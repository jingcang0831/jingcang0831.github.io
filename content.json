{"meta":{"title":"zy-blog","subtitle":"摆烂中....","description":"开发随笔","author":"zy","url":"http://example.com","root":"/"},"pages":[{"title":"💡 努力的意义就是好运来临的时候我觉得我值得💡","date":"2023-06-15T08:14:58.000Z","updated":"2023-06-30T07:48:48.690Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"spring-security实现简单后台管理系统（后端） vue3+js 实现简单商城系统（前端） spring-ioc简单实现（源码）"},{"title":"分类","date":"2023-06-16T02:24:33.000Z","updated":"2023-06-16T06:30:01.543Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"💡 努力的意义就是好运来临的时候我觉得我值得💡","date":"2023-06-16T02:30:13.000Z","updated":"2023-06-30T07:49:07.371Z","comments":true,"path":"index.html","permalink":"http://example.com/index.html","excerpt":"","text":"spring-security实现简单后台管理系统（后端） vue3+js 实现简单商城系统（前端） spring-ioc简单实现（源码）"},{"title":"tags","date":"2023-06-16T02:30:13.000Z","updated":"2023-06-16T02:31:36.684Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"elk（十四）-安装文档","slug":"elk/elk（十四）-安装文档","date":"2023-06-30T07:43:39.000Z","updated":"2023-06-30T07:45:11.922Z","comments":true,"path":"2023/06/30/elk/elk（十四）-安装文档/","link":"","permalink":"http://example.com/2023/06/30/elk/elk%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89-%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/","excerpt":"","text":"安装elasticsearch1.部署单点es1.1.创建网络因为我们还需要部署kibana容器，因此需要让es和kibana容器互联。这里先创建一个网络： 1docker network create es-net 1.2.加载镜像这里我们采用elasticsearch的7.12.1版本的镜像，这个镜像体积非常大，接近1G。不建议大家自己pull。 课前资料提供了镜像的tar包： 大家将其上传到虚拟机中，然后运行命令加载即可： 12# 导入数据docker load -i es.tar 同理还有kibana的tar包也需要这样做。 1.3.运行运行docker命令，部署单点es： 1234567891011docker run -d \\ --name es \\ -e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; \\ -e &quot;discovery.type=single-node&quot; \\ -v es-data:/usr/share/elasticsearch/data \\ -v es-plugins:/usr/share/elasticsearch/plugins \\ --privileged \\ --network es-net \\ -p 9200:9200 \\ -p 9300:9300 \\elasticsearch:7.12.1 命令解释： -e &quot;cluster.name=es-docker-cluster&quot;：设置集群名称 -e &quot;http.host=0.0.0.0&quot;：监听的地址，可以外网访问 -e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;：内存大小 -e &quot;discovery.type=single-node&quot;：非集群模式 -v es-data:/usr/share/elasticsearch/data：挂载逻辑卷，绑定es的数据目录 -v es-logs:/usr/share/elasticsearch/logs：挂载逻辑卷，绑定es的日志目录 -v es-plugins:/usr/share/elasticsearch/plugins：挂载逻辑卷，绑定es的插件目录 --privileged：授予逻辑卷访问权 --network es-net ：加入一个名为es-net的网络中 -p 9200:9200：端口映射配置 在浏览器中输入：http://192.168.150.101:9200 即可看到elasticsearch的响应结果： 2.部署kibanakibana可以给我们提供一个elasticsearch的可视化界面，便于我们学习。 2.1.部署运行docker命令，部署kibana 123456docker run -d \\--name kibana \\-e ELASTICSEARCH_HOSTS=http://es:9200 \\--network=es-net \\-p 5601:5601 \\kibana:7.12.1 --network es-net ：加入一个名为es-net的网络中，与elasticsearch在同一个网络中 -e ELASTICSEARCH_HOSTS=http://es:9200&quot;：设置elasticsearch的地址，因为kibana已经与elasticsearch在一个网络，因此可以用容器名直接访问elasticsearch -p 5601:5601：端口映射配置 kibana启动一般比较慢，需要多等待一会，可以通过命令： 1docker logs -f kibana 查看运行日志，当查看到下面的日志，说明成功： 此时，在浏览器输入地址访问：http://192.168.150.101:5601，即可看到结果 2.2.DevToolskibana中提供了一个DevTools界面： 这个界面中可以编写DSL来操作elasticsearch。并且对DSL语句有自动补全功能。 3.安装IK分词器3.1.在线安装ik插件（较慢）12345678910# 进入容器内部docker exec -it elasticsearch /bin/bash# 在线下载并安装./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip#退出exit#重启容器docker restart elasticsearch 3.2.离线安装ik插件（推荐）1）查看数据卷目录安装插件需要知道elasticsearch的plugins目录位置，而我们用了数据卷挂载，因此需要查看elasticsearch的数据卷目录，通过下面命令查看: 1docker volume inspect es-plugins 显示结果： 1234567891011[ &#123; &quot;CreatedAt&quot;: &quot;2022-05-06T10:06:34+08:00&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Labels&quot;: null, &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/es-plugins/_data&quot;, &quot;Name&quot;: &quot;es-plugins&quot;, &quot;Options&quot;: null, &quot;Scope&quot;: &quot;local&quot; &#125;] 说明plugins目录被挂载到了：/var/lib/docker/volumes/es-plugins/_data 这个目录中。 2）解压缩分词器安装包下面我们需要把课前资料中的ik分词器解压缩，重命名为ik 3）上传到es容器的插件数据卷中也就是/var/lib/docker/volumes/es-plugins/_data ： 4）重启容器12# 4、重启容器docker restart es 12# 查看es日志docker logs -f es 5）测试：IK分词器包含两种模式： ik_smart：最少切分 ik_max_word：最细切分 12345GET /_analyze&#123; &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;text&quot;: &quot;黑马程序员学习java太棒了&quot;&#125; 结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&#123; &quot;tokens&quot; : [ &#123; &quot;token&quot; : &quot;黑马&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 2, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 0 &#125;, &#123; &quot;token&quot; : &quot;程序员&quot;, &quot;start_offset&quot; : 2, &quot;end_offset&quot; : 5, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 1 &#125;, &#123; &quot;token&quot; : &quot;程序&quot;, &quot;start_offset&quot; : 2, &quot;end_offset&quot; : 4, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 2 &#125;, &#123; &quot;token&quot; : &quot;员&quot;, &quot;start_offset&quot; : 4, &quot;end_offset&quot; : 5, &quot;type&quot; : &quot;CN_CHAR&quot;, &quot;position&quot; : 3 &#125;, &#123; &quot;token&quot; : &quot;学习&quot;, &quot;start_offset&quot; : 5, &quot;end_offset&quot; : 7, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 4 &#125;, &#123; &quot;token&quot; : &quot;java&quot;, &quot;start_offset&quot; : 7, &quot;end_offset&quot; : 11, &quot;type&quot; : &quot;ENGLISH&quot;, &quot;position&quot; : 5 &#125;, &#123; &quot;token&quot; : &quot;太棒了&quot;, &quot;start_offset&quot; : 11, &quot;end_offset&quot; : 14, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 6 &#125;, &#123; &quot;token&quot; : &quot;太棒&quot;, &quot;start_offset&quot; : 11, &quot;end_offset&quot; : 13, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 7 &#125;, &#123; &quot;token&quot; : &quot;了&quot;, &quot;start_offset&quot; : 13, &quot;end_offset&quot; : 14, &quot;type&quot; : &quot;CN_CHAR&quot;, &quot;position&quot; : 8 &#125; ]&#125; 3.3 扩展词词典随着互联网的发展，“造词运动”也越发的频繁。出现了很多新的词语，在原有的词汇列表中并不存在。比如：“奥力给”，“传智播客” 等。 所以我们的词汇也需要不断的更新，IK分词器提供了扩展词汇的功能。 1）打开IK分词器config目录： 2）在IKAnalyzer.cfg.xml配置文件内容添加： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;&lt;properties&gt; &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt; &lt;!--用户可以在这里配置自己的扩展字典 *** 添加扩展词典--&gt; &lt;entry key=&quot;ext_dict&quot;&gt;ext.dic&lt;/entry&gt;&lt;/properties&gt; 3）新建一个 ext.dic，可以参考config目录下复制一个配置文件进行修改 12传智播客奥力给 4）重启elasticsearch 1234docker restart es# 查看 日志docker logs -f elasticsearch 日志中已经成功加载ext.dic配置文件 5）测试效果： 12345GET /_analyze&#123; &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;text&quot;: &quot;传智播客Java就业超过90%,奥力给！&quot;&#125; 注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑 3.4 停用词词典在互联网项目中，在网络间传输的速度很快，所以很多语言是不允许在网络上传递的，如：关于宗教、政治等敏感词语，那么我们在搜索时也应该忽略当前词汇。 IK分词器也提供了强大的停用词功能，让我们在索引时就直接忽略当前的停用词汇表中的内容。 1）IKAnalyzer.cfg.xml配置文件内容添加： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;&lt;properties&gt; &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt; &lt;!--用户可以在这里配置自己的扩展字典--&gt; &lt;entry key=&quot;ext_dict&quot;&gt;ext.dic&lt;/entry&gt; &lt;!--用户可以在这里配置自己的扩展停止词字典 *** 添加停用词词典--&gt; &lt;entry key=&quot;ext_stopwords&quot;&gt;stopword.dic&lt;/entry&gt;&lt;/properties&gt; 3）在 stopword.dic 添加停用词 1习大大 4）重启elasticsearch 123456# 重启服务docker restart elasticsearchdocker restart kibana# 查看 日志docker logs -f elasticsearch 日志中已经成功加载stopword.dic配置文件 5）测试效果： 12345GET /_analyze&#123; &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;text&quot;: &quot;传智播客Java就业率超过95%,习大大都点赞,奥力给！&quot;&#125; 注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑 4.部署es集群我们会在单机上利用docker容器运行多个es实例来模拟es集群。不过生产环境推荐大家每一台服务节点仅部署一个es的实例。 部署es集群可以直接使用docker-compose来完成，但这要求你的Linux虚拟机至少有4G的内存空间 4.1.创建es集群首先编写一个docker-compose文件，内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758version: &#x27;2.2&#x27;services: es01: image: elasticsearch:7.12.1 container_name: es01 environment: - node.name=es01 - cluster.name=es-docker-cluster - discovery.seed_hosts=es02,es03 - cluster.initial_master_nodes=es01,es02,es03 - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; volumes: - data01:/usr/share/elasticsearch/data ports: - 9200:9200 networks: - elastic es02: image: elasticsearch:7.12.1 container_name: es02 environment: - node.name=es02 - cluster.name=es-docker-cluster - discovery.seed_hosts=es01,es03 - cluster.initial_master_nodes=es01,es02,es03 - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; volumes: - data02:/usr/share/elasticsearch/data ports: - 9201:9200 networks: - elastic es03: image: elasticsearch:7.12.1 container_name: es03 environment: - node.name=es03 - cluster.name=es-docker-cluster - discovery.seed_hosts=es01,es02 - cluster.initial_master_nodes=es01,es02,es03 - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; volumes: - data03:/usr/share/elasticsearch/data networks: - elastic ports: - 9202:9200volumes: data01: driver: local data02: driver: local data03: driver: localnetworks: elastic: driver: bridge es运行需要修改一些linux系统权限，修改/etc/sysctl.conf文件 1vi /etc/sysctl.conf 添加下面的内容： 1vm.max_map_count=262144 然后执行命令，让配置生效： 1sysctl -p 通过docker-compose启动集群： 1docker-compose up -d 4.2.集群状态监控kibana可以监控es集群，不过新版本需要依赖es的x-pack 功能，配置比较复杂。 这里推荐使用cerebro来监控es集群状态，官方网址：https://github.com/lmenezes/cerebro 课前资料已经提供了安装包： 解压即可使用，非常方便。 解压好的目录如下： 进入对应的bin目录： 双击其中的cerebro.bat文件即可启动服务。 访问http://localhost:9000 即可进入管理界面： 输入你的elasticsearch的任意节点的地址和端口，点击connect即可： 绿色的条，代表集群处于绿色（健康状态）。 4.3.创建索引库1）利用kibana的DevTools创建索引库在DevTools中输入指令： 123456789101112PUT /itcast&#123; &quot;settings&quot;: &#123; &quot;number_of_shards&quot;: 3, // 分片数量 &quot;number_of_replicas&quot;: 1 // 副本数量 &#125;, &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; // mapping映射定义 ... &#125; &#125;&#125; 2）利用cerebro创建索引库利用cerebro还可以创建索引库： 填写索引库信息： 点击右下角的create按钮： 4.4.查看分片效果回到首页，即可查看索引库分片效果：","categories":[{"name":"elk","slug":"elk","permalink":"http://example.com/elk/"}],"tags":[{"name":"elk","slug":"elk","permalink":"http://example.com/tags/elk/"}]},{"title":"elk（十三）-集群","slug":"elk/elk（十三）-集群","date":"2023-06-30T07:40:37.000Z","updated":"2023-06-30T07:45:06.805Z","comments":true,"path":"2023/06/30/elk/elk（十三）-集群/","link":"","permalink":"http://example.com/2023/06/30/elk/elk%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89-%E9%9B%86%E7%BE%A4/","excerpt":"","text":"4.集群单机的elasticsearch做数据存储，必然面临两个问题：海量数据存储问题、单点故障问题。 海量数据存储问题：将索引库从逻辑上拆分为N个分片（shard），存储到多个节点 单点故障问题：将分片数据在不同节点备份（replica ） ES集群相关概念: 集群（cluster）：一组拥有共同的 cluster name 的 节点。 节点（node) ：集群中的一个 Elasticearch 实例 分片（shard）：索引可以被拆分为不同的部分进行存储，称为分片。在集群环境下，一个索引的不同分片可以拆分到不同的节点中 解决问题：数据量太大，单点存储量有限的问题。 此处，我们把数据分成3片：shard0、shard1、shard2 主分片（Primary shard）：相对于副本分片的定义。 副本分片（Replica shard）每个主分片可以有一个或者多个副本，数据和主分片一样。 ​ 数据备份可以保证高可用，但是每个分片备份一份，所需要的节点数量就会翻一倍，成本实在是太高了！ 为了在高可用和成本间寻求平衡，我们可以这样做： 首先对数据分片，存储到不同节点 然后对每个分片进行备份，放到对方节点，完成互相备份 这样可以大大减少所需要的服务节点数量，如图，我们以3分片，每个分片备份一份为例： 现在，每个分片都有1个备份，存储在3个节点： node0：保存了分片0和1 node1：保存了分片0和2 node2：保存了分片1和2 4.1.搭建ES集群参考课前资料的文档： 其中的第四章节： 4.2.集群脑裂问题4.2.1.集群职责划分elasticsearch中集群节点有不同的职责划分： 默认情况下，集群中的任何一个节点都同时具备上述四种角色。 但是真实的集群一定要将集群职责分离： master节点：对CPU要求高，但是内存要求第 data节点：对CPU和内存要求都高 coordinating节点：对网络带宽、CPU要求高 职责分离可以让我们根据不同节点的需求分配不同的硬件去部署。而且避免业务之间的互相干扰。 一个典型的es集群职责划分如图： 4.2.2.脑裂问题脑裂是因为集群中的节点失联导致的。 例如一个集群中，主节点与其它节点失联： 此时，node2和node3认为node1宕机，就会重新选主： 当node3当选后，集群继续对外提供服务，node2和node3自成集群，node1自成集群，两个集群数据不同步，出现数据差异。 当网络恢复后，因为集群中有两个master节点，集群状态的不一致，出现脑裂的情况： 解决脑裂的方案是，要求选票超过 ( eligible节点数量 + 1 ）&#x2F; 2 才能当选为主，因此eligible节点数量最好是奇数。对应配置项是discovery.zen.minimum_master_nodes，在es7.0以后，已经成为默认配置，因此一般不会发生脑裂问题 例如：3个节点形成的集群，选票必须超过 （3 + 1） &#x2F; 2 ，也就是2票。node3得到node2和node3的选票，当选为主。node1只有自己1票，没有当选。集群中依然只有1个主节点，没有出现脑裂。 4.2.3.小结master eligible节点的作用是什么？ 参与集群选主 主节点可以管理集群状态、管理分片信息、处理创建和删除索引库的请求 data节点的作用是什么？ 数据的CRUD coordinator节点的作用是什么？ 路由请求到其它节点 合并查询到的结果，返回给用户 4.3.集群分布式存储当新增文档时，应该保存到不同分片，保证数据均衡，那么coordinating node如何确定数据该存储到哪个分片呢？ 4.3.1.分片存储测试插入三条数据： 测试可以看到，三条数据分别在不同分片： 结果： 4.3.2.分片存储原理elasticsearch会通过hash算法来计算文档应该存储到哪个分片： 说明： _routing默认是文档的id 算法与分片数量有关，因此索引库一旦创建，分片数量不能修改！ 新增文档的流程如下： 解读： 1）新增一个id&#x3D;1的文档 2）对id做hash运算，假如得到的是2，则应该存储到shard-2 3）shard-2的主分片在node3节点，将数据路由到node3 4）保存文档 5）同步给shard-2的副本replica-2，在node2节点 6）返回结果给coordinating-node节点 4.4.集群分布式查询elasticsearch的查询分成两个阶段： scatter phase：分散阶段，coordinating node会把请求分发到每一个分片 gather phase：聚集阶段，coordinating node汇总data node的搜索结果，并处理为最终结果集返回给用户 4.5.集群故障转移集群的master节点会监控集群中的节点状态，如果发现有节点宕机，会立即将宕机节点的分片数据迁移到其它节点，确保数据安全，这个叫做故障转移。 1）例如一个集群结构如图： 现在，node1是主节点，其它两个节点是从节点。 2）突然，node1发生了故障： 宕机后的第一件事，需要重新选主，例如选中了node2： node2成为主节点后，会检测集群监控状态，发现：shard-1、shard-0没有副本节点。因此需要将node1上的数据迁移到node2、node3：","categories":[{"name":"elk","slug":"elk","permalink":"http://example.com/elk/"}],"tags":[{"name":"elk","slug":"elk","permalink":"http://example.com/tags/elk/"}]},{"title":"elk（十二）-数据同步","slug":"elk/elk（十二）-数据同步","date":"2023-06-30T07:39:15.000Z","updated":"2023-06-30T07:45:02.445Z","comments":true,"path":"2023/06/30/elk/elk（十二）-数据同步/","link":"","permalink":"http://example.com/2023/06/30/elk/elk%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89-%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/","excerpt":"","text":"3.数据同步elasticsearch中的酒店数据来自于mysql数据库，因此mysql数据发生改变时，elasticsearch也必须跟着改变，这个就是elasticsearch与mysql之间的数据同步。 3.1.思路分析常见的数据同步方案有三种： 同步调用 异步通知 监听binlog 3.1.1.同步调用方案一：同步调用 基本步骤如下： hotel-demo对外提供接口，用来修改elasticsearch中的数据 酒店管理服务在完成数据库操作后，直接调用hotel-demo提供的接口， 3.1.2.异步通知方案二：异步通知 流程如下： hotel-admin对mysql数据库数据完成增、删、改后，发送MQ消息 hotel-demo监听MQ，接收到消息后完成elasticsearch数据修改 3.1.3.监听binlog方案三：监听binlog 流程如下： 给mysql开启binlog功能 mysql完成增、删、改操作都会记录在binlog中 hotel-demo基于canal监听binlog变化，实时更新elasticsearch中的内容 3.1.4.选择方式一：同步调用 优点：实现简单，粗暴 缺点：业务耦合度高 方式二：异步通知 优点：低耦合，实现难度一般 缺点：依赖mq的可靠性 方式三：监听binlog 优点：完全解除服务间耦合 缺点：开启binlog增加数据库负担、实现复杂度高 3.2.实现数据同步3.2.1.思路利用课前资料提供的hotel-admin项目作为酒店管理的微服务。当酒店数据发生增、删、改时，要求对elasticsearch中数据也要完成相同操作。 步骤： 导入课前资料提供的hotel-admin项目，启动并测试酒店数据的CRUD 声明exchange、queue、RoutingKey 在hotel-admin中的增、删、改业务中完成消息发送 在hotel-demo中完成消息监听，并更新elasticsearch中数据 启动并测试数据同步功能 3.2.2.导入demo导入课前资料提供的hotel-admin项目： 运行后，访问 http://localhost:8099 其中包含了酒店的CRUD功能： 3.2.3.声明交换机、队列MQ结构如图： 1）引入依赖在hotel-admin、hotel-demo中引入rabbitmq的依赖： 12345&lt;!--amqp--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 2）声明队列交换机名称在hotel-admin和hotel-demo中的cn.itcast.hotel.constatnts包下新建一个类MqConstants： 123456789101112131415161718192021222324package cn.itcast.hotel.constatnts; public class MqConstants &#123; /** * 交换机 */ public final static String HOTEL_EXCHANGE = &quot;hotel.topic&quot;; /** * 监听新增和修改的队列 */ public final static String HOTEL_INSERT_QUEUE = &quot;hotel.insert.queue&quot;; /** * 监听删除的队列 */ public final static String HOTEL_DELETE_QUEUE = &quot;hotel.delete.queue&quot;; /** * 新增或修改的RoutingKey */ public final static String HOTEL_INSERT_KEY = &quot;hotel.insert&quot;; /** * 删除的RoutingKey */ public final static String HOTEL_DELETE_KEY = &quot;hotel.delete&quot;;&#125; 3）声明队列交换机在hotel-demo中，定义配置类，声明队列、交换机： 12345678910111213141516171819202122232425262728293031323334353637package cn.itcast.hotel.config;import cn.itcast.hotel.constants.MqConstants;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.Queue;import org.springframework.amqp.core.TopicExchange;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class MqConfig &#123; @Bean public TopicExchange topicExchange()&#123; return new TopicExchange(MqConstants.HOTEL_EXCHANGE, true, false); &#125; @Bean public Queue insertQueue()&#123; return new Queue(MqConstants.HOTEL_INSERT_QUEUE, true); &#125; @Bean public Queue deleteQueue()&#123; return new Queue(MqConstants.HOTEL_DELETE_QUEUE, true); &#125; @Bean public Binding insertQueueBinding()&#123; return BindingBuilder.bind(insertQueue()).to(topicExchange()).with(MqConstants.HOTEL_INSERT_KEY); &#125; @Bean public Binding deleteQueueBinding()&#123; return BindingBuilder.bind(deleteQueue()).to(topicExchange()).with(MqConstants.HOTEL_DELETE_KEY); &#125;&#125; 3.2.4.发送MQ消息在hotel-admin中的增、删、改业务中分别发送MQ消息： 3.2.5.接收MQ消息hotel-demo接收到MQ消息要做的事情包括： 新增消息：根据传递的hotel的id查询hotel信息，然后新增一条数据到索引库 删除消息：根据传递的hotel的id删除索引库中的一条数据 1）首先在hotel-demo的cn.itcast.hotel.service包下的IHotelService中新增新增、删除业务 123void deleteById(Long id);void insertById(Long id); 2）给hotel-demo中的cn.itcast.hotel.service.impl包下的HotelService中实现业务： 123456789101112131415161718192021222324252627282930@Overridepublic void deleteById(Long id) &#123; try &#123; // 1.准备Request DeleteRequest request = new DeleteRequest(&quot;hotel&quot;, id.toString()); // 2.发送请求 client.delete(request, RequestOptions.DEFAULT); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125;&#125;@Overridepublic void insertById(Long id) &#123; try &#123; // 0.根据id查询酒店数据 Hotel hotel = getById(id); // 转换为文档类型 HotelDoc hotelDoc = new HotelDoc(hotel); // 1.准备Request对象 IndexRequest request = new IndexRequest(&quot;hotel&quot;).id(hotel.getId().toString()); // 2.准备Json文档 request.source(JSON.toJSONString(hotelDoc), XContentType.JSON); // 3.发送请求 client.index(request, RequestOptions.DEFAULT); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125;&#125; 3）编写监听器 在hotel-demo中的cn.itcast.hotel.mq包新增一个类： 1234567891011121314151617181920212223242526272829303132package cn.itcast.hotel.mq;import cn.itcast.hotel.constants.MqConstants;import cn.itcast.hotel.service.IHotelService;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;@Componentpublic class HotelListener &#123; @Autowired private IHotelService hotelService; /** * 监听酒店新增或修改的业务 * @param id 酒店id */ @RabbitListener(queues = MqConstants.HOTEL_INSERT_QUEUE) public void listenHotelInsertOrUpdate(Long id)&#123; hotelService.insertById(id); &#125; /** * 监听酒店删除的业务 * @param id 酒店id */ @RabbitListener(queues = MqConstants.HOTEL_DELETE_QUEUE) public void listenHotelDelete(Long id)&#123; hotelService.deleteById(id); &#125;&#125;","categories":[{"name":"elk","slug":"elk","permalink":"http://example.com/elk/"}],"tags":[{"name":"elk","slug":"elk","permalink":"http://example.com/tags/elk/"}]},{"title":"elk（十一）-自动补全","slug":"elk/elk（十一）-自动补全","date":"2023-06-30T07:38:02.000Z","updated":"2023-06-30T07:45:15.947Z","comments":true,"path":"2023/06/30/elk/elk（十一）-自动补全/","link":"","permalink":"http://example.com/2023/06/30/elk/elk%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89-%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8/","excerpt":"","text":"2.自动补全当用户在搜索框输入字符时，我们应该提示出与该字符有关的搜索项，如图： 这种根据用户输入的字母，提示完整词条的功能，就是自动补全了。 因为需要根据拼音字母来推断，因此要用到拼音分词功能。 2.1.拼音分词器要实现根据字母做补全，就必须对文档按照拼音分词。在GitHub上恰好有elasticsearch的拼音分词插件。地址：https://github.com/medcl/elasticsearch-analysis-pinyin 课前资料中也提供了拼音分词器的安装包： 安装方式与IK分词器一样，分三步： ​ ①解压 ​ ②上传到虚拟机中，elasticsearch的plugin目录 ​ ③重启elasticsearch ​ ④测试 详细安装步骤可以参考IK分词器的安装过程。 测试用法如下： 12345POST /_analyze&#123; &quot;text&quot;: &quot;如家酒店还不错&quot;, &quot;analyzer&quot;: &quot;pinyin&quot;&#125; 结果： 2.2.自定义分词器默认的拼音分词器会将每个汉字单独分为拼音，而我们希望的是每个词条形成一组拼音，需要对拼音分词器做个性化定制，形成自定义分词器。 elasticsearch中分词器（analyzer）的组成包含三部分： character filters：在tokenizer之前对文本进行处理。例如删除字符、替换字符 tokenizer：将文本按照一定的规则切割成词条（term）。例如keyword，就是不分词；还有ik_smart tokenizer filter：将tokenizer输出的词条做进一步处理。例如大小写转换、同义词处理、拼音处理等 文档分词时会依次由这三部分来处理文档： 声明自定义分词器的语法如下： 123456789101112131415161718192021222324252627282930313233PUT /test&#123; &quot;settings&quot;: &#123; &quot;analysis&quot;: &#123; &quot;analyzer&quot;: &#123; // 自定义分词器 &quot;my_analyzer&quot;: &#123; // 分词器名称 &quot;tokenizer&quot;: &quot;ik_max_word&quot;, &quot;filter&quot;: &quot;py&quot; &#125; &#125;, &quot;filter&quot;: &#123; // 自定义tokenizer filter &quot;py&quot;: &#123; // 过滤器名称 &quot;type&quot;: &quot;pinyin&quot;, // 过滤器类型，这里是pinyin &quot;keep_full_pinyin&quot;: false, &quot;keep_joined_full_pinyin&quot;: true, &quot;keep_original&quot;: true, &quot;limit_first_letter_length&quot;: 16, &quot;remove_duplicated_term&quot;: true, &quot;none_chinese_pinyin_tokenize&quot;: false &#125; &#125; &#125; &#125;, &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;name&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;my_analyzer&quot;, &quot;search_analyzer&quot;: &quot;ik_smart&quot; &#125; &#125; &#125;&#125; 测试： 总结： 如何使用拼音分词器？ ①下载pinyin分词器 ②解压并放到elasticsearch的plugin目录 ③重启即可 如何自定义分词器？ ①创建索引库时，在settings中配置，可以包含三部分 ②character filter ③tokenizer ④filter 拼音分词器注意事项？ 为了避免搜索到同音字，搜索时不要使用拼音分词器 2.3.自动补全查询elasticsearch提供了Completion Suggester查询来实现自动补全功能。这个查询会匹配以用户输入内容开头的词条并返回。为了提高补全查询的效率，对于文档中字段的类型有一些约束： 参与补全查询的字段必须是completion类型。 字段的内容一般是用来补全的多个词条形成的数组。 比如，一个这样的索引库： 1234567891011// 创建索引库PUT test&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;title&quot;:&#123; &quot;type&quot;: &quot;completion&quot; &#125; &#125; &#125;&#125; 然后插入下面的数据： 12345678910111213// 示例数据POST test/_doc&#123; &quot;title&quot;: [&quot;Sony&quot;, &quot;WH-1000XM3&quot;]&#125;POST test/_doc&#123; &quot;title&quot;: [&quot;SK-II&quot;, &quot;PITERA&quot;]&#125;POST test/_doc&#123; &quot;title&quot;: [&quot;Nintendo&quot;, &quot;switch&quot;]&#125; 查询的DSL语句如下： 1234567891011121314// 自动补全查询GET /test/_search&#123; &quot;suggest&quot;: &#123; &quot;title_suggest&quot;: &#123; &quot;text&quot;: &quot;s&quot;, // 关键字 &quot;completion&quot;: &#123; &quot;field&quot;: &quot;title&quot;, // 补全查询的字段 &quot;skip_duplicates&quot;: true, // 跳过重复的 &quot;size&quot;: 10 // 获取前10条结果 &#125; &#125; &#125;&#125; 2.4.实现酒店搜索框自动补全现在，我们的hotel索引库还没有设置拼音分词器，需要修改索引库中的配置。但是我们知道索引库是无法修改的，只能删除然后重新创建。 另外，我们需要添加一个字段，用来做自动补全，将brand、suggestion、city等都放进去，作为自动补全的提示。 因此，总结一下，我们需要做的事情包括： 修改hotel索引库结构，设置自定义拼音分词器 修改索引库的name、all字段，使用自定义分词器 索引库添加一个新字段suggestion，类型为completion类型，使用自定义的分词器 给HotelDoc类添加suggestion字段，内容包含brand、business 重新导入数据到hotel库 2.4.1.修改酒店映射结构代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// 酒店数据索引库PUT /hotel&#123; &quot;settings&quot;: &#123; &quot;analysis&quot;: &#123; &quot;analyzer&quot;: &#123; &quot;text_anlyzer&quot;: &#123; &quot;tokenizer&quot;: &quot;ik_max_word&quot;, &quot;filter&quot;: &quot;py&quot; &#125;, &quot;completion_analyzer&quot;: &#123; &quot;tokenizer&quot;: &quot;keyword&quot;, &quot;filter&quot;: &quot;py&quot; &#125; &#125;, &quot;filter&quot;: &#123; &quot;py&quot;: &#123; &quot;type&quot;: &quot;pinyin&quot;, &quot;keep_full_pinyin&quot;: false, &quot;keep_joined_full_pinyin&quot;: true, &quot;keep_original&quot;: true, &quot;limit_first_letter_length&quot;: 16, &quot;remove_duplicated_term&quot;: true, &quot;none_chinese_pinyin_tokenize&quot;: false &#125; &#125; &#125; &#125;, &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;id&quot;:&#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;name&quot;:&#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;text_anlyzer&quot;, &quot;search_analyzer&quot;: &quot;ik_smart&quot;, &quot;copy_to&quot;: &quot;all&quot; &#125;, &quot;address&quot;:&#123; &quot;type&quot;: &quot;keyword&quot;, &quot;index&quot;: false &#125;, &quot;price&quot;:&#123; &quot;type&quot;: &quot;integer&quot; &#125;, &quot;score&quot;:&#123; &quot;type&quot;: &quot;integer&quot; &#125;, &quot;brand&quot;:&#123; &quot;type&quot;: &quot;keyword&quot;, &quot;copy_to&quot;: &quot;all&quot; &#125;, &quot;city&quot;:&#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;starName&quot;:&#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;business&quot;:&#123; &quot;type&quot;: &quot;keyword&quot;, &quot;copy_to&quot;: &quot;all&quot; &#125;, &quot;location&quot;:&#123; &quot;type&quot;: &quot;geo_point&quot; &#125;, &quot;pic&quot;:&#123; &quot;type&quot;: &quot;keyword&quot;, &quot;index&quot;: false &#125;, &quot;all&quot;:&#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;text_anlyzer&quot;, &quot;search_analyzer&quot;: &quot;ik_smart&quot; &#125;, &quot;suggestion&quot;:&#123; &quot;type&quot;: &quot;completion&quot;, &quot;analyzer&quot;: &quot;completion_analyzer&quot; &#125; &#125; &#125;&#125; 2.4.2.修改HotelDoc实体HotelDoc中要添加一个字段，用来做自动补全，内容可以是酒店品牌、城市、商圈等信息。按照自动补全字段的要求，最好是这些字段的数组。 因此我们在HotelDoc中添加一个suggestion字段，类型为List&lt;String&gt;，然后将brand、city、business等信息放到里面。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package cn.itcast.hotel.pojo;import lombok.Data;import lombok.NoArgsConstructor;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.List;@Data@NoArgsConstructorpublic class HotelDoc &#123; private Long id; private String name; private String address; private Integer price; private Integer score; private String brand; private String city; private String starName; private String business; private String location; private String pic; private Object distance; private Boolean isAD; private List&lt;String&gt; suggestion; public HotelDoc(Hotel hotel) &#123; this.id = hotel.getId(); this.name = hotel.getName(); this.address = hotel.getAddress(); this.price = hotel.getPrice(); this.score = hotel.getScore(); this.brand = hotel.getBrand(); this.city = hotel.getCity(); this.starName = hotel.getStarName(); this.business = hotel.getBusiness(); this.location = hotel.getLatitude() + &quot;, &quot; + hotel.getLongitude(); this.pic = hotel.getPic(); // 组装suggestion if(this.business.contains(&quot;/&quot;))&#123; // business有多个值，需要切割 String[] arr = this.business.split(&quot;/&quot;); // 添加元素 this.suggestion = new ArrayList&lt;&gt;(); this.suggestion.add(this.brand); Collections.addAll(this.suggestion, arr); &#125;else &#123; this.suggestion = Arrays.asList(this.brand, this.business); &#125; &#125;&#125; 2.4.3.重新导入重新执行之前编写的导入数据功能，可以看到新的酒店数据中包含了suggestion： 2.4.4.自动补全查询的JavaAPI之前我们学习了自动补全查询的DSL，而没有学习对应的JavaAPI，这里给出一个示例： 而自动补全的结果也比较特殊，解析的代码如下： 2.4.5.实现搜索框自动补全查看前端页面，可以发现当我们在输入框键入时，前端会发起ajax请求： 返回值是补全词条的集合，类型为List&lt;String&gt; 1）在cn.itcast.hotel.web包下的HotelController中添加新接口，接收新的请求： 1234@GetMapping(&quot;suggestion&quot;)public List&lt;String&gt; getSuggestions(@RequestParam(&quot;key&quot;) String prefix) &#123; return hotelService.getSuggestions(prefix);&#125; 2）在cn.itcast.hotel.service包下的IhotelService中添加方法： 1List&lt;String&gt; getSuggestions(String prefix); 3）在cn.itcast.hotel.service.impl.HotelService中实现该方法： 1234567891011121314151617181920212223242526272829303132@Overridepublic List&lt;String&gt; getSuggestions(String prefix) &#123; try &#123; // 1.准备Request SearchRequest request = new SearchRequest(&quot;hotel&quot;); // 2.准备DSL request.source().suggest(new SuggestBuilder().addSuggestion( &quot;suggestions&quot;, SuggestBuilders.completionSuggestion(&quot;suggestion&quot;) .prefix(prefix) .skipDuplicates(true) .size(10) )); // 3.发起请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析结果 Suggest suggest = response.getSuggest(); // 4.1.根据补全查询名称，获取补全结果 CompletionSuggestion suggestions = suggest.getSuggestion(&quot;suggestions&quot;); // 4.2.获取options List&lt;CompletionSuggestion.Entry.Option&gt; options = suggestions.getOptions(); // 4.3.遍历 List&lt;String&gt; list = new ArrayList&lt;&gt;(options.size()); for (CompletionSuggestion.Entry.Option option : options) &#123; String text = option.getText().toString(); list.add(text); &#125; return list; &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125;&#125;","categories":[{"name":"elk","slug":"elk","permalink":"http://example.com/elk/"}],"tags":[{"name":"elk","slug":"elk","permalink":"http://example.com/tags/elk/"}]},{"title":"elk（十）-数据聚合","slug":"elk/elk（十）-数据聚合","date":"2023-06-30T07:36:37.000Z","updated":"2023-06-30T07:44:56.584Z","comments":true,"path":"2023/06/30/elk/elk（十）-数据聚合/","link":"","permalink":"http://example.com/2023/06/30/elk/elk%EF%BC%88%E5%8D%81%EF%BC%89-%E6%95%B0%E6%8D%AE%E8%81%9A%E5%90%88/","excerpt":"","text":"1.数据聚合**聚合（aggregations）**可以让我们极其方便的实现对数据的统计、分析、运算。例如： 什么品牌的手机最受欢迎？ 这些手机的平均价格、最高价格、最低价格？ 这些手机每月的销售情况如何？ 实现这些统计功能的比数据库的sql要方便的多，而且查询速度非常快，可以实现近实时搜索效果。 1.1.聚合的种类聚合常见的有三类： 桶（Bucket）聚合：用来对文档做分组 TermAggregation：按照文档字段值分组，例如按照品牌值分组、按照国家分组 Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组 度量（Metric）聚合：用以计算一些值，比如：最大值、最小值、平均值等 Avg：求平均值 Max：求最大值 Min：求最小值 Stats：同时求max、min、avg、sum等 管道（pipeline）聚合：其它聚合的结果为基础做聚合 注意：参加聚合的字段必须是keyword、日期、数值、布尔类型 1.2.DSL实现聚合现在，我们要统计所有数据中的酒店品牌有几种，其实就是按照品牌对数据分组。此时可以根据酒店品牌的名称做聚合，也就是Bucket聚合。 1.2.1.Bucket聚合语法语法如下： 123456789101112GET /hotel/_search&#123; &quot;size&quot;: 0, // 设置size为0，结果中不包含文档，只包含聚合结果 &quot;aggs&quot;: &#123; // 定义聚合 &quot;brandAgg&quot;: &#123; //给聚合起个名字 &quot;terms&quot;: &#123; // 聚合的类型，按照品牌值聚合，所以选择term &quot;field&quot;: &quot;brand&quot;, // 参与聚合的字段 &quot;size&quot;: 20 // 希望获取的聚合结果数量 &#125; &#125; &#125;&#125; 结果如图： 1.2.2.聚合结果排序默认情况下，Bucket聚合会统计Bucket内的文档数量，记为_count，并且按照_count降序排序。 我们可以指定order属性，自定义聚合的排序方式： 123456789101112131415GET /hotel/_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;brandAgg&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;brand&quot;, &quot;order&quot;: &#123; &quot;_count&quot;: &quot;asc&quot; // 按照_count升序排列 &#125;, &quot;size&quot;: 20 &#125; &#125; &#125;&#125; 1.2.3.限定聚合范围默认情况下，Bucket聚合是对索引库的所有文档做聚合，但真实场景下，用户会输入搜索条件，因此聚合必须是对搜索结果聚合。那么聚合必须添加限定条件。 我们可以限定要聚合的文档范围，只要添加query条件即可： 12345678910111213141516171819GET /hotel/_search&#123; &quot;query&quot;: &#123; &quot;range&quot;: &#123; &quot;price&quot;: &#123; &quot;lte&quot;: 200 // 只对200元以下的文档聚合 &#125; &#125; &#125;, &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;brandAgg&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;brand&quot;, &quot;size&quot;: 20 &#125; &#125; &#125;&#125; 这次，聚合得到的品牌明显变少了： 1.2.4.Metric聚合语法上节课，我们对酒店按照品牌分组，形成了一个个桶。现在我们需要对桶内的酒店做运算，获取每个品牌的用户评分的min、max、avg等值。 这就要用到Metric聚合了，例如stat聚合：就可以获取min、max、avg等结果。 语法如下： 12345678910111213141516171819GET /hotel/_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;brandAgg&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;brand&quot;, &quot;size&quot;: 20 &#125;, &quot;aggs&quot;: &#123; // 是brands聚合的子聚合，也就是分组后对每组分别计算 &quot;score_stats&quot;: &#123; // 聚合名称 &quot;stats&quot;: &#123; // 聚合类型，这里stats可以计算min、max、avg等 &quot;field&quot;: &quot;score&quot; // 聚合字段，这里是score &#125; &#125; &#125; &#125; &#125;&#125; 这次的score_stats聚合是在brandAgg的聚合内部嵌套的子聚合。因为我们需要在每个桶分别计算。 另外，我们还可以给聚合结果做个排序，例如按照每个桶的酒店平均分做排序： 1.2.5.小结aggs代表聚合，与query同级，此时query的作用是？ 限定聚合的的文档范围 聚合必须的三要素： 聚合名称 聚合类型 聚合字段 聚合可配置属性有： size：指定聚合结果数量 order：指定聚合结果排序方式 field：指定聚合字段 1.3.RestAPI实现聚合1.3.1.API语法聚合条件与query条件同级别，因此需要使用request.source()来指定聚合条件。 聚合条件的语法： 聚合的结果也与查询结果不同，API也比较特殊。不过同样是JSON逐层解析： 1.3.2.业务需求需求：搜索页面的品牌、城市等信息不应该是在页面写死，而是通过聚合索引库中的酒店数据得来的： 分析： 目前，页面的城市列表、星级列表、品牌列表都是写死的，并不会随着搜索结果的变化而变化。但是用户搜索条件改变时，搜索结果会跟着变化。 例如：用户搜索“东方明珠”，那搜索的酒店肯定是在上海东方明珠附近，因此，城市只能是上海，此时城市列表中就不应该显示北京、深圳、杭州这些信息了。 也就是说，搜索结果中包含哪些城市，页面就应该列出哪些城市；搜索结果中包含哪些品牌，页面就应该列出哪些品牌。 如何得知搜索结果中包含哪些品牌？如何得知搜索结果中包含哪些城市？ 使用聚合功能，利用Bucket聚合，对搜索结果中的文档基于品牌分组、基于城市分组，就能得知包含哪些品牌、哪些城市了。 因为是对搜索结果聚合，因此聚合是限定范围的聚合，也就是说聚合的限定条件跟搜索文档的条件一致。 查看浏览器可以发现，前端其实已经发出了这样的一个请求： 请求参数与搜索文档的参数完全一致。 返回值类型就是页面要展示的最终结果： 结果是一个Map结构： key是字符串，城市、星级、品牌、价格 value是集合，例如多个城市的名称 1.3.3.业务实现在cn.itcast.hotel.web包的HotelController中添加一个方法，遵循下面的要求： 请求方式：POST 请求路径：/hotel/filters 请求参数：RequestParams，与搜索文档的参数一致 返回值类型：Map&lt;String, List&lt;String&gt;&gt; 代码： 1234@PostMapping(&quot;filters&quot;)public Map&lt;String, List&lt;String&gt;&gt; getFilters(@RequestBody RequestParams params)&#123; return hotelService.getFilters(params);&#125; 这里调用了IHotelService中的getFilters方法，尚未实现。 在cn.itcast.hotel.service.IHotelService中定义新方法： 1Map&lt;String, List&lt;String&gt;&gt; filters(RequestParams params); 在cn.itcast.hotel.service.impl.HotelService中实现该方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@Overridepublic Map&lt;String, List&lt;String&gt;&gt; filters(RequestParams params) &#123; try &#123; // 1.准备Request SearchRequest request = new SearchRequest(&quot;hotel&quot;); // 2.准备DSL // 2.1.query buildBasicQuery(params, request); // 2.2.设置size request.source().size(0); // 2.3.聚合 buildAggregation(request); // 3.发出请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析结果 Map&lt;String, List&lt;String&gt;&gt; result = new HashMap&lt;&gt;(); Aggregations aggregations = response.getAggregations(); // 4.1.根据品牌名称，获取品牌结果 List&lt;String&gt; brandList = getAggByName(aggregations, &quot;brandAgg&quot;); result.put(&quot;品牌&quot;, brandList); // 4.2.根据品牌名称，获取品牌结果 List&lt;String&gt; cityList = getAggByName(aggregations, &quot;cityAgg&quot;); result.put(&quot;城市&quot;, cityList); // 4.3.根据品牌名称，获取品牌结果 List&lt;String&gt; starList = getAggByName(aggregations, &quot;starAgg&quot;); result.put(&quot;星级&quot;, starList); return result; &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125;&#125;private void buildAggregation(SearchRequest request) &#123; request.source().aggregation(AggregationBuilders .terms(&quot;brandAgg&quot;) .field(&quot;brand&quot;) .size(100) ); request.source().aggregation(AggregationBuilders .terms(&quot;cityAgg&quot;) .field(&quot;city&quot;) .size(100) ); request.source().aggregation(AggregationBuilders .terms(&quot;starAgg&quot;) .field(&quot;starName&quot;) .size(100) );&#125;private List&lt;String&gt; getAggByName(Aggregations aggregations, String aggName) &#123; // 4.1.根据聚合名称获取聚合结果 Terms brandTerms = aggregations.get(aggName); // 4.2.获取buckets List&lt;? extends Terms.Bucket&gt; buckets = brandTerms.getBuckets(); // 4.3.遍历 List&lt;String&gt; brandList = new ArrayList&lt;&gt;(); for (Terms.Bucket bucket : buckets) &#123; // 4.4.获取key String key = bucket.getKeyAsString(); brandList.add(key); &#125; return brandList;&#125;","categories":[{"name":"elk","slug":"elk","permalink":"http://example.com/elk/"}],"tags":[{"name":"elk","slug":"elk","permalink":"http://example.com/tags/elk/"}]},{"title":"elk（九）-旅游案例","slug":"elk/elk（九）-旅游案例","date":"2023-06-30T07:31:22.000Z","updated":"2023-06-30T07:33:18.242Z","comments":true,"path":"2023/06/30/elk/elk（九）-旅游案例/","link":"","permalink":"http://example.com/2023/06/30/elk/elk%EF%BC%88%E4%B9%9D%EF%BC%89-%E6%97%85%E6%B8%B8%E6%A1%88%E4%BE%8B/","excerpt":"","text":"4.黑马旅游案例下面，我们通过黑马旅游的案例来实战演练下之前学习的知识。 我们实现四部分功能： 酒店搜索和分页 酒店结果过滤 我周边的酒店 酒店竞价排名 启动我们提供的hotel-demo项目，其默认端口是8089，访问http://localhost:8090，就能看到项目页面了： 4.1.酒店搜索和分页案例需求：实现黑马旅游的酒店搜索功能，完成关键字搜索和分页 4.1.1.需求分析在项目的首页，有一个大大的搜索框，还有分页按钮： 点击搜索按钮，可以看到浏览器控制台发出了请求： 请求参数如下： 由此可以知道，我们这个请求的信息如下： 请求方式：POST 请求路径：&#x2F;hotel&#x2F;list 请求参数：JSON对象，包含4个字段： key：搜索关键字 page：页码 size：每页大小 sortBy：排序，目前暂不实现 返回值：分页查询，需要返回分页结果PageResult，包含两个属性： total：总条数 List&lt;HotelDoc&gt;：当前页的数据 因此，我们实现业务的流程如下： 步骤一：定义实体类，接收请求参数的JSON对象 步骤二：编写controller，接收页面的请求 步骤三：编写业务实现，利用RestHighLevelClient实现搜索、分页 4.1.2.定义实体类实体类有两个，一个是前端的请求参数实体，一个是服务端应该返回的响应结果实体。 1）请求参数 前端请求的json结构如下： 123456&#123; &quot;key&quot;: &quot;搜索关键字&quot;, &quot;page&quot;: 1, &quot;size&quot;: 3, &quot;sortBy&quot;: &quot;default&quot;&#125; 因此，我们在cn.itcast.hotel.pojo包下定义一个实体类： 1234567891011package cn.itcast.hotel.pojo;import lombok.Data;@Datapublic class RequestParams &#123; private String key; private Integer page; private Integer size; private String sortBy;&#125; 2）返回值 分页查询，需要返回分页结果PageResult，包含两个属性： total：总条数 List&lt;HotelDoc&gt;：当前页的数据 因此，我们在cn.itcast.hotel.pojo中定义返回结果： 12345678910111213141516171819package cn.itcast.hotel.pojo;import lombok.Data;import java.util.List;@Datapublic class PageResult &#123; private Long total; private List&lt;HotelDoc&gt; hotels; public PageResult() &#123; &#125; public PageResult(Long total, List&lt;HotelDoc&gt; hotels) &#123; this.total = total; this.hotels = hotels; &#125;&#125; 4.1.3.定义controller定义一个HotelController，声明查询接口，满足下列要求： 请求方式：Post 请求路径：&#x2F;hotel&#x2F;list 请求参数：对象，类型为RequestParam 返回值：PageResult，包含两个属性 Long total：总条数 List&lt;HotelDoc&gt; hotels：酒店数据 因此，我们在cn.itcast.hotel.web中定义HotelController： 123456789101112@RestController@RequestMapping(&quot;/hotel&quot;)public class HotelController &#123; @Autowired private IHotelService hotelService; // 搜索酒店数据 @PostMapping(&quot;/list&quot;) public PageResult search(@RequestBody RequestParams params)&#123; return hotelService.search(params); &#125;&#125; 4.1.4.实现搜索业务我们在controller调用了IHotelService，并没有实现该方法，因此下面我们就在IHotelService中定义方法，并且去实现业务逻辑。 1）在cn.itcast.hotel.service中的IHotelService接口中定义一个方法： 123456/** * 根据关键字搜索酒店信息 * @param params 请求参数对象，包含用户输入的关键字 * @return 酒店文档列表 */PageResult search(RequestParams params); 2）实现搜索业务，肯定离不开RestHighLevelClient，我们需要把它注册到Spring中作为一个Bean。在cn.itcast.hotel中的HotelDemoApplication中声明这个Bean： 123456@Beanpublic RestHighLevelClient client()&#123; return new RestHighLevelClient(RestClient.builder( HttpHost.create(&quot;http://192.168.150.101:9200&quot;) ));&#125; 3）在cn.itcast.hotel.service.impl中的HotelService中实现search方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Overridepublic PageResult search(RequestParams params) &#123; try &#123; // 1.准备Request SearchRequest request = new SearchRequest(&quot;hotel&quot;); // 2.准备DSL // 2.1.query String key = params.getKey(); if (key == null || &quot;&quot;.equals(key)) &#123; boolQuery.must(QueryBuilders.matchAllQuery()); &#125; else &#123; boolQuery.must(QueryBuilders.matchQuery(&quot;all&quot;, key)); &#125; // 2.2.分页 int page = params.getPage(); int size = params.getSize(); request.source().from((page - 1) * size).size(size); // 3.发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析响应 return handleResponse(response); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125;&#125;// 结果解析private PageResult handleResponse(SearchResponse response) &#123; // 4.解析响应 SearchHits searchHits = response.getHits(); // 4.1.获取总条数 long total = searchHits.getTotalHits().value; // 4.2.文档数组 SearchHit[] hits = searchHits.getHits(); // 4.3.遍历 List&lt;HotelDoc&gt; hotels = new ArrayList&lt;&gt;(); for (SearchHit hit : hits) &#123; // 获取文档source String json = hit.getSourceAsString(); // 反序列化 HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class); // 放入集合 hotels.add(hotelDoc); &#125; // 4.4.封装返回 return new PageResult(total, hotels);&#125; 4.2.酒店结果过滤需求：添加品牌、城市、星级、价格等过滤功能 4.2.1.需求分析在页面搜索框下面，会有一些过滤项： 传递的参数如图： 包含的过滤条件有： brand：品牌值 city：城市 minPrice~maxPrice：价格范围 starName：星级 我们需要做两件事情： 修改请求参数的对象RequestParams，接收上述参数 修改业务逻辑，在搜索条件之外，添加一些过滤条件 4.2.2.修改实体类修改在cn.itcast.hotel.pojo包下的实体类RequestParams： 12345678910111213@Datapublic class RequestParams &#123; private String key; private Integer page; private Integer size; private String sortBy; // 下面是新增的过滤条件参数 private String city; private String brand; private String starName; private Integer minPrice; private Integer maxPrice;&#125; 4.2.3.修改搜索业务在HotelService的search方法中，只有一个地方需要修改：requet.source().query( … )其中的查询条件。 在之前的业务中，只有match查询，根据关键字搜索，现在要添加条件过滤，包括： 品牌过滤：是keyword类型，用term查询 星级过滤：是keyword类型，用term查询 价格过滤：是数值类型，用range查询 城市过滤：是keyword类型，用term查询 多个查询条件组合，肯定是boolean查询来组合： 关键字搜索放到must中，参与算分 其它过滤条件放到filter中，不参与算分 因为条件构建的逻辑比较复杂，这里先封装为一个函数： buildBasicQuery的代码如下： 123456789101112131415161718192021222324252627282930313233private void buildBasicQuery(RequestParams params, SearchRequest request) &#123; // 1.构建BooleanQuery BoolQueryBuilder boolQuery = QueryBuilders.boolQuery(); // 2.关键字搜索 String key = params.getKey(); if (key == null || &quot;&quot;.equals(key)) &#123; boolQuery.must(QueryBuilders.matchAllQuery()); &#125; else &#123; boolQuery.must(QueryBuilders.matchQuery(&quot;all&quot;, key)); &#125; // 3.城市条件 if (params.getCity() != null &amp;&amp; !params.getCity().equals(&quot;&quot;)) &#123; boolQuery.filter(QueryBuilders.termQuery(&quot;city&quot;, params.getCity())); &#125; // 4.品牌条件 if (params.getBrand() != null &amp;&amp; !params.getBrand().equals(&quot;&quot;)) &#123; boolQuery.filter(QueryBuilders.termQuery(&quot;brand&quot;, params.getBrand())); &#125; // 5.星级条件 if (params.getStarName() != null &amp;&amp; !params.getStarName().equals(&quot;&quot;)) &#123; boolQuery.filter(QueryBuilders.termQuery(&quot;starName&quot;, params.getStarName())); &#125; // 6.价格 if (params.getMinPrice() != null &amp;&amp; params.getMaxPrice() != null) &#123; boolQuery.filter(QueryBuilders .rangeQuery(&quot;price&quot;) .gte(params.getMinPrice()) .lte(params.getMaxPrice()) ); &#125; // 7.放入source request.source().query(boolQuery);&#125; 4.3.我周边的酒店需求：我附近的酒店 4.3.1.需求分析在酒店列表页的右侧，有一个小地图，点击地图的定位按钮，地图会找到你所在的位置： 并且，在前端会发起查询请求，将你的坐标发送到服务端： 我们要做的事情就是基于这个location坐标，然后按照距离对周围酒店排序。实现思路如下： 修改RequestParams参数，接收location字段 修改search方法业务逻辑，如果location有值，添加根据geo_distance排序的功能 4.3.2.修改实体类修改在cn.itcast.hotel.pojo包下的实体类RequestParams： 12345678910111213141516171819package cn.itcast.hotel.pojo;import lombok.Data;@Datapublic class RequestParams &#123; private String key; private Integer page; private Integer size; private String sortBy; private String city; private String brand; private String starName; private Integer minPrice; private Integer maxPrice; // 我当前的地理坐标 private String location;&#125; 4.3.3.距离排序API我们以前学习过排序功能，包括两种： 普通字段排序 地理坐标排序 我们只讲了普通字段排序对应的java写法。地理坐标排序只学过DSL语法，如下： 123456789101112131415161718GET /indexName/_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;sort&quot;: [ &#123; &quot;price&quot;: &quot;asc&quot; &#125;, &#123; &quot;_geo_distance&quot; : &#123; &quot;FIELD&quot; : &quot;纬度，经度&quot;, &quot;order&quot; : &quot;asc&quot;, &quot;unit&quot; : &quot;km&quot; &#125; &#125; ]&#125; 对应的java代码示例： 4.3.4.添加距离排序在cn.itcast.hotel.service.impl的HotelService的search方法中，添加一个排序功能： 完整代码： 1234567891011121314151617181920212223242526272829303132@Overridepublic PageResult search(RequestParams params) &#123; try &#123; // 1.准备Request SearchRequest request = new SearchRequest(&quot;hotel&quot;); // 2.准备DSL // 2.1.query buildBasicQuery(params, request); // 2.2.分页 int page = params.getPage(); int size = params.getSize(); request.source().from((page - 1) * size).size(size); // 2.3.排序 String location = params.getLocation(); if (location != null &amp;&amp; !location.equals(&quot;&quot;)) &#123; request.source().sort(SortBuilders .geoDistanceSort(&quot;location&quot;, new GeoPoint(location)) .order(SortOrder.ASC) .unit(DistanceUnit.KILOMETERS) ); &#125; // 3.发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析响应 return handleResponse(response); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125;&#125; 4.3.5.排序距离显示重启服务后，测试我的酒店功能： 发现确实可以实现对我附近酒店的排序，不过并没有看到酒店到底距离我多远，这该怎么办？ 排序完成后，页面还要获取我附近每个酒店的具体距离值，这个值在响应结果中是独立的： 因此，我们在结果解析阶段，除了解析source部分以外，还要得到sort部分，也就是排序的距离，然后放到响应结果中。 我们要做两件事： 修改HotelDoc，添加排序距离字段，用于页面显示 修改HotelService类中的handleResponse方法，添加对sort值的获取 1）修改HotelDoc类，添加距离字段 1234567891011121314151617181920212223242526272829303132333435363738package cn.itcast.hotel.pojo;import lombok.Data;import lombok.NoArgsConstructor;@Data@NoArgsConstructorpublic class HotelDoc &#123; private Long id; private String name; private String address; private Integer price; private Integer score; private String brand; private String city; private String starName; private String business; private String location; private String pic; // 排序时的 距离值 private Object distance; public HotelDoc(Hotel hotel) &#123; this.id = hotel.getId(); this.name = hotel.getName(); this.address = hotel.getAddress(); this.price = hotel.getPrice(); this.score = hotel.getScore(); this.brand = hotel.getBrand(); this.city = hotel.getCity(); this.starName = hotel.getStarName(); this.business = hotel.getBusiness(); this.location = hotel.getLatitude() + &quot;, &quot; + hotel.getLongitude(); this.pic = hotel.getPic(); &#125;&#125; 2）修改HotelService中的handleResponse方法 重启后测试，发现页面能成功显示距离了： 4.4.酒店竞价排名需求：让指定的酒店在搜索结果中排名置顶 4.4.1.需求分析要让指定酒店在搜索结果中排名置顶，效果如图： 页面会给指定的酒店添加广告标记。 那怎样才能让指定的酒店排名置顶呢？ 我们之前学习过的function_score查询可以影响算分，算分高了，自然排名也就高了。而function_score包含3个要素： 过滤条件：哪些文档要加分 算分函数：如何计算function score 加权方式：function score 与 query score如何运算 这里的需求是：让指定酒店排名靠前。因此我们需要给这些酒店添加一个标记，这样在过滤条件中就可以根据这个标记来判断，是否要提高算分。 比如，我们给酒店添加一个字段：isAD，Boolean类型： true：是广告 false：不是广告 这样function_score包含3个要素就很好确定了： 过滤条件：判断isAD 是否为true 算分函数：我们可以用最简单暴力的weight，固定加权值 加权方式：可以用默认的相乘，大大提高算分 因此，业务的实现步骤包括： 给HotelDoc类添加isAD字段，Boolean类型 挑选几个你喜欢的酒店，给它的文档数据添加isAD字段，值为true 修改search方法，添加function score功能，给isAD值为true的酒店增加权重 4.4.2.修改HotelDoc实体给cn.itcast.hotel.pojo包下的HotelDoc类添加isAD字段： 4.4.3.添加广告标记接下来，我们挑几个酒店，添加isAD字段，设置为true： 123456789101112131415161718192021222324POST /hotel/_update/1902197537&#123; &quot;doc&quot;: &#123; &quot;isAD&quot;: true &#125;&#125;POST /hotel/_update/2056126831&#123; &quot;doc&quot;: &#123; &quot;isAD&quot;: true &#125;&#125;POST /hotel/_update/1989806195&#123; &quot;doc&quot;: &#123; &quot;isAD&quot;: true &#125;&#125;POST /hotel/_update/2056105938&#123; &quot;doc&quot;: &#123; &quot;isAD&quot;: true &#125;&#125; 4.4.4.添加算分函数查询接下来我们就要修改查询条件了。之前是用的boolean 查询，现在要改成function_socre查询。 function_score查询结构如下： 对应的JavaAPI如下： 我们可以将之前写的boolean查询作为原始查询条件放到query中，接下来就是添加过滤条件、算分函数、加权模式了。所以原来的代码依然可以沿用。 修改cn.itcast.hotel.service.impl包下的HotelService类中的buildBasicQuery方法，添加算分函数查询： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private void buildBasicQuery(RequestParams params, SearchRequest request) &#123; // 1.构建BooleanQuery BoolQueryBuilder boolQuery = QueryBuilders.boolQuery(); // 关键字搜索 String key = params.getKey(); if (key == null || &quot;&quot;.equals(key)) &#123; boolQuery.must(QueryBuilders.matchAllQuery()); &#125; else &#123; boolQuery.must(QueryBuilders.matchQuery(&quot;all&quot;, key)); &#125; // 城市条件 if (params.getCity() != null &amp;&amp; !params.getCity().equals(&quot;&quot;)) &#123; boolQuery.filter(QueryBuilders.termQuery(&quot;city&quot;, params.getCity())); &#125; // 品牌条件 if (params.getBrand() != null &amp;&amp; !params.getBrand().equals(&quot;&quot;)) &#123; boolQuery.filter(QueryBuilders.termQuery(&quot;brand&quot;, params.getBrand())); &#125; // 星级条件 if (params.getStarName() != null &amp;&amp; !params.getStarName().equals(&quot;&quot;)) &#123; boolQuery.filter(QueryBuilders.termQuery(&quot;starName&quot;, params.getStarName())); &#125; // 价格 if (params.getMinPrice() != null &amp;&amp; params.getMaxPrice() != null) &#123; boolQuery.filter(QueryBuilders .rangeQuery(&quot;price&quot;) .gte(params.getMinPrice()) .lte(params.getMaxPrice()) ); &#125; // 2.算分控制 FunctionScoreQueryBuilder functionScoreQuery = QueryBuilders.functionScoreQuery( // 原始查询，相关性算分的查询 boolQuery, // function score的数组 new FunctionScoreQueryBuilder.FilterFunctionBuilder[]&#123; // 其中的一个function score 元素 new FunctionScoreQueryBuilder.FilterFunctionBuilder( // 过滤条件 QueryBuilders.termQuery(&quot;isAD&quot;, true), // 算分函数 ScoreFunctionBuilders.weightFactorFunction(10) ) &#125;); request.source().query(functionScoreQuery);&#125;","categories":[{"name":"elk","slug":"elk","permalink":"http://example.com/elk/"}],"tags":[{"name":"elk","slug":"elk","permalink":"http://example.com/tags/elk/"}]},{"title":"elk（八）-RestClent查询文档","slug":"elk/elk（八）-RestClent查询文档","date":"2023-06-30T07:29:13.000Z","updated":"2023-06-30T07:32:42.151Z","comments":true,"path":"2023/06/30/elk/elk（八）-RestClent查询文档/","link":"","permalink":"http://example.com/2023/06/30/elk/elk%EF%BC%88%E5%85%AB%EF%BC%89-RestClent%E6%9F%A5%E8%AF%A2%E6%96%87%E6%A1%A3/","excerpt":"","text":"3.RestClient查询 文档文档的查询同样适用昨天学习的 RestHighLevelClient对象，基本步骤包括： 1）准备Request对象 2）准备请求参数 3）发起请求 4）解析响应 3.1.快速入门我们以match_all查询为例 3.1.1.发起查询请求 代码解读： 第一步，创建SearchRequest对象，指定索引库名 第二步，利用request.source()构建DSL，DSL中可以包含查询、分页、排序、高亮等 query()：代表查询条件，利用QueryBuilders.matchAllQuery()构建一个match_all查询的DSL 第三步，利用client.search()发送请求，得到响应 这里关键的API有两个，一个是request.source()，其中包含了查询、排序、分页、高亮等所有功能： 另一个是QueryBuilders，其中包含match、term、function_score、bool等各种查询： 3.1.2.解析响应响应结果的解析： elasticsearch返回的结果是一个JSON字符串，结构包含： hits：命中的结果 total：总条数，其中的value是具体的总条数值 max_score：所有结果中得分最高的文档的相关性算分 hits：搜索结果的文档数组，其中的每个文档都是一个json对象 _source：文档中的原始数据，也是json对象 因此，我们解析响应结果，就是逐层解析JSON字符串，流程如下： SearchHits：通过response.getHits()获取，就是JSON中的最外层的hits，代表命中的结果 SearchHits#getTotalHits().value：获取总条数信息 SearchHits#getHits()：获取SearchHit数组，也就是文档数组 SearchHit#getSourceAsString()：获取文档结果中的_source，也就是原始的json文档数据 3.1.3.完整代码完整代码如下： 12345678910111213141516171819202122232425262728293031@Testvoid testMatchAll() throws IOException &#123; // 1.准备Request SearchRequest request = new SearchRequest(&quot;hotel&quot;); // 2.准备DSL request.source() .query(QueryBuilders.matchAllQuery()); // 3.发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析响应 handleResponse(response);&#125;private void handleResponse(SearchResponse response) &#123; // 4.解析响应 SearchHits searchHits = response.getHits(); // 4.1.获取总条数 long total = searchHits.getTotalHits().value; System.out.println(&quot;共搜索到&quot; + total + &quot;条数据&quot;); // 4.2.文档数组 SearchHit[] hits = searchHits.getHits(); // 4.3.遍历 for (SearchHit hit : hits) &#123; // 获取文档source String json = hit.getSourceAsString(); // 反序列化 HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class); System.out.println(&quot;hotelDoc = &quot; + hotelDoc); &#125;&#125; 3.1.4.小结查询的基本步骤是： 创建SearchRequest对象 准备Request.source()，也就是DSL。 ① QueryBuilders来构建查询条件 ② 传入Request.source() 的 query() 方法 发送请求，得到结果 解析结果（参考JSON结果，从外到内，逐层解析） 3.2.match查询全文检索的match和multi_match查询与match_all的API基本一致。差别是查询条件，也就是query的部分。 因此，Java代码上的差异主要是request.source().query()中的参数了。同样是利用QueryBuilders提供的方法： 而结果解析代码则完全一致，可以抽取并共享。 完整代码如下： 12345678910111213@Testvoid testMatch() throws IOException &#123; // 1.准备Request SearchRequest request = new SearchRequest(&quot;hotel&quot;); // 2.准备DSL request.source() .query(QueryBuilders.matchQuery(&quot;all&quot;, &quot;如家&quot;)); // 3.发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析响应 handleResponse(response);&#125; 3.3.精确查询精确查询主要是两者： term：词条精确匹配 range：范围查询 与之前的查询相比，差异同样在查询条件，其它都一样。 查询条件构造的API如下： 3.4.布尔查询布尔查询是用must、must_not、filter等方式组合其它查询，代码示例如下： 可以看到，API与其它查询的差别同样是在查询条件的构建，QueryBuilders，结果解析等其他代码完全不变。 完整代码如下： 12345678910111213141516171819@Testvoid testBool() throws IOException &#123; // 1.准备Request SearchRequest request = new SearchRequest(&quot;hotel&quot;); // 2.准备DSL // 2.1.准备BooleanQuery BoolQueryBuilder boolQuery = QueryBuilders.boolQuery(); // 2.2.添加term boolQuery.must(QueryBuilders.termQuery(&quot;city&quot;, &quot;杭州&quot;)); // 2.3.添加range boolQuery.filter(QueryBuilders.rangeQuery(&quot;price&quot;).lte(250)); request.source().query(boolQuery); // 3.发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析响应 handleResponse(response);&#125; 3.5.排序、分页搜索结果的排序和分页是与query同级的参数，因此同样是使用request.source()来设置。 对应的API如下： 完整代码示例： 1234567891011121314151617181920@Testvoid testPageAndSort() throws IOException &#123; // 页码，每页大小 int page = 1, size = 5; // 1.准备Request SearchRequest request = new SearchRequest(&quot;hotel&quot;); // 2.准备DSL // 2.1.query request.source().query(QueryBuilders.matchAllQuery()); // 2.2.排序 sort request.source().sort(&quot;price&quot;, SortOrder.ASC); // 2.3.分页 from、size request.source().from((page - 1) * size).size(5); // 3.发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析响应 handleResponse(response);&#125; 3.6.高亮高亮的代码与之前代码差异较大，有两点： 查询的DSL：其中除了查询条件，还需要添加高亮条件，同样是与query同级。 结果解析：结果除了要解析_source文档数据，还要解析高亮结果 3.6.1.高亮请求构建高亮请求的构建API如下： 上述代码省略了查询条件部分，但是大家不要忘了：高亮查询必须使用全文检索查询，并且要有搜索关键字，将来才可以对关键字高亮。 完整代码如下： 123456789101112131415@Testvoid testHighlight() throws IOException &#123; // 1.准备Request SearchRequest request = new SearchRequest(&quot;hotel&quot;); // 2.准备DSL // 2.1.query request.source().query(QueryBuilders.matchQuery(&quot;all&quot;, &quot;如家&quot;)); // 2.2.高亮 request.source().highlighter(new HighlightBuilder().field(&quot;name&quot;).requireFieldMatch(false)); // 3.发送请求 SearchResponse response = client.search(request, RequestOptions.DEFAULT); // 4.解析响应 handleResponse(response);&#125; 3.6.2.高亮结果解析高亮的结果与查询的文档结果默认是分离的，并不在一起。 因此解析高亮的代码需要额外处理： 代码解读： 第一步：从结果中获取source。hit.getSourceAsString()，这部分是非高亮结果，json字符串。还需要反序列为HotelDoc对象 第二步：获取高亮结果。hit.getHighlightFields()，返回值是一个Map，key是高亮字段名称，值是HighlightField对象，代表高亮值 第三步：从map中根据高亮字段名称，获取高亮字段值对象HighlightField 第四步：从HighlightField中获取Fragments，并且转为字符串。这部分就是真正的高亮字符串了 第五步：用高亮的结果替换HotelDoc中的非高亮结果 完整代码如下： 1234567891011121314151617181920212223242526272829private void handleResponse(SearchResponse response) &#123; // 4.解析响应 SearchHits searchHits = response.getHits(); // 4.1.获取总条数 long total = searchHits.getTotalHits().value; System.out.println(&quot;共搜索到&quot; + total + &quot;条数据&quot;); // 4.2.文档数组 SearchHit[] hits = searchHits.getHits(); // 4.3.遍历 for (SearchHit hit : hits) &#123; // 获取文档source String json = hit.getSourceAsString(); // 反序列化 HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class); // 获取高亮结果 Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields(); if (!CollectionUtils.isEmpty(highlightFields)) &#123; // 根据字段名获取高亮结果 HighlightField highlightField = highlightFields.get(&quot;name&quot;); if (highlightField != null) &#123; // 获取高亮值 String name = highlightField.getFragments()[0].string(); // 覆盖非高亮结果 hotelDoc.setName(name); &#125; &#125; System.out.println(&quot;hotelDoc = &quot; + hotelDoc); &#125;&#125;","categories":[{"name":"elk","slug":"elk","permalink":"http://example.com/elk/"}],"tags":[{"name":"elk","slug":"elk","permalink":"http://example.com/tags/elk/"}]},{"title":"elk（七）-搜索结果处理","slug":"elk/elk（七）-搜索结果处理","date":"2023-06-30T07:27:06.000Z","updated":"2023-06-30T07:33:37.640Z","comments":true,"path":"2023/06/30/elk/elk（七）-搜索结果处理/","link":"","permalink":"http://example.com/2023/06/30/elk/elk%EF%BC%88%E4%B8%83%EF%BC%89-%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86/","excerpt":"","text":"2.搜索结果处理搜索的结果可以按照用户指定的方式去处理或展示。 2.1.排序elasticsearch默认是根据相关度算分（_score）来排序，但是也支持自定义方式对搜索结果排序。可以排序字段类型有：keyword类型、数值类型、地理坐标类型、日期类型等。 2.1.1.普通字段排序keyword、数值、日期类型排序的语法基本一致。 语法： 1234567891011GET /indexName/_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;sort&quot;: [ &#123; &quot;FIELD&quot;: &quot;desc&quot; // 排序字段、排序方式ASC、DESC &#125; ]&#125; 排序条件是一个数组，也就是可以写多个排序条件。按照声明的顺序，当第一个条件相等时，再按照第二个条件排序，以此类推 示例： 需求描述：酒店数据按照用户评价（score)降序排序，评价相同的按照价格(price)升序排序 2.1.2.地理坐标排序地理坐标排序略有不同。 语法说明： 123456789101112131415GET /indexName/_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;sort&quot;: [ &#123; &quot;_geo_distance&quot; : &#123; &quot;FIELD&quot; : &quot;纬度，经度&quot;, // 文档中geo_point类型的字段名、目标坐标点 &quot;order&quot; : &quot;asc&quot;, // 排序方式 &quot;unit&quot; : &quot;km&quot; // 排序的距离单位 &#125; &#125; ]&#125; 这个查询的含义是： 指定一个坐标，作为目标点 计算每一个文档中，指定字段（必须是geo_point类型）的坐标 到目标点的距离是多少 根据距离排序 示例： 需求描述：实现对酒店数据按照到你的位置坐标的距离升序排序 提示：获取你的位置的经纬度的方式：https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/ 假设我的位置是：31.034661，121.612282，寻找我周围距离最近的酒店。 2.2.分页elasticsearch 默认情况下只返回top10的数据。而如果要查询更多数据就需要修改分页参数了。elasticsearch中通过修改from、size参数来控制要返回的分页结果： from：从第几个文档开始 size：总共查询几个文档 类似于mysql中的limit ?, ? 2.2.1.基本的分页分页的基本语法如下： 1234567891011GET /hotel/_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;from&quot;: 0, // 分页开始的位置，默认为0 &quot;size&quot;: 10, // 期望获取的文档总数 &quot;sort&quot;: [ &#123;&quot;price&quot;: &quot;asc&quot;&#125; ]&#125; 2.2.2.深度分页问题现在，我要查询990~1000的数据，查询逻辑要这么写： 1234567891011GET /hotel/_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;from&quot;: 990, // 分页开始的位置，默认为0 &quot;size&quot;: 10, // 期望获取的文档总数 &quot;sort&quot;: [ &#123;&quot;price&quot;: &quot;asc&quot;&#125; ]&#125; 这里是查询990开始的数据，也就是 第990~第1000条 数据。 不过，elasticsearch内部分页时，必须先查询 0~1000条，然后截取其中的990 ~ 1000的这10条： 查询TOP1000，如果es是单点模式，这并无太大影响。 但是elasticsearch将来一定是集群，例如我集群有5个节点，我要查询TOP1000的数据，并不是每个节点查询200条就可以了。 因为节点A的TOP200，在另一个节点可能排到10000名以外了。 因此要想获取整个集群的TOP1000，必须先查询出每个节点的TOP1000，汇总结果后，重新排名，重新截取TOP1000。 那如果我要查询9900~10000的数据呢？是不是要先查询TOP10000呢？那每个节点都要查询10000条？汇总到内存中？ 当查询分页深度较大时，汇总数据过多，对内存和CPU会产生非常大的压力，因此elasticsearch会禁止from+ size 超过10000的请求。 针对深度分页，ES提供了两种解决方案，官方文档： search after：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。 scroll：原理将排序后的文档id形成快照，保存在内存。官方已经不推荐使用。 2.2.3.小结分页查询的常见实现方案以及优缺点： from + size： 优点：支持随机翻页 缺点：深度分页问题，默认查询上限（from + size）是10000 场景：百度、京东、谷歌、淘宝这样的随机翻页搜索 after search： 优点：没有查询上限（单次查询的size不超过10000） 缺点：只能向后逐页查询，不支持随机翻页 场景：没有随机翻页需求的搜索，例如手机向下滚动翻页 scroll： 优点：没有查询上限（单次查询的size不超过10000） 缺点：会有额外内存消耗，并且搜索结果是非实时的 场景：海量数据的获取和迁移。从ES7.1开始不推荐，建议用 after search方案。 2.3.高亮2.3.1.高亮原理什么是高亮显示呢？ 我们在百度，京东搜索时，关键字会变成红色，比较醒目，这叫高亮显示： 高亮显示的实现分为两步： 1）给文档中的所有关键字都添加一个标签，例如&lt;em&gt;标签 2）页面给&lt;em&gt;标签编写CSS样式 2.3.2.实现高亮高亮的语法： 12345678910111213141516GET /hotel/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;FIELD&quot;: &quot;TEXT&quot; // 查询条件，高亮一定要使用全文检索查询 &#125; &#125;, &quot;highlight&quot;: &#123; &quot;fields&quot;: &#123; // 指定要高亮的字段 &quot;FIELD&quot;: &#123; &quot;pre_tags&quot;: &quot;&lt;em&gt;&quot;, // 用来标记高亮字段的前置标签 &quot;post_tags&quot;: &quot;&lt;/em&gt;&quot; // 用来标记高亮字段的后置标签 &#125; &#125; &#125;&#125; 注意： 高亮是对关键字高亮，因此搜索条件必须带有关键字，而不能是范围这样的查询。 默认情况下，高亮的字段，必须与搜索指定的字段一致，否则无法高亮 如果要对非搜索字段高亮，则需要添加一个属性：required_field_match&#x3D;false 示例： 2.4.总结查询的DSL是一个大的JSON对象，包含下列属性： query：查询条件 from和size：分页条件 sort：排序条件 highlight：高亮条件 示例：","categories":[{"name":"elk","slug":"elk","permalink":"http://example.com/elk/"}],"tags":[{"name":"elk","slug":"elk","permalink":"http://example.com/tags/elk/"}]},{"title":"elk（六）-DSL查询文档","slug":"elk/elk（六）-DSL查询文档","date":"2023-06-30T07:23:52.000Z","updated":"2023-06-30T07:33:31.810Z","comments":true,"path":"2023/06/30/elk/elk（六）-DSL查询文档/","link":"","permalink":"http://example.com/2023/06/30/elk/elk%EF%BC%88%E5%85%AD%EF%BC%89-DSL%E6%9F%A5%E8%AF%A2%E6%96%87%E6%A1%A3/","excerpt":"","text":"1.DSL查询文档elasticsearch的查询依然是基于JSON风格的DSL来实现的。 1.1.DSL查询分类Elasticsearch提供了基于JSON的DSL（Domain Specific Language）来定义查询。常见的查询类型包括： 查询所有：查询出所有数据，一般测试用。例如：match_all 全文检索（full text）查询：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如： match_query multi_match_query 精确查询：根据精确词条值查找数据，一般是查找keyword、数值、日期、boolean等类型字段。例如： ids range term 地理（geo）查询：根据经纬度查询。例如： geo_distance geo_bounding_box 复合（compound）查询：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如： bool function_score 查询的语法基本一致： 12345678GET /indexName/_search&#123; &quot;query&quot;: &#123; &quot;查询类型&quot;: &#123; &quot;查询条件&quot;: &quot;条件值&quot; &#125; &#125;&#125; 我们以查询所有为例，其中： 查询类型为match_all 没有查询条件 12345678// 查询所有GET /indexName/_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123; &#125; &#125;&#125; 其它查询无非就是查询类型、查询条件的变化。 1.2.全文检索查询1.2.1.使用场景全文检索查询的基本流程如下： 对用户搜索的内容做分词，得到词条 根据词条去倒排索引库中匹配，得到文档id 根据文档id找到文档，返回给用户 比较常用的场景包括： 商城的输入框搜索 百度输入框搜索 例如京东： 因为是拿着词条去匹配，因此参与搜索的字段也必须是可分词的text类型的字段。 1.2.2.基本语法常见的全文检索查询包括： match查询：单字段查询 multi_match查询：多字段查询，任意一个字段符合条件就算符合查询条件 match查询语法如下： 12345678GET /indexName/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;FIELD&quot;: &quot;TEXT&quot; &#125; &#125;&#125; mulit_match语法如下： 123456789GET /indexName/_search&#123; &quot;query&quot;: &#123; &quot;multi_match&quot;: &#123; &quot;query&quot;: &quot;TEXT&quot;, &quot;fields&quot;: [&quot;FIELD1&quot;, &quot; FIELD12&quot;] &#125; &#125;&#125; 1.2.3.示例match查询示例： multi_match查询示例： 可以看到，两种查询结果是一样的，为什么？ 因为我们将brand、name、business值都利用copy_to复制到了all字段中。因此你根据三个字段搜索，和根据all字段搜索效果当然一样了。 但是，搜索字段越多，对查询性能影响越大，因此建议采用copy_to，然后单字段查询的方式。 1.2.4.总结match和multi_match的区别是什么？ match：根据一个字段查询 multi_match：根据多个字段查询，参与查询字段越多，查询性能越差 1.3.精准查询精确查询一般是查找keyword、数值、日期、boolean等类型字段。所以不会对搜索条件分词。常见的有： term：根据词条精确值查询 range：根据值的范围查询 1.3.1.term查询因为精确查询的字段搜是不分词的字段，因此查询的条件也必须是不分词的词条。查询时，用户输入的内容跟自动值完全匹配时才认为符合条件。如果用户输入的内容过多，反而搜索不到数据。 语法说明： 1234567891011// term查询GET /indexName/_search&#123; &quot;query&quot;: &#123; &quot;term&quot;: &#123; &quot;FIELD&quot;: &#123; &quot;value&quot;: &quot;VALUE&quot; &#125; &#125; &#125;&#125; 示例： 当我搜索的是精确词条时，能正确查询出结果： 但是，当我搜索的内容不是词条，而是多个词语形成的短语时，反而搜索不到： 1.3.2.range查询范围查询，一般应用在对数值类型做范围过滤的时候。比如做价格范围过滤。 基本语法： 123456789101112// range查询GET /indexName/_search&#123; &quot;query&quot;: &#123; &quot;range&quot;: &#123; &quot;FIELD&quot;: &#123; &quot;gte&quot;: 10, // 这里的gte代表大于等于，gt则代表大于 &quot;lte&quot;: 20 // lte代表小于等于，lt则代表小于 &#125; &#125; &#125;&#125; 示例： 1.3.3.总结精确查询常见的有哪些？ term查询：根据词条精确匹配，一般搜索keyword类型、数值类型、布尔类型、日期类型字段 range查询：根据数值范围查询，可以是数值、日期的范围 1.4.地理坐标查询所谓的地理坐标查询，其实就是根据经纬度查询，官方文档：https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html 常见的使用场景包括： 携程：搜索我附近的酒店 滴滴：搜索我附近的出租车 微信：搜索我附近的人 附近的酒店： 附近的车： 1.4.1.矩形范围查询矩形范围查询，也就是geo_bounding_box查询，查询坐标落在某个矩形范围的所有文档： 查询时，需要指定矩形的左上、右下两个点的坐标，然后画出一个矩形，落在该矩形内的都是符合条件的点。 语法如下： 123456789101112131415161718// geo_bounding_box查询GET /indexName/_search&#123; &quot;query&quot;: &#123; &quot;geo_bounding_box&quot;: &#123; &quot;FIELD&quot;: &#123; &quot;top_left&quot;: &#123; // 左上点 &quot;lat&quot;: 31.1, &quot;lon&quot;: 121.5 &#125;, &quot;bottom_right&quot;: &#123; // 右下点 &quot;lat&quot;: 30.9, &quot;lon&quot;: 121.7 &#125; &#125; &#125; &#125;&#125; 这种并不符合“附近的人”这样的需求，所以我们就不做了。 1.4.2.附近查询附近查询，也叫做距离查询（geo_distance）：查询到指定中心点小于某个距离值的所有文档。 换句话来说，在地图上找一个点作为圆心，以指定距离为半径，画一个圆，落在圆内的坐标都算符合条件： 语法说明： 12345678910// geo_distance 查询GET /indexName/_search&#123; &quot;query&quot;: &#123; &quot;geo_distance&quot;: &#123; &quot;distance&quot;: &quot;15km&quot;, // 半径 &quot;FIELD&quot;: &quot;31.21,121.5&quot; // 圆心 &#125; &#125;&#125; 示例： 我们先搜索陆家嘴附近15km的酒店： 发现共有47家酒店。 然后把半径缩短到3公里： 可以发现，搜索到的酒店数量减少到了5家。 1.5.复合查询复合（compound）查询：复合查询可以将其它简单查询组合起来，实现更复杂的搜索逻辑。常见的有两种： fuction score：算分函数查询，可以控制文档相关性算分，控制文档排名 bool query：布尔查询，利用逻辑关系组合多个其它的查询，实现复杂搜索 1.5.1.相关性算分当我们利用match查询时，文档结果会根据与搜索词条的关联度打分（_score），返回结果时按照分值降序排列。 例如，我们搜索 “虹桥如家”，结果如下： 1234567891011121314151617181920[ &#123; &quot;_score&quot; : 17.850193, &quot;_source&quot; : &#123; &quot;name&quot; : &quot;虹桥如家酒店真不错&quot;, &#125; &#125;, &#123; &quot;_score&quot; : 12.259849, &quot;_source&quot; : &#123; &quot;name&quot; : &quot;外滩如家酒店真不错&quot;, &#125; &#125;, &#123; &quot;_score&quot; : 11.91091, &quot;_source&quot; : &#123; &quot;name&quot; : &quot;迪士尼如家酒店真不错&quot;, &#125; &#125;] 在elasticsearch中，早期使用的打分算法是TF-IDF算法，公式如下： 在后来的5.1版本升级中，elasticsearch将算法改进为BM25算法，公式如下： TF-IDF算法有一各缺陷，就是词条频率越高，文档得分也会越高，单个词条对文档影响较大。而BM25则会让单个词条的算分有一个上限，曲线更加平滑： 小结：elasticsearch会根据词条和文档的相关度做打分，算法由两种： TF-IDF算法 BM25算法，elasticsearch5.1版本后采用的算法 1.5.2.算分函数查询根据相关度打分是比较合理的需求，但合理的不一定是产品经理需要的。 以百度为例，你搜索的结果中，并不是相关度越高排名越靠前，而是谁掏的钱多排名就越靠前。如图： 要想认为控制相关性算分，就需要利用elasticsearch中的function score 查询了。 1）语法说明 function score 查询中包含四部分内容： 原始查询条件：query部分，基于这个条件搜索文档，并且基于BM25算法给文档打分，原始算分（query score) 过滤条件：filter部分，符合该条件的文档才会重新算分 算分函数：符合filter条件的文档要根据这个函数做运算，得到的函数算分（function score），有四种函数 weight：函数结果是常量 field_value_factor：以文档中的某个字段值作为函数结果 random_score：以随机数作为函数结果 script_score：自定义算分函数算法 运算模式：算分函数的结果、原始查询的相关性算分，两者之间的运算方式，包括： multiply：相乘 replace：用function score替换query score 其它，例如：sum、avg、max、min function score的运行流程如下： 1）根据原始条件查询搜索文档，并且计算相关性算分，称为原始算分（query score） 2）根据过滤条件，过滤文档 3）符合过滤条件的文档，基于算分函数运算，得到函数算分（function score） 4）将原始算分（query score）和函数算分（function score）基于运算模式做运算，得到最终结果，作为相关性算分。 因此，其中的关键点是： 过滤条件：决定哪些文档的算分被修改 算分函数：决定函数算分的算法 运算模式：决定最终算分结果 2）示例需求：给“如家”这个品牌的酒店排名靠前一些 翻译一下这个需求，转换为之前说的四个要点： 原始条件：不确定，可以任意变化 过滤条件：brand &#x3D; “如家” 算分函数：可以简单粗暴，直接给固定的算分结果，weight 运算模式：比如求和 因此最终的DSL语句如下： 12345678910111213141516171819GET /hotel/_search&#123; &quot;query&quot;: &#123; &quot;function_score&quot;: &#123; &quot;query&quot;: &#123; .... &#125;, // 原始查询，可以是任意条件 &quot;functions&quot;: [ // 算分函数 &#123; &quot;filter&quot;: &#123; // 满足的条件，品牌必须是如家 &quot;term&quot;: &#123; &quot;brand&quot;: &quot;如家&quot; &#125; &#125;, &quot;weight&quot;: 2 // 算分权重为2 &#125; ], &quot;boost_mode&quot;: &quot;sum&quot; // 加权模式，求和 &#125; &#125;&#125; 测试，在未添加算分函数时，如家得分如下： 添加了算分函数后，如家得分就提升了： 3）小结function score query定义的三要素是什么？ 过滤条件：哪些文档要加分 算分函数：如何计算function score 加权方式：function score 与 query score如何运算 1.5.3.布尔查询布尔查询是一个或多个查询子句的组合，每一个子句就是一个子查询。子查询的组合方式有： must：必须匹配每个子查询，类似“与” should：选择性匹配子查询，类似“或” must_not：必须不匹配，不参与算分，类似“非” filter：必须匹配，不参与算分 比如在搜索酒店时，除了关键字搜索外，我们还可能根据品牌、价格、城市等字段做过滤： 每一个不同的字段，其查询的条件、方式都不一样，必须是多个不同的查询，而要组合这些查询，就必须用bool查询了。 需要注意的是，搜索时，参与打分的字段越多，查询的性能也越差。因此这种多条件查询时，建议这样做： 搜索框的关键字搜索，是全文检索查询，使用must查询，参与算分 其它过滤条件，采用filter查询。不参与算分 1）语法示例：1234567891011121314151617181920GET /hotel/_search&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;must&quot;: [ &#123;&quot;term&quot;: &#123;&quot;city&quot;: &quot;上海&quot; &#125;&#125; ], &quot;should&quot;: [ &#123;&quot;term&quot;: &#123;&quot;brand&quot;: &quot;皇冠假日&quot; &#125;&#125;, &#123;&quot;term&quot;: &#123;&quot;brand&quot;: &quot;华美达&quot; &#125;&#125; ], &quot;must_not&quot;: [ &#123; &quot;range&quot;: &#123; &quot;price&quot;: &#123; &quot;lte&quot;: 500 &#125; &#125;&#125; ], &quot;filter&quot;: [ &#123; &quot;range&quot;: &#123;&quot;score&quot;: &#123; &quot;gte&quot;: 45 &#125; &#125;&#125; ] &#125; &#125;&#125; 2）示例需求：搜索名字包含“如家”，价格不高于400，在坐标31.21,121.5周围10km范围内的酒店。 分析： 名称搜索，属于全文检索查询，应该参与算分。放到must中 价格不高于400，用range查询，属于过滤条件，不参与算分。放到must_not中 周围10km范围内，用geo_distance查询，属于过滤条件，不参与算分。放到filter中 3）小结bool查询有几种逻辑关系？ must：必须匹配的条件，可以理解为“与” should：选择性匹配的条件，可以理解为“或” must_not：必须不匹配的条件，不参与打分 filter：必须匹配的条件，不参与打分","categories":[{"name":"elk","slug":"elk","permalink":"http://example.com/elk/"}],"tags":[{"name":"elk","slug":"elk","permalink":"http://example.com/tags/elk/"}]},{"title":"elk（五）-RestClient操作文档","slug":"elk/elk（五）-RestClient操作文档","date":"2023-06-30T07:19:24.000Z","updated":"2023-06-30T07:21:01.598Z","comments":true,"path":"2023/06/30/elk/elk（五）-RestClient操作文档/","link":"","permalink":"http://example.com/2023/06/30/elk/elk%EF%BC%88%E4%BA%94%EF%BC%89-RestClient%E6%93%8D%E4%BD%9C%E6%96%87%E6%A1%A3/","excerpt":"","text":"5.RestClient操作文档为了与索引库操作分离，我们再次参加一个测试类，做两件事情： 初始化RestHighLevelClient 我们的酒店数据在数据库，需要利用IHotelService去查询，所以注入这个接口 123456789101112131415161718192021222324252627282930313233package cn.itcast.hotel;import cn.itcast.hotel.pojo.Hotel;import cn.itcast.hotel.service.IHotelService;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;import java.util.List;@SpringBootTestpublic class HotelDocumentTest &#123; @Autowired private IHotelService hotelService; private RestHighLevelClient client; @BeforeEach void setUp() &#123; this.client = new RestHighLevelClient(RestClient.builder( HttpHost.create(&quot;http://192.168.150.101:9200&quot;) )); &#125; @AfterEach void tearDown() throws IOException &#123; this.client.close(); &#125;&#125; 5.1.新增文档我们要将数据库的酒店数据查询出来，写入elasticsearch中。 5.1.1.索引库实体类数据库查询后的结果是一个Hotel类型的对象。结构如下： 1234567891011121314151617@Data@TableName(&quot;tb_hotel&quot;)public class Hotel &#123; @TableId(type = IdType.INPUT) private Long id; private String name; private String address; private Integer price; private Integer score; private String brand; private String city; private String starName; private String business; private String longitude; private String latitude; private String pic;&#125; 与我们的索引库结构存在差异： longitude和latitude需要合并为location 因此，我们需要定义一个新的类型，与索引库结构吻合： 1234567891011121314151617181920212223242526272829303132333435package cn.itcast.hotel.pojo;import lombok.Data;import lombok.NoArgsConstructor;@Data@NoArgsConstructorpublic class HotelDoc &#123; private Long id; private String name; private String address; private Integer price; private Integer score; private String brand; private String city; private String starName; private String business; private String location; private String pic; public HotelDoc(Hotel hotel) &#123; this.id = hotel.getId(); this.name = hotel.getName(); this.address = hotel.getAddress(); this.price = hotel.getPrice(); this.score = hotel.getScore(); this.brand = hotel.getBrand(); this.city = hotel.getCity(); this.starName = hotel.getStarName(); this.business = hotel.getBusiness(); this.location = hotel.getLatitude() + &quot;, &quot; + hotel.getLongitude(); this.pic = hotel.getPic(); &#125;&#125; 5.1.2.语法说明新增文档的DSL语句如下： 12345POST /&#123;索引库名&#125;/_doc/1&#123; &quot;name&quot;: &quot;Jack&quot;, &quot;age&quot;: 21&#125; 对应的java代码如图： 可以看到与创建索引库类似，同样是三步走： 1）创建Request对象 2）准备请求参数，也就是DSL中的JSON文档 3）发送请求 变化的地方在于，这里直接使用client.xxx()的API，不再需要client.indices()了。 5.1.3.完整代码我们导入酒店数据，基本流程一致，但是需要考虑几点变化： 酒店数据来自于数据库，我们需要先查询出来，得到hotel对象 hotel对象需要转为HotelDoc对象 HotelDoc需要序列化为json格式 因此，代码整体步骤如下： 1）根据id查询酒店数据Hotel 2）将Hotel封装为HotelDoc 3）将HotelDoc序列化为JSON 4）创建IndexRequest，指定索引库名和id 5）准备请求参数，也就是JSON文档 6）发送请求 在hotel-demo的HotelDocumentTest测试类中，编写单元测试： 12345678910111213141516@Testvoid testAddDocument() throws IOException &#123; // 1.根据id查询酒店数据 Hotel hotel = hotelService.getById(61083L); // 2.转换为文档类型 HotelDoc hotelDoc = new HotelDoc(hotel); // 3.将HotelDoc转json String json = JSON.toJSONString(hotelDoc); // 1.准备Request对象 IndexRequest request = new IndexRequest(&quot;hotel&quot;).id(hotelDoc.getId().toString()); // 2.准备Json文档 request.source(json, XContentType.JSON); // 3.发送请求 client.index(request, RequestOptions.DEFAULT);&#125; 5.2.查询文档5.2.1.语法说明查询的DSL语句如下： 1GET /hotel/_doc/&#123;id&#125; 非常简单，因此代码大概分两步： 准备Request对象 发送请求 不过查询的目的是得到结果，解析为HotelDoc，因此难点是结果的解析。完整代码如下： 可以看到，结果是一个JSON，其中文档放在一个_source属性中，因此解析就是拿到_source，反序列化为Java对象即可。 与之前类似，也是三步走： 1）准备Request对象。这次是查询，所以是GetRequest 2）发送请求，得到结果。因为是查询，这里调用client.get()方法 3）解析结果，就是对JSON做反序列化 5.2.2.完整代码在hotel-demo的HotelDocumentTest测试类中，编写单元测试： 123456789101112@Testvoid testGetDocumentById() throws IOException &#123; // 1.准备Request GetRequest request = new GetRequest(&quot;hotel&quot;, &quot;61082&quot;); // 2.发送请求，得到响应 GetResponse response = client.get(request, RequestOptions.DEFAULT); // 3.解析响应结果 String json = response.getSourceAsString(); HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class); System.out.println(hotelDoc);&#125; 5.3.删除文档删除的DSL为是这样的： 1DELETE /hotel/_doc/&#123;id&#125; 与查询相比，仅仅是请求方式从DELETE变成GET，可以想象Java代码应该依然是三步走： 1）准备Request对象，因为是删除，这次是DeleteRequest对象。要指定索引库名和id 2）准备参数，无参 3）发送请求。因为是删除，所以是client.delete()方法 在hotel-demo的HotelDocumentTest测试类中，编写单元测试： 1234567@Testvoid testDeleteDocument() throws IOException &#123; // 1.准备Request DeleteRequest request = new DeleteRequest(&quot;hotel&quot;, &quot;61083&quot;); // 2.发送请求 client.delete(request, RequestOptions.DEFAULT);&#125; 5.4.修改文档5.4.1.语法说明修改我们讲过两种方式： 全量修改：本质是先根据id删除，再新增 增量修改：修改文档中的指定字段值 在RestClient的API中，全量修改与新增的API完全一致，判断依据是ID： 如果新增时，ID已经存在，则修改 如果新增时，ID不存在，则新增 这里不再赘述，我们主要关注增量修改。 代码示例如图： 与之前类似，也是三步走： 1）准备Request对象。这次是修改，所以是UpdateRequest 2）准备参数。也就是JSON文档，里面包含要修改的字段 3）更新文档。这里调用client.update()方法 5.4.2.完整代码在hotel-demo的HotelDocumentTest测试类中，编写单元测试： 123456789101112@Testvoid testUpdateDocument() throws IOException &#123; // 1.准备Request UpdateRequest request = new UpdateRequest(&quot;hotel&quot;, &quot;61083&quot;); // 2.准备请求参数 request.doc( &quot;price&quot;, &quot;952&quot;, &quot;starName&quot;, &quot;四钻&quot; ); // 3.发送请求 client.update(request, RequestOptions.DEFAULT);&#125; 5.5.批量导入文档案例需求：利用BulkRequest批量将数据库数据导入到索引库中。 步骤如下： 利用mybatis-plus查询酒店数据 将查询到的酒店数据（Hotel）转换为文档类型数据（HotelDoc） 利用JavaRestClient中的BulkRequest批处理，实现批量新增文档 5.5.1.语法说明批量处理BulkRequest，其本质就是将多个普通的CRUD请求组合在一起发送。 其中提供了一个add方法，用来添加其他请求： 可以看到，能添加的请求包括： IndexRequest，也就是新增 UpdateRequest，也就是修改 DeleteRequest，也就是删除 因此Bulk中添加了多个IndexRequest，就是批量新增功能了。示例： 其实还是三步走： 1）创建Request对象。这里是BulkRequest 2）准备参数。批处理的参数，就是其它Request对象，这里就是多个IndexRequest 3）发起请求。这里是批处理，调用的方法为client.bulk()方法 我们在导入酒店数据时，将上述代码改造成for循环处理即可。 5.5.2.完整代码在hotel-demo的HotelDocumentTest测试类中，编写单元测试： 12345678910111213141516171819@Testvoid testBulkRequest() throws IOException &#123; // 批量查询酒店数据 List&lt;Hotel&gt; hotels = hotelService.list(); // 1.创建Request BulkRequest request = new BulkRequest(); // 2.准备参数，添加多个新增的Request for (Hotel hotel : hotels) &#123; // 2.1.转换为文档类型HotelDoc HotelDoc hotelDoc = new HotelDoc(hotel); // 2.2.创建新增文档的Request对象 request.add(new IndexRequest(&quot;hotel&quot;) .id(hotelDoc.getId().toString()) .source(JSON.toJSONString(hotelDoc), XContentType.JSON)); &#125; // 3.发送请求 client.bulk(request, RequestOptions.DEFAULT);&#125; 5.6.小结文档操作的基本步骤： 初始化RestHighLevelClient 创建XxxRequest。XXX是Index、Get、Update、Delete、Bulk 准备参数（Index、Update、Bulk时需要） 发送请求。调用RestHighLevelClient#.xxx()方法，xxx是index、get、update、delete、bulk 解析结果（Get时需要）","categories":[{"name":"elk","slug":"elk","permalink":"http://example.com/elk/"}],"tags":[{"name":"elk","slug":"elk","permalink":"http://example.com/tags/elk/"}]},{"title":"elk（四）-RestAPI","slug":"elk/elk（四）-RestAPI","date":"2023-06-30T07:17:46.000Z","updated":"2023-06-30T07:21:00.631Z","comments":true,"path":"2023/06/30/elk/elk（四）-RestAPI/","link":"","permalink":"http://example.com/2023/06/30/elk/elk%EF%BC%88%E5%9B%9B%EF%BC%89-RestAPI/","excerpt":"","text":"4.RestAPIES官方提供了各种不同语言的客户端，用来操作ES。这些客户端的本质就是组装DSL语句，通过http请求发送给ES。官方文档地址：https://www.elastic.co/guide/en/elasticsearch/client/index.html 其中的Java Rest Client又包括两种： Java Low Level Rest Client Java High Level Rest Client 我们学习的是Java HighLevel Rest Client客户端API 4.0.导入Demo工程4.0.1.导入数据首先导入课前资料提供的数据库数据： 数据结构如下： 123456789101112131415CREATE TABLE `tb_hotel` ( `id` bigint(20) NOT NULL COMMENT &#x27;酒店id&#x27;, `name` varchar(255) NOT NULL COMMENT &#x27;酒店名称；例：7天酒店&#x27;, `address` varchar(255) NOT NULL COMMENT &#x27;酒店地址；例：航头路&#x27;, `price` int(10) NOT NULL COMMENT &#x27;酒店价格；例：329&#x27;, `score` int(2) NOT NULL COMMENT &#x27;酒店评分；例：45，就是4.5分&#x27;, `brand` varchar(32) NOT NULL COMMENT &#x27;酒店品牌；例：如家&#x27;, `city` varchar(32) NOT NULL COMMENT &#x27;所在城市；例：上海&#x27;, `star_name` varchar(16) DEFAULT NULL COMMENT &#x27;酒店星级，从低到高分别是：1星到5星，1钻到5钻&#x27;, `business` varchar(255) DEFAULT NULL COMMENT &#x27;商圈；例：虹桥&#x27;, `latitude` varchar(32) NOT NULL COMMENT &#x27;纬度；例：31.2497&#x27;, `longitude` varchar(32) NOT NULL COMMENT &#x27;经度；例：120.3925&#x27;, `pic` varchar(255) DEFAULT NULL COMMENT &#x27;酒店图片；例:/img/1.jpg&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 4.0.2.导入项目然后导入课前资料提供的项目: 项目结构如图： 4.0.3.mapping映射分析创建索引库，最关键的是mapping映射，而mapping映射要考虑的信息包括： 字段名 字段数据类型 是否参与搜索 是否需要分词 如果分词，分词器是什么？ 其中： 字段名、字段数据类型，可以参考数据表结构的名称和类型 是否参与搜索要分析业务来判断，例如图片地址，就无需参与搜索 是否分词呢要看内容，内容如果是一个整体就无需分词，反之则要分词 分词器，我们可以统一使用ik_max_word 来看下酒店数据的索引库结构: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950PUT /hotel&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;id&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;name&quot;:&#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;copy_to&quot;: &quot;all&quot; &#125;, &quot;address&quot;:&#123; &quot;type&quot;: &quot;keyword&quot;, &quot;index&quot;: false &#125;, &quot;price&quot;:&#123; &quot;type&quot;: &quot;integer&quot; &#125;, &quot;score&quot;:&#123; &quot;type&quot;: &quot;integer&quot; &#125;, &quot;brand&quot;:&#123; &quot;type&quot;: &quot;keyword&quot;, &quot;copy_to&quot;: &quot;all&quot; &#125;, &quot;city&quot;:&#123; &quot;type&quot;: &quot;keyword&quot;, &quot;copy_to&quot;: &quot;all&quot; &#125;, &quot;starName&quot;:&#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;business&quot;:&#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;location&quot;:&#123; &quot;type&quot;: &quot;geo_point&quot; &#125;, &quot;pic&quot;:&#123; &quot;type&quot;: &quot;keyword&quot;, &quot;index&quot;: false &#125;, &quot;all&quot;:&#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot; &#125; &#125; &#125;&#125; 几个特殊字段说明： location：地理坐标，里面包含精度、纬度 all：一个组合字段，其目的是将多字段的值 利用copy_to合并，提供给用户搜索 地理坐标说明： copy_to说明： 4.0.4.初始化RestClient在elasticsearch提供的API中，与elasticsearch一切交互都封装在一个名为RestHighLevelClient的类中，必须先完成这个对象的初始化，建立与elasticsearch的连接。 分为三步： 1）引入es的RestHighLevelClient依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;&lt;/dependency&gt; 2）因为SpringBoot默认的ES版本是7.6.2，所以我们需要覆盖默认的ES版本： 1234&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;elasticsearch.version&gt;7.12.1&lt;/elasticsearch.version&gt;&lt;/properties&gt; 3）初始化RestHighLevelClient： 初始化的代码如下： 123RestHighLevelClient client = new RestHighLevelClient(RestClient.builder( HttpHost.create(&quot;http://192.168.150.101:9200&quot;))); 这里为了单元测试方便，我们创建一个测试类HotelIndexTest，然后将初始化的代码编写在@BeforeEach方法中： 12345678910111213141516171819202122232425package cn.itcast.hotel;import org.apache.http.HttpHost;import org.elasticsearch.client.RestHighLevelClient;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import java.io.IOException;public class HotelIndexTest &#123; private RestHighLevelClient client; @BeforeEach void setUp() &#123; this.client = new RestHighLevelClient(RestClient.builder( HttpHost.create(&quot;http://192.168.150.101:9200&quot;) )); &#125; @AfterEach void tearDown() throws IOException &#123; this.client.close(); &#125;&#125; 4.1.创建索引库4.1.1.代码解读创建索引库的API如下： 代码分为三步： 1）创建Request对象。因为是创建索引库的操作，因此Request是CreateIndexRequest。 2）添加请求参数，其实就是DSL的JSON参数部分。因为json字符串很长，这里是定义了静态字符串常量MAPPING_TEMPLATE，让代码看起来更加优雅。 3）发送请求，client.indices()方法的返回值是IndicesClient类型，封装了所有与索引库操作有关的方法。 4.1.2.完整示例在hotel-demo的cn.itcast.hotel.constants包下，创建一个类，定义mapping映射的JSON字符串常量： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package cn.itcast.hotel.constants;public class HotelConstants &#123; public static final String MAPPING_TEMPLATE = &quot;&#123;\\n&quot; + &quot; \\&quot;mappings\\&quot;: &#123;\\n&quot; + &quot; \\&quot;properties\\&quot;: &#123;\\n&quot; + &quot; \\&quot;id\\&quot;: &#123;\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;keyword\\&quot;\\n&quot; + &quot; &#125;,\\n&quot; + &quot; \\&quot;name\\&quot;:&#123;\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;text\\&quot;,\\n&quot; + &quot; \\&quot;analyzer\\&quot;: \\&quot;ik_max_word\\&quot;,\\n&quot; + &quot; \\&quot;copy_to\\&quot;: \\&quot;all\\&quot;\\n&quot; + &quot; &#125;,\\n&quot; + &quot; \\&quot;address\\&quot;:&#123;\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;keyword\\&quot;,\\n&quot; + &quot; \\&quot;index\\&quot;: false\\n&quot; + &quot; &#125;,\\n&quot; + &quot; \\&quot;price\\&quot;:&#123;\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;integer\\&quot;\\n&quot; + &quot; &#125;,\\n&quot; + &quot; \\&quot;score\\&quot;:&#123;\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;integer\\&quot;\\n&quot; + &quot; &#125;,\\n&quot; + &quot; \\&quot;brand\\&quot;:&#123;\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;keyword\\&quot;,\\n&quot; + &quot; \\&quot;copy_to\\&quot;: \\&quot;all\\&quot;\\n&quot; + &quot; &#125;,\\n&quot; + &quot; \\&quot;city\\&quot;:&#123;\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;keyword\\&quot;,\\n&quot; + &quot; \\&quot;copy_to\\&quot;: \\&quot;all\\&quot;\\n&quot; + &quot; &#125;,\\n&quot; + &quot; \\&quot;starName\\&quot;:&#123;\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;keyword\\&quot;\\n&quot; + &quot; &#125;,\\n&quot; + &quot; \\&quot;business\\&quot;:&#123;\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;keyword\\&quot;\\n&quot; + &quot; &#125;,\\n&quot; + &quot; \\&quot;location\\&quot;:&#123;\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;geo_point\\&quot;\\n&quot; + &quot; &#125;,\\n&quot; + &quot; \\&quot;pic\\&quot;:&#123;\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;keyword\\&quot;,\\n&quot; + &quot; \\&quot;index\\&quot;: false\\n&quot; + &quot; &#125;,\\n&quot; + &quot; \\&quot;all\\&quot;:&#123;\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;text\\&quot;,\\n&quot; + &quot; \\&quot;analyzer\\&quot;: \\&quot;ik_max_word\\&quot;\\n&quot; + &quot; &#125;\\n&quot; + &quot; &#125;\\n&quot; + &quot; &#125;\\n&quot; + &quot;&#125;&quot;;&#125; 在hotel-demo中的HotelIndexTest测试类中，编写单元测试，实现创建索引： 123456789@Testvoid createHotelIndex() throws IOException &#123; // 1.创建Request对象 CreateIndexRequest request = new CreateIndexRequest(&quot;hotel&quot;); // 2.准备请求的参数：DSL语句 request.source(MAPPING_TEMPLATE, XContentType.JSON); // 3.发送请求 client.indices().create(request, RequestOptions.DEFAULT);&#125; 4.2.删除索引库删除索引库的DSL语句非常简单： 1DELETE /hotel 与创建索引库相比： 请求方式从PUT变为DELTE 请求路径不变 无请求参数 所以代码的差异，注意体现在Request对象上。依然是三步走： 1）创建Request对象。这次是DeleteIndexRequest对象 2）准备参数。这里是无参 3）发送请求。改用delete方法 在hotel-demo中的HotelIndexTest测试类中，编写单元测试，实现删除索引： 1234567@Testvoid testDeleteHotelIndex() throws IOException &#123; // 1.创建Request对象 DeleteIndexRequest request = new DeleteIndexRequest(&quot;hotel&quot;); // 2.发送请求 client.indices().delete(request, RequestOptions.DEFAULT);&#125; 4.3.判断索引库是否存在判断索引库是否存在，本质就是查询，对应的DSL是： 1GET /hotel 因此与删除的Java代码流程是类似的。依然是三步走： 1）创建Request对象。这次是GetIndexRequest对象 2）准备参数。这里是无参 3）发送请求。改用exists方法 123456789@Testvoid testExistsHotelIndex() throws IOException &#123; // 1.创建Request对象 GetIndexRequest request = new GetIndexRequest(&quot;hotel&quot;); // 2.发送请求 boolean exists = client.indices().exists(request, RequestOptions.DEFAULT); // 3.输出 System.err.println(exists ? &quot;索引库已经存在！&quot; : &quot;索引库不存在！&quot;);&#125; 4.4.总结JavaRestClient操作elasticsearch的流程基本类似。核心是client.indices()方法来获取索引库的操作对象。 索引库操作的基本步骤： 初始化RestHighLevelClient 创建XxxIndexRequest。XXX是Create、Get、Delete 准备DSL（ Create时需要，其它是无参） 发送请求。调用RestHighLevelClient#indices().xxx()方法，xxx是create、exists、delete","categories":[{"name":"elk","slug":"elk","permalink":"http://example.com/elk/"}],"tags":[{"name":"elk","slug":"elk","permalink":"http://example.com/tags/elk/"}]},{"title":"elk（三）-文档操作","slug":"elk/elk（三）-文档操作","date":"2023-06-30T07:16:09.000Z","updated":"2023-06-30T07:20:58.426Z","comments":true,"path":"2023/06/30/elk/elk（三）-文档操作/","link":"","permalink":"http://example.com/2023/06/30/elk/elk%EF%BC%88%E4%B8%89%EF%BC%89-%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C/","excerpt":"","text":"3.文档操作3.1.新增文档语法： 12345678910POST /索引库名/_doc/文档id&#123; &quot;字段1&quot;: &quot;值1&quot;, &quot;字段2&quot;: &quot;值2&quot;, &quot;字段3&quot;: &#123; &quot;子属性1&quot;: &quot;值3&quot;, &quot;子属性2&quot;: &quot;值4&quot; &#125;, // ...&#125; 示例： 123456789POST /heima/_doc/1&#123; &quot;info&quot;: &quot;黑马程序员Java讲师&quot;, &quot;email&quot;: &quot;zy@itcast.cn&quot;, &quot;name&quot;: &#123; &quot;firstName&quot;: &quot;云&quot;, &quot;lastName&quot;: &quot;赵&quot; &#125;&#125; 响应： 3.2.查询文档根据rest风格，新增是post，查询应该是get，不过查询一般都需要条件，这里我们把文档id带上。 语法： 1GET /&#123;索引库名称&#125;/_doc/&#123;id&#125; 通过kibana查看数据： 1GET /heima/_doc/1 查看结果： 3.3.删除文档删除使用DELETE请求，同样，需要根据id进行删除： 语法： 1DELETE /&#123;索引库名&#125;/_doc/id值 示例： 12# 根据id删除数据DELETE /heima/_doc/1 结果： 3.4.修改文档修改有两种方式： 全量修改：直接覆盖原来的文档 增量修改：修改文档中的部分字段 3.4.1.全量修改全量修改是覆盖原来的文档，其本质是： 根据指定的id删除文档 新增一个相同id的文档 注意：如果根据id删除时，id不存在，第二步的新增也会执行，也就从修改变成了新增操作了。 语法： 1234567PUT /&#123;索引库名&#125;/_doc/文档id&#123; &quot;字段1&quot;: &quot;值1&quot;, &quot;字段2&quot;: &quot;值2&quot;, // ... 略&#125; 示例： 123456789PUT /heima/_doc/1&#123; &quot;info&quot;: &quot;黑马程序员高级Java讲师&quot;, &quot;email&quot;: &quot;zy@itcast.cn&quot;, &quot;name&quot;: &#123; &quot;firstName&quot;: &quot;云&quot;, &quot;lastName&quot;: &quot;赵&quot; &#125;&#125; 3.4.2.增量修改增量修改是只修改指定id匹配的文档中的部分字段。 语法： 123456POST /&#123;索引库名&#125;/_update/文档id&#123; &quot;doc&quot;: &#123; &quot;字段名&quot;: &quot;新的值&quot;, &#125;&#125; 示例： 123456POST /heima/_update/1&#123; &quot;doc&quot;: &#123; &quot;email&quot;: &quot;ZhaoYun@itcast.cn&quot; &#125;&#125; 3.5.总结文档操作有哪些？ 创建文档：POST &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id { json文档 } 查询文档：GET &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id 删除文档：DELETE &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id 修改文档： 全量修改：PUT &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id { json文档 } 增量修改：POST &#x2F;{索引库名}&#x2F;_update&#x2F;文档id { “doc”: {字段}}","categories":[{"name":"elk","slug":"elk","permalink":"http://example.com/elk/"}],"tags":[{"name":"elk","slug":"elk","permalink":"http://example.com/tags/elk/"}]},{"title":"elk（二）-索引库操作","slug":"elk/elk（二）-索引库操作","date":"2023-06-30T07:11:50.000Z","updated":"2023-06-30T07:14:23.935Z","comments":true,"path":"2023/06/30/elk/elk（二）-索引库操作/","link":"","permalink":"http://example.com/2023/06/30/elk/elk%EF%BC%88%E4%BA%8C%EF%BC%89-%E7%B4%A2%E5%BC%95%E5%BA%93%E6%93%8D%E4%BD%9C/","excerpt":"","text":"2.索引库操作索引库就类似数据库表，mapping映射就类似表的结构。 我们要向es中存储数据，必须先创建“库”和“表”。 2.1.mapping映射属性mapping是对索引库中文档的约束，常见的mapping属性包括： type：字段数据类型，常见的简单类型有： 字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址） 数值：long、integer、short、byte、double、float、 布尔：boolean 日期：date 对象：object index：是否创建索引，默认为true analyzer：使用哪种分词器 properties：该字段的子字段 例如下面的json文档： 123456789101112&#123; &quot;age&quot;: 21, &quot;weight&quot;: 52.1, &quot;isMarried&quot;: false, &quot;info&quot;: &quot;黑马程序员Java讲师&quot;, &quot;email&quot;: &quot;zy@itcast.cn&quot;, &quot;score&quot;: [99.1, 99.5, 98.9], &quot;name&quot;: &#123; &quot;firstName&quot;: &quot;云&quot;, &quot;lastName&quot;: &quot;赵&quot; &#125;&#125; 对应的每个字段映射（mapping）： age：类型为 integer；参与搜索，因此需要index为true；无需分词器 weight：类型为float；参与搜索，因此需要index为true；无需分词器 isMarried：类型为boolean；参与搜索，因此需要index为true；无需分词器 info：类型为字符串，需要分词，因此是text；参与搜索，因此需要index为true；分词器可以用ik_smart email：类型为字符串，但是不需要分词，因此是keyword；不参与搜索，因此需要index为false；无需分词器 score：虽然是数组，但是我们只看元素的类型，类型为float；参与搜索，因此需要index为true；无需分词器 name：类型为object，需要定义多个子属性 name.firstName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器 name.lastName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器 2.2.索引库的CRUD这里我们统一使用Kibana编写DSL的方式来演示。 2.2.1.创建索引库和映射基本语法： 请求方式：PUT 请求路径：&#x2F;索引库名，可以自定义 请求参数：mapping映射 格式： 1234567891011121314151617181920212223PUT /索引库名称&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;字段名&quot;:&#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_smart&quot; &#125;, &quot;字段名2&quot;:&#123; &quot;type&quot;: &quot;keyword&quot;, &quot;index&quot;: &quot;false&quot; &#125;, &quot;字段名3&quot;:&#123; &quot;properties&quot;: &#123; &quot;子字段&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125; &#125; &#125;, // ...略 &#125; &#125;&#125; 示例：1234567891011121314151617181920212223PUT /heima&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;info&quot;:&#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_smart&quot; &#125;, &quot;email&quot;:&#123; &quot;type&quot;: &quot;keyword&quot;, &quot;index&quot;: &quot;falsae&quot; &#125;, &quot;name&quot;:&#123; &quot;properties&quot;: &#123; &quot;firstName&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125; &#125; &#125;, // ... 略 &#125; &#125;&#125; 2.2.2.查询索引库基本语法： 请求方式：GET 请求路径：&#x2F;索引库名 请求参数：无 格式： 1GET /索引库名 示例： 2.2.3.修改索引库倒排索引结构虽然不复杂，但是一旦数据结构改变（比如改变了分词器），就需要重新创建倒排索引，这简直是灾难。因此索引库一旦创建，无法修改mapping。 虽然无法修改mapping中已有的字段，但是却允许添加新的字段到mapping中，因为不会对倒排索引产生影响。 语法说明： 12345678PUT /索引库名/_mapping&#123; &quot;properties&quot;: &#123; &quot;新字段名&quot;:&#123; &quot;type&quot;: &quot;integer&quot; &#125; &#125;&#125; 示例： 2.2.4.删除索引库语法： 请求方式：DELETE 请求路径：&#x2F;索引库名 请求参数：无 格式： 1DELETE /索引库名 在kibana中测试： 2.2.5.总结索引库操作有哪些？ 创建索引库：PUT &#x2F;索引库名 查询索引库：GET &#x2F;索引库名 删除索引库：DELETE &#x2F;索引库名 添加字段：PUT &#x2F;索引库名&#x2F;_mapping","categories":[{"name":"elk","slug":"elk","permalink":"http://example.com/elk/"}],"tags":[{"name":"elk","slug":"elk","permalink":"http://example.com/tags/elk/"}]},{"title":"elk（一）-初识elk","slug":"elk/elk（一）-初识elk","date":"2023-06-30T07:05:17.000Z","updated":"2023-06-30T07:08:29.975Z","comments":true,"path":"2023/06/30/elk/elk（一）-初识elk/","link":"","permalink":"http://example.com/2023/06/30/elk/elk%EF%BC%88%E4%B8%80%EF%BC%89-%E5%88%9D%E8%AF%86elk/","excerpt":"","text":"1.初识elasticsearch1.1.了解ES1.1.1.elasticsearch的作用elasticsearch是一款非常强大的开源搜索引擎，具备非常多强大功能，可以帮助我们从海量数据中快速找到需要的内容 例如： 在GitHub搜索代码 在电商网站搜索商品 在百度搜索答案 在打车软件搜索附近的车 1.1.2.ELK技术栈elasticsearch结合kibana、Logstash、Beats，也就是elastic stack（ELK）。被广泛应用在日志数据分析、实时监控等领域： 而elasticsearch是elastic stack的核心，负责存储、搜索、分析数据。 1.1.3.elasticsearch和luceneelasticsearch底层是基于lucene来实现的。 Lucene是一个Java语言的搜索引擎类库，是Apache公司的顶级项目，由DougCutting于1999年研发。官网地址：https://lucene.apache.org/ 。 elasticsearch的发展历史： 2004年Shay Banon基于Lucene开发了Compass 2010年Shay Banon 重写了Compass，取名为Elasticsearch。 1.1.4.为什么不是其他搜索技术？目前比较知名的搜索引擎技术排名： 虽然在早期，Apache Solr是最主要的搜索引擎技术，但随着发展elasticsearch已经渐渐超越了Solr，独占鳌头： 1.1.5.总结什么是elasticsearch？ 一个开源的分布式搜索引擎，可以用来实现搜索、日志统计、分析、系统监控等功能 什么是elastic stack（ELK）？ 是以elasticsearch为核心的技术栈，包括beats、Logstash、kibana、elasticsearch 什么是Lucene？ 是Apache的开源搜索引擎类库，提供了搜索引擎的核心API","categories":[{"name":"elk","slug":"elk","permalink":"http://example.com/elk/"}],"tags":[{"name":"elk","slug":"elk","permalink":"http://example.com/tags/elk/"}]},{"title":"ts（二）-面向对象","slug":"vue3/typeScript/ts（二）-面向对象","date":"2023-06-29T09:22:43.000Z","updated":"2023-06-29T09:23:23.438Z","comments":true,"path":"2023/06/29/vue3/typeScript/ts（二）-面向对象/","link":"","permalink":"http://example.com/2023/06/29/vue3/typeScript/ts%EF%BC%88%E4%BA%8C%EF%BC%89-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"第二章：面向对象面向对象是程序中一个非常重要的思想，它被很多同学理解成了一个比较难，比较深奥的问题，其实不然。面向对象很简单，简而言之就是程序之中所有的操作都需要通过对象来完成。 举例来说： 操作浏览器要使用window对象 操作网页要使用document对象 操作控制台要使用console对象 一切操作都要通过对象，也就是所谓的面向对象，那么对象到底是什么呢？这就要先说到程序是什么，计算机程序的本质就是对现实事物的抽象，抽象的反义词是具体，比如：照片是对一个具体的人的抽象，汽车模型是对具体汽车的抽象等等。程序也是对事物的抽象，在程序中我们可以表示一个人、一条狗、一把枪、一颗子弹等等所有的事物。一个事物到了程序中就变成了一个对象。 在程序中所有的对象都被分成了两个部分数据和功能，以人为例，人的姓名、性别、年龄、身高、体重等属于数据，人可以说话、走路、吃饭、睡觉这些属于人的功能。数据在对象中被成为属性，而功能就被称为方法。所以简而言之，在程序中一切皆是对象。 1、类（class）要想面向对象，操作对象，首先便要拥有对象，那么下一个问题就是如何创建对象。要创建对象，必须要先定义类，所谓的类可以理解为对象的模型，程序中可以根据类创建指定类型的对象，举例来说：可以通过Person类来创建人的对象，通过Dog类创建狗的对象，通过Car类来创建汽车的对象，不同的类可以用来创建不同的对象。 定义类： class 类名 &#123; 属性名: 类型; constructor(参数: 类型)&#123; this.属性名 = 参数; &#125; 方法名()&#123; .... &#125; &#125; 1234567891011121314151617- 示例： - ```typescript class Person&#123; name: string; age: number; constructor(name: string, age: number)&#123; this.name = name; this.age = age; &#125; sayHello()&#123; console.log(`大家好，我是$&#123;this.name&#125;`); &#125; &#125; 使用类： const p = new Person(&#39;孙悟空&#39;, 18); p.sayHello(); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647## 2、面向对象的特点- 封装 - 对象实质上就是属性和方法的容器，它的主要作用就是存储属性和方法，这就是所谓的封装 - 默认情况下，对象的属性是可以任意的修改的，为了确保数据的安全性，在TS中可以对属性的权限进行设置 - 只读属性（readonly）： - 如果在声明属性时添加一个readonly，则属性便成了只读属性无法修改 - TS中属性具有三种修饰符： - public（默认值），可以在类、子类和对象中修改 - protected ，可以在类、子类中修改 - private ，可以在类中修改 - 示例： - public - ```typescript class Person&#123; public name: string; // 写或什么都不写都是public public age: number; constructor(name: string, age: number)&#123; this.name = name; // 可以在类中修改 this.age = age; &#125; sayHello()&#123; console.log(`大家好，我是$&#123;this.name&#125;`); &#125; &#125; class Employee extends Person&#123; constructor(name: string, age: number)&#123; super(name, age); this.name = name; //子类中可以修改 &#125; &#125; const p = new Person(&#x27;孙悟空&#x27;, 18); p.name = &#x27;猪八戒&#x27;;// 可以通过对象修改 - protected - ```typescript class Person&#123; protected name: string; protected age: number; constructor(name: string, age: number)&#123; this.name = name; // 可以修改 this.age = age; &#125; sayHello()&#123; console.log(`大家好，我是$&#123;this.name&#125;`); &#125; &#125; class Employee extends Person&#123; constructor(name: string, age: number)&#123; super(name, age); this.name = name; //子类中可以修改 &#125; &#125; const p = new Person(&#39;孙悟空&#39;, 18); p.name = &#39;猪八戒&#39;;// 不能修改 12345678910111213141516171819202122232425262728- private - ```typescript class Person&#123; private name: string; private age: number; constructor(name: string, age: number)&#123; this.name = name; // 可以修改 this.age = age; &#125; sayHello()&#123; console.log(`大家好，我是$&#123;this.name&#125;`); &#125; &#125; class Employee extends Person&#123; constructor(name: string, age: number)&#123; super(name, age); this.name = name; //子类中不能修改 &#125; &#125; const p = new Person(&#x27;孙悟空&#x27;, 18); p.name = &#x27;猪八戒&#x27;;// 不能修改 属性存取器 对于一些不希望被任意修改的属性，可以将其设置为private 直接将其设置为private将导致无法再通过对象修改其中的属性 我们可以在类中定义一组读取、设置属性的方法，这种对属性读取或设置的属性被称为属性的存取器 读取属性的方法叫做setter方法，设置属性的方法叫做getter方法 示例： class Person&#123; private _name: string; constructor(name: string)&#123; this._name = name; &#125; get name()&#123; return this._name; &#125; set name(name: string)&#123; this._name = name; &#125; &#125; const p1 = new Person(&#39;孙悟空&#39;); console.log(p1.name); // 通过getter读取name属性 p1.name = &#39;猪八戒&#39;; // 通过setter修改name属性 1234567891011121314151617181920- 静态属性 - 静态属性（方法），也称为类属性。使用静态属性无需创建实例，通过类即可直接使用 - 静态属性（方法）使用static开头 - 示例： - ```typescript class Tools&#123; static PI = 3.1415926; static sum(num1: number, num2: number)&#123; return num1 + num2 &#125; &#125; console.log(Tools.PI); console.log(Tools.sum(123, 456)); this 在类中，使用this表示当前对象 继承 继承时面向对象中的又一个特性 通过继承可以将其他类中的属性和方法引入到当前类中 示例： class Animal&#123; name: string; age: number; constructor(name: string, age: number)&#123; this.name = name; this.age = age; &#125; &#125; class Dog extends Animal&#123; bark()&#123; console.log(`$&#123;this.name&#125;在汪汪叫！`); &#125; &#125; const dog = new Dog(&#39;旺财&#39;, 4); dog.bark(); 12345678910111213141516171819202122232425262728293031323334353637- 通过继承可以在不修改类的情况下完成对类的扩展- 重写 - 发生继承时，如果子类中的方法会替换掉父类中的同名方法，这就称为方法的重写 - 示例： - ```typescript class Animal&#123; name: string; age: number; constructor(name: string, age: number)&#123; this.name = name; this.age = age; &#125; run()&#123; console.log(`父类中的run方法！`); &#125; &#125; class Dog extends Animal&#123; bark()&#123; console.log(`$&#123;this.name&#125;在汪汪叫！`); &#125; run()&#123; console.log(`子类中的run方法，会重写父类中的run方法！`); &#125; &#125; const dog = new Dog(&#x27;旺财&#x27;, 4); dog.bark(); 在子类中可以使用super来完成对父类的引用 抽象类（abstract class） 抽象类是专门用来被其他类所继承的类，它只能被其他类所继承不能用来创建实例 abstract class Animal&#123; abstract run(): void; bark()&#123; console.log(&#39;动物在叫~&#39;); &#125; &#125; class Dog extends Animals&#123; run()&#123; console.log(&#39;狗在跑~&#39;); &#125; &#125; 1234567891011121314151617181920212223 - 使用abstract开头的方法叫做抽象方法，抽象方法没有方法体只能定义在抽象类中，继承抽象类时抽象方法必须要实现 ## 3、接口（Interface）接口的作用类似于抽象类，不同点在于接口中的所有方法和属性都是没有实值的，换句话说接口中的所有方法都是抽象方法。接口主要负责定义一个类的结构，接口可以去限制一个对象的接口，对象只有包含接口中定义的所有属性和方法时才能匹配接口。同时，可以让一个类去实现接口，实现接口时类中要保护接口中的所有属性。- 示例（检查对象类型）： - ```typescript interface Person&#123; name: string; sayHello():void; &#125; function fn(per: Person)&#123; per.sayHello(); &#125; fn(&#123;name:&#x27;孙悟空&#x27;, sayHello() &#123;console.log(`Hello, 我是 $&#123;this.name&#125;`)&#125;&#125;); 示例（实现） interface Person&#123; name: string; sayHello():void; &#125; class Student implements Person&#123; constructor(public name: string) &#123; &#125; sayHello() &#123; console.log(&#39;大家好，我是&#39;+this.name); &#125; &#125; 123456789101112131415 - ## 4、泛型（Generic）定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定），此时泛型便能够发挥作用。- 举个例子： - ```typescript function test(arg: any): any&#123; return arg; &#125; 上例中，test函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的，由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的，首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型 使用泛型： function test&lt;T&gt;(arg: T): T&#123; return arg; &#125; 123456789- 这里的```&lt;T&gt;```就是泛型，T是我们给这个类型起的名字（不一定非叫T），设置泛型后即可在函数中使用T来表示该类型。所以泛型其实很好理解，就表示某个类型。- 那么如何使用上边的函数呢？ - 方式一（直接使用）： - ```typescript test(10) - 使用时可以直接传递参数使用，类型会由TS自动推断出来，但有时编译器无法自动推断时还需要使用下面的方式 - 方式二（指定类型）： - ```typescript test&lt;number&gt;(10) 1234567891011 - 也可以在函数后手动指定泛型- 可以同时指定多个泛型，泛型间使用逗号隔开： - ```typescript function test&lt;T, K&gt;(a: T, b: K): K&#123; return b; &#125; test&lt;number, string&gt;(10, &quot;hello&quot;); - 使用泛型时，完全可以将泛型当成是一个普通的类去使用 类中同样可以使用泛型： class MyClass&lt;T&gt;&#123; prop: T; constructor(prop: T)&#123; this.prop = prop; &#125; &#125; 1234567891011- 除此之外，也可以对泛型的范围进行约束 - ```typescript interface MyInter&#123; length: number; &#125; function test&lt;T extends MyInter&gt;(arg: T): number&#123; return arg.length; &#125; 使用T extends MyInter表示泛型T必须是MyInter的子类，不一定非要使用接口类和抽象类同样适用。","categories":[{"name":"ts","slug":"ts","permalink":"http://example.com/ts/"}],"tags":[{"name":"ts","slug":"ts","permalink":"http://example.com/tags/ts/"}]},{"title":"ts（一）-快速入门","slug":"vue3/typeScript/ts（一）-快速入门","date":"2023-06-29T09:21:11.000Z","updated":"2023-06-29T09:22:15.472Z","comments":true,"path":"2023/06/29/vue3/typeScript/ts（一）-快速入门/","link":"","permalink":"http://example.com/2023/06/29/vue3/typeScript/ts%EF%BC%88%E4%B8%80%EF%BC%89-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","excerpt":"","text":"第一章 快速入门0、TypeScript简介 TypeScript是JavaScript的超集。 它对JS进行了扩展，向JS中引入了类型的概念，并添加了许多新的特性。 TS代码需要通过编译器编译为JS，然后再交由JS解析器执行。 TS完全兼容JS，换言之，任何的JS代码都可以直接当成JS使用。 相较于JS而言，TS拥有了静态类型，更加严格的语法，更强大的功能；TS可以在代码执行前就完成代码的检查，减小了运行时异常的出现的几率；TS代码可以编译为任意版本的JS代码，可有效解决不同JS运行环境的兼容问题；同样的功能，TS的代码量要大于JS，但由于TS的代码结构更加清晰，变量类型更加明确，在后期代码的维护中TS却远远胜于JS。 1、TypeScript 开发环境搭建 下载Node.js 64位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi 32位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi 安装Node.js 使用npm全局安装typescript 进入命令行 输入：npm i -g typescript 创建一个ts文件 使用tsc对ts文件进行编译 进入命令行 进入ts文件所在目录 执行命令：tsc xxx.ts 2、基本类型 类型声明 类型声明是TS非常重要的一个特点 通过类型声明可以指定TS中变量（参数、形参）的类型 指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错 简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值 语法： let 变量: 类型; let 变量: 类型 = 值; function fn(参数: 类型, 参数: 类型): 类型&#123; ... &#125; 1234567891011121314151617181920212223242526272829303132- 自动类型判断 - TS拥有自动的类型判断机制 - 当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型 - 所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明- 类型： | 类型 | 例子 | 描述 | | :-----: | :---------------: | :----------------------------: | | number | 1, -33, 2.5 | 任意数字 | | string | &#x27;hi&#x27;, &quot;hi&quot;, `hi` | 任意字符串 | | boolean | true、false | 布尔值true或false | | 字面量 | 其本身 | 限制变量的值就是该字面量的值 | | any | * | 任意类型 | | unknown | * | 类型安全的any | | void | 空值（undefined） | 没有值（或undefined） | | never | 没有值 | 不能是任何值 | | object | &#123;name:&#x27;孙悟空&#x27;&#125; | 任意的JS对象 | | array | [1,2,3] | 任意JS数组 | | tuple | [4,5] | 元素，TS新增类型，固定长度数组 | | enum | enum&#123;A, B&#125; | 枚举，TS中新增类型 |- number - ```typescript let decimal: number = 6; let hex: number = 0xf00d; let binary: number = 0b1010; let octal: number = 0o744; let big: bigint = 100n; boolean let isDone: boolean = false; 123456789101112- string - ```typescript let color: string = &quot;blue&quot;; color = &#x27;red&#x27;; let fullName: string = `Bob Bobbington`; let age: number = 37; let sentence: string = `Hello, my name is $&#123;fullName&#125;. I&#x27;ll be $&#123;age + 1&#125; years old next month.`; 字面量 也可以使用字面量去指定变量的类型，通过字面量可以确定变量的取值范围 let color: &#39;red&#39; | &#39;blue&#39; | &#39;black&#39;; let num: 1 | 2 | 3 | 4 | 5; 1234567- any - ```typescript let d: any = 4; d = &#x27;hello&#x27;; d = true; unknown let notSure: unknown = 4; notSure = &#39;hello&#39;; 12345- void - ```typescript let unusable: void = undefined; never function error(message: string): never &#123; throw new Error(message); &#125; 12345- object（没啥用） - ```typescript let obj: object = &#123;&#125;; array let list: number[] = [1, 2, 3]; let list: Array&lt;number&gt; = [1, 2, 3]; 123456- tuple - ```typescript let x: [string, number]; x = [&quot;hello&quot;, 10]; enum enum Color &#123; Red, Green, Blue, &#125; let c: Color = Color.Green; enum Color &#123; Red = 1, Green, Blue, &#125; let c: Color = Color.Green; enum Color &#123; Red = 1, Green = 2, Blue = 4, &#125; let c: Color = Color.Green; 12345678910- 类型断言 - 有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式： - 第一种 - ```typescript let someValue: unknown = &quot;this is a string&quot;; let strLength: number = (someValue as string).length; - 第二种 - ```typescript let someValue: unknown = &quot;this is a string&quot;; let strLength: number = (&lt;string&gt;someValue).length; 12345678910111213 ## 3、编译选项- 自动编译文件 - 编译文件时，使用 -w 指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。 - 示例： - ```powershell tsc xxx.ts -w 自动编译整个项目 如果直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件。 但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json tsconfig.json是一个JSON文件，添加配置文件后，只需只需 tsc 命令即可完成对整个项目的编译 配置选项： include 定义希望被编译文件所在的目录 默认值：[“**&#x2F;*“] 示例： &quot;include&quot;:[&quot;src/**/*&quot;, &quot;tests/**/*&quot;] 12345678910111213 - 上述示例中，所有src目录和tests目录下的文件都会被编译- exclude - 定义需要排除在外的目录 - 默认值：[&quot;node_modules&quot;, &quot;bower_components&quot;, &quot;jspm_packages&quot;] - 示例： - ```json &quot;exclude&quot;: [&quot;./src/hello/**/*&quot;] 上述示例中，src下hello目录下的文件都不会被编译 extends 定义被继承的配置文件 示例： &quot;extends&quot;: &quot;./configs/base&quot; 123456789101112131415161718192021 - 上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息- files - 指定被编译文件的列表，只有需要编译的文件少时才会用到 - 示例： - ```json &quot;files&quot;: [ &quot;core.ts&quot;, &quot;sys.ts&quot;, &quot;types.ts&quot;, &quot;scanner.ts&quot;, &quot;parser.ts&quot;, &quot;utilities.ts&quot;, &quot;binder.ts&quot;, &quot;checker.ts&quot;, &quot;tsc.ts&quot; ] 列表中的文件都会被TS编译器所编译 compilerOptions 编译选项是配置文件中非常重要也比较复杂的配置选项 在compilerOptions中包含多个子选项，用来完成对编译的配置 项目选项 target 设置ts代码编译的目标版本 可选值： ES3（默认）、ES5、ES6&#x2F;ES2015、ES7&#x2F;ES2016、ES2017、ES2018、ES2019、ES2020、ESNext 示例： &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;ES6&quot; &#125; 1234567891011121314151617181920 - 如上设置，我们所编写的ts代码将会被编译为ES6版本的js代码- lib - 指定代码运行时所包含的库（宿主环境） - 可选值： - ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ...... - 示例： - ```json &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;ES6&quot;, &quot;lib&quot;: [&quot;ES6&quot;, &quot;DOM&quot;], &quot;outDir&quot;: &quot;dist&quot;, &quot;outFile&quot;: &quot;dist/aa.js&quot; &#125; module 设置编译后代码使用的模块化系统 可选值： CommonJS、UMD、AMD、System、ES2020、ESNext、None 示例： &quot;compilerOptions&quot;: &#123; &quot;module&quot;: &quot;CommonJS&quot; &#125; 12345678910111213- outDir - 编译后文件的所在目录 - 默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置 - 示例： - ```json &quot;compilerOptions&quot;: &#123; &quot;outDir&quot;: &quot;dist&quot; &#125; 设置后编译后的js文件将会生成到dist目录 outFile 将所有的文件编译为一个js文件 默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中 示例： &quot;compilerOptions&quot;: &#123; &quot;outFile&quot;: &quot;dist/app.js&quot; &#125; 1234567891011- rootDir - 指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录 - 示例： - ```json &quot;compilerOptions&quot;: &#123; &quot;rootDir&quot;: &quot;./src&quot; &#125; allowJs 是否对js文件编译 checkJs 是否对js文件进行检查 示例： &quot;compilerOptions&quot;: &#123; &quot;allowJs&quot;: true, &quot;checkJs&quot;: true &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141 - removeComments - 是否删除注释 - 默认值：false - noEmit - 不对代码进行编译 - 默认值：false - sourceMap - 是否生成sourceMap - 默认值：false - 严格检查 - strict - 启用所有的严格检查，默认值为true，设置后相当于开启了所有的严格检查 - alwaysStrict - 总是以严格模式对代码进行编译 - noImplicitAny - 禁止隐式的any类型 - noImplicitThis - 禁止类型不明确的this - strictBindCallApply - 严格检查bind、call和apply的参数列表 - strictFunctionTypes - 严格检查函数的类型 - strictNullChecks - 严格的空值检查 - strictPropertyInitialization - 严格检查属性是否初始化 - 额外检查 - noFallthroughCasesInSwitch - 检查switch语句包含正确的break - noImplicitReturns - 检查函数没有隐式的返回值 - noUnusedLocals - 检查未使用的局部变量 - noUnusedParameters - 检查未使用的参数 - 高级 - allowUnreachableCode - 检查不可达代码 - 可选值： - true，忽略不可达代码 - false，不可达代码将引起错误 - noEmitOnError - 有错误的情况下不进行编译 - 默认值：false## 4、webpack- 通常情况下，实际开发中我们都需要使用构建工具对代码进行打包，TS同样也可以结合构建工具一起使用，下边以webpack为例介绍一下如何结合构建工具使用TS。- 步骤： 1. 初始化项目 - 进入项目根目录，执行命令 ``` npm init -y``` - 主要作用：创建package.json文件 2. 下载构建工具 - ```npm i -D webpack webpack-cli webpack-dev-server typescript ts-loader clean-webpack-plugin``` - 共安装了7个包 - webpack - 构建工具webpack - webpack-cli - webpack的命令行工具 - webpack-dev-server - webpack的开发服务器 - typescript - ts编译器 - ts-loader - ts加载器，用于在webpack中编译ts文件 - html-webpack-plugin - webpack中html插件，用来自动创建html文件 - clean-webpack-plugin - webpack中的清除插件，每次构建都会先清除目录 3. 根目录下创建webpack的配置文件webpack.config.js - ```javascript const path = require(&quot;path&quot;); const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;); const &#123; CleanWebpackPlugin &#125; = require(&quot;clean-webpack-plugin&quot;); module.exports = &#123; optimization:&#123; minimize: false // 关闭代码压缩，可选 &#125;, entry: &quot;./src/index.ts&quot;, devtool: &quot;inline-source-map&quot;, devServer: &#123; contentBase: &#x27;./dist&#x27; &#125;, output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;bundle.js&quot;, environment: &#123; arrowFunction: false // 关闭webpack的箭头函数，可选 &#125; &#125;, resolve: &#123; extensions: [&quot;.ts&quot;, &quot;.js&quot;] &#125;, module: &#123; rules: [ &#123; test: /\\.ts$/, use: &#123; loader: &quot;ts-loader&quot; &#125;, exclude: /node_modules/ &#125; ] &#125;, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; title:&#x27;TS测试&#x27; &#125;), ] &#125; 根目录下创建tsconfig.json，配置可以根据自己需要 &#123; &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;ES2015&quot;, &quot;module&quot;: &quot;ES2015&quot;, &quot;strict&quot;: true &#125; &#125; 123456789101112135. 修改package.json添加如下配置 - ```json &#123; ...略... &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;build&quot;: &quot;webpack&quot;, &quot;start&quot;: &quot;webpack serve --open chrome.exe&quot; &#125;, ...略... &#125; 在src下创建ts文件，并在并命令行执行npm run build对代码进行编译，或者执行npm start来启动开发服务器 5、Babel 经过一系列的配置，使得TS和webpack已经结合到了一起，除了webpack，开发中还经常需要结合babel来对代码进行转换以使其可以兼容到更多的浏览器，在上述步骤的基础上，通过以下步骤再将babel引入到项目中。 安装依赖包： npm i -D @babel/core @babel/preset-env babel-loader core-js 共安装了4个包，分别是： @babel&#x2F;core babel的核心工具 @babel&#x2F;preset-env babel的预定义环境 @babel-loader babel在webpack中的加载器 core-js core-js用来使老版本的浏览器支持新版ES语法 修改webpack.config.js配置文件 ...略... module: &#123; rules: [ &#123; test: /\\.ts$/, use: [ &#123; loader: &quot;babel-loader&quot;, options:&#123; presets: [ [ &quot;@babel/preset-env&quot;, &#123; &quot;targets&quot;:&#123; &quot;chrome&quot;: &quot;58&quot;, &quot;ie&quot;: &quot;11&quot; &#125;, &quot;corejs&quot;:&quot;3&quot;, &quot;useBuiltIns&quot;: &quot;usage&quot; &#125; ] ] &#125; &#125;, &#123; loader: &quot;ts-loader&quot;, &#125; ], exclude: /node_modules/ &#125; ] &#125; ...略... 如此一来，使用ts编译后的文件将会再次被babel处理，使得代码可以在大部分浏览器中直接使用，可以在配置选项的targets中指定要兼容的浏览器版本。","categories":[{"name":"ts","slug":"ts","permalink":"http://example.com/ts/"}],"tags":[{"name":"ts","slug":"ts","permalink":"http://example.com/tags/ts/"}]},{"title":"CyclicBarrierDemo","slug":"juc/CyclicBarrierDemo","date":"2023-06-25T09:47:13.000Z","updated":"2023-06-25T09:52:13.091Z","comments":true,"path":"2023/06/25/juc/CyclicBarrierDemo/","link":"","permalink":"http://example.com/2023/06/25/juc/CyclicBarrierDemo/","excerpt":"","text":"力扣22 三个线程循环打印abcCyclicBarrier作用是让一组线程相互等待，当达到一个共同点时，所有之前等待的线程再继续执行 1234567891011121314151617181920212223242526272829303132public class CyclicBarrierDemo &#123; private static int sharedCount; public static void main(String[] args) throws InterruptedException &#123; String printString = &quot;ABC&quot;; CyclicBarrier barrier = new CyclicBarrier(3, () -&gt; &#123; &#125;); Runnable runnable = new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; printString.length(); i++) &#123; synchronized (this)&#123; sharedCount = sharedCount &gt; 2 ? 0 : sharedCount; System.out.println(printString.toCharArray()[sharedCount++]); &#125; try &#123; barrier.await(); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125; &#125;; new Thread(runnable).start(); new Thread(runnable).start(); new Thread(runnable).start(); &#125;&#125;","categories":[{"name":"juc","slug":"juc","permalink":"http://example.com/juc/"}],"tags":[{"name":"juc","slug":"juc","permalink":"http://example.com/tags/juc/"}]},{"title":"RocketMq（五）--集成springboot","slug":"mq/RocketMq/RocketMq（五）-集成springboot","date":"2023-06-19T02:38:02.000Z","updated":"2023-06-19T02:53:04.761Z","comments":true,"path":"2023/06/19/mq/RocketMq/RocketMq（五）-集成springboot/","link":"","permalink":"http://example.com/2023/06/19/mq/RocketMq/RocketMq%EF%BC%88%E4%BA%94%EF%BC%89-%E9%9B%86%E6%88%90springboot/","excerpt":"","text":"Rocketmq集成SpringBoot搭建rocketmq-producer（消息生产者） 创建项目，完整的pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;?*xml version=\\&quot;1.0\\&quot; encoding=\\&quot;UTF-8\\&quot;*?\\&gt; \\&lt;project xmlns=\\&quot;http://maven.apache.org/POM/4.0.0\\&quot; xmlns:xsi=\\&quot;http://www.w3.org/2001/XMLSchema-instance\\&quot; xsi:schemaLocation=\\&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\\&quot;\\&gt; \\&lt;modelVersion\\&gt;4.0.0\\&lt;/modelVersion\\&gt; \\&lt;parent\\&gt; \\&lt;groupId\\&gt;org.springframework.boot\\&lt;/groupId\\&gt; \\&lt;artifactId\\&gt;spring-boot-starter-parent\\&lt;/artifactId\\&gt; \\&lt;version\\&gt;2.6.3\\&lt;/version\\&gt; \\&lt;relativePath/\\&gt; &lt;!\\-- lookup parent from repository \\--\\&gt; \\&lt;/parent\\&gt; \\&lt;groupId\\&gt;com.powernode\\&lt;/groupId\\&gt; \\&lt;artifactId\\&gt;01-rocketmq-producer\\&lt;/artifactId\\&gt; \\&lt;version\\&gt;0.0.1-SNAPSHOT\\&lt;/version\\&gt; \\&lt;name\\&gt;rocketmq-producer\\&lt;/name\\&gt; \\&lt;description\\&gt;Demo project for Spring Boot\\&lt;/description\\&gt; \\&lt;properties\\&gt; \\&lt;java.version\\&gt;1.8\\&lt;/java.version\\&gt; \\&lt;/properties\\&gt; \\&lt;dependencies\\&gt; \\&lt;dependency\\&gt; \\&lt;groupId\\&gt;org.springframework.boot\\&lt;/groupId\\&gt; \\&lt;artifactId\\&gt;spring-boot-starter-web\\&lt;/artifactId\\&gt; \\&lt;/dependency\\&gt; **&lt;!\\-- rocketmq的依赖 \\--\\&gt;** *&lt;dependency\\&gt;* *&lt;groupId\\&gt;org.apache.rocketmq\\&lt;/groupId\\&gt;* *&lt;artifactId\\&gt;rocketmq-spring-boot-starter\\&lt;/artifactId\\&gt;* *&lt;version\\&gt;2.0.2\\&lt;/version\\&gt;* *&lt;/dependency\\&gt;* \\&lt;dependency\\&gt; \\&lt;groupId\\&gt;org.projectlombok\\&lt;/groupId\\&gt; \\&lt;artifactId\\&gt;lombok\\&lt;/artifactId\\&gt; \\&lt;optional\\&gt;true\\&lt;/optional\\&gt; \\&lt;/dependency\\&gt; \\&lt;dependency\\&gt; \\&lt;groupId\\&gt;org.springframework.boot\\&lt;/groupId\\&gt; \\&lt;artifactId\\&gt;spring-boot-starter-test\\&lt;/artifactId\\&gt; \\&lt;scope\\&gt;test\\&lt;/scope\\&gt; \\&lt;/dependency\\&gt; \\&lt;/dependencies\\&gt; \\&lt;build\\&gt; \\&lt;plugins\\&gt; \\&lt;plugin\\&gt; \\&lt;groupId\\&gt;org.springframework.boot\\&lt;/groupId\\&gt; \\&lt;artifactId\\&gt;spring-boot-maven-plugin\\&lt;/artifactId\\&gt; \\&lt;configuration\\&gt; \\&lt;excludes\\&gt; \\&lt;exclude\\&gt; \\&lt;groupId\\&gt;org.projectlombok\\&lt;/groupId\\&gt; \\&lt;artifactId\\&gt;lombok\\&lt;/artifactId\\&gt; \\&lt;/exclude\\&gt; \\&lt;/excludes\\&gt; \\&lt;/configuration\\&gt; \\&lt;/plugin\\&gt; \\&lt;/plugins\\&gt; \\&lt;/build\\&gt; \\&lt;/project\\&gt; 修改配置文件application.yml1234567891011121314151617181920spring: application: name: rocketmq-producer rocketmq: name-server: 127.0.0.1:9876 \\# rocketMq的nameServer地址 producer: group: powernode-group \\# 生产者组别 send-message-timeout: 3000 \\# 消息发送的超时时间 retry-times-when-send-async-failed: 2 \\# 异步消息发送失败重试次数 max-message-size: 4194304 \\# 消息的最大长度 我们在测试类里面测试发送消息往powernode主题里面发送一个简单的字符串消息 12345678910111213141516171819202122232425262728293031323334353637383940/* \\* 注入rocketMQTemplate，我们使用它来操作mq \\*/ @Autowired private RocketMQTemplate rocketMQTemplate; /* \\* 测试发送简单的消息 \\ \\* @throws Exception \\*/ @Test public void testSimpleMsg() throws Exception &#123; // 往powernode的主题里面发送一个简单的字符串消息 SendResult sendResult = rocketMQTemplate.syncSend(\\&quot;powernode\\&quot;, \\&quot;我是一个简单的消息\\&quot;); // 拿到消息的发送状态 System.*out*.println(sendResult.getSendStatus()); // 拿到消息的id System.*out*.println(sendResult.getMsgId()); &#125; 运行后查看控制台 查看rocketMq的控制台 查看消息细节 搭建rocketmq-consumer（消息消费者） 创建项目，完整的pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;?*xml version=\\&quot;1.0\\&quot; encoding=\\&quot;UTF-8\\&quot;*?\\&gt; \\&lt;project xmlns=\\&quot;http://maven.apache.org/POM/4.0.0\\&quot; xmlns:xsi=\\&quot;http://www.w3.org/2001/XMLSchema-instance\\&quot; xsi:schemaLocation=\\&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\\&quot;\\&gt; \\&lt;modelVersion\\&gt;4.0.0\\&lt;/modelVersion\\&gt; \\&lt;parent\\&gt; \\&lt;groupId\\&gt;org.springframework.boot\\&lt;/groupId\\&gt; \\&lt;artifactId\\&gt;spring-boot-starter-parent\\&lt;/artifactId\\&gt; *&lt;version\\&gt;2.6.3\\&lt;/version\\&gt;* \\&lt;relativePath/\\&gt; &lt;!\\-- lookup parent from repository \\--\\&gt; \\&lt;/parent\\&gt; \\&lt;groupId\\&gt;com.powernode\\&lt;/groupId\\&gt; \\&lt;artifactId\\&gt;02-rocketmq-consumer\\&lt;/artifactId\\&gt; \\&lt;version\\&gt;0.0.1-SNAPSHOT\\&lt;/version\\&gt; \\&lt;name\\&gt;rocketmq-consumer\\&lt;/name\\&gt; \\&lt;description\\&gt;Demo project for Spring Boot\\&lt;/description\\&gt; \\&lt;properties\\&gt; \\&lt;java.version\\&gt;1.8\\&lt;/java.version\\&gt; \\&lt;/properties\\&gt; \\&lt;dependencies\\&gt; \\&lt;dependency\\&gt; \\&lt;groupId\\&gt;org.springframework.boot\\&lt;/groupId\\&gt; \\&lt;artifactId\\&gt;spring-boot-starter-web\\&lt;/artifactId\\&gt; \\&lt;/dependency\\&gt; **&lt;!\\-- rocketmq的依赖 \\--\\&gt;** *&lt;dependency\\&gt;* *&lt;groupId\\&gt;org.apache.rocketmq\\&lt;/groupId\\&gt;* *&lt;artifactId\\&gt;rocketmq-spring-boot-starter\\&lt;/artifactId\\&gt;* *&lt;version\\&gt;2.0.2\\&lt;/version\\&gt;* *&lt;/dependency\\&gt;* \\&lt;dependency\\&gt; \\&lt;groupId\\&gt;org.projectlombok\\&lt;/groupId\\&gt; \\&lt;artifactId\\&gt;lombok\\&lt;/artifactId\\&gt; \\&lt;optional\\&gt;true\\&lt;/optional\\&gt; \\&lt;/dependency\\&gt; \\&lt;dependency\\&gt; \\&lt;groupId\\&gt;org.springframework.boot\\&lt;/groupId\\&gt; \\&lt;artifactId\\&gt;spring-boot-starter-test\\&lt;/artifactId\\&gt; \\&lt;scope\\&gt;test\\&lt;/scope\\&gt; \\&lt;/dependency\\&gt; \\&lt;/dependencies\\&gt; \\&lt;build\\&gt; \\&lt;plugins\\&gt; \\&lt;plugin\\&gt; \\&lt;groupId\\&gt;org.springframework.boot\\&lt;/groupId\\&gt; \\&lt;artifactId\\&gt;spring-boot-maven-plugin\\&lt;/artifactId\\&gt; \\&lt;configuration\\&gt; \\&lt;excludes\\&gt; \\&lt;exclude\\&gt; \\&lt;groupId\\&gt;org.projectlombok\\&lt;/groupId\\&gt; \\&lt;artifactId\\&gt;lombok\\&lt;/artifactId\\&gt; \\&lt;/exclude\\&gt; \\&lt;/excludes\\&gt; \\&lt;/configuration\\&gt; \\&lt;/plugin\\&gt; \\&lt;/plugins\\&gt; \\&lt;/build\\&gt; \\&lt;/project\\&gt; 修改配置文件application.yml123456789spring: application: name: rocketmq-consumer rocketmq: name-server: 127.0.0.1:9876 添加一个监听的类SimpleMsgListener123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566消费者要消费消息，就添加一个监听 package com.powernode.listener; import org.apache.rocketmq.spring.annotation.MessageModel; import org.apache.rocketmq.spring.annotation.RocketMQMessageListener; import org.apache.rocketmq.spring.core.RocketMQListener; import org.springframework.stereotype.Component; /* * 创建一个简单消息的监听 * 1.类上添加注解@Component和@RocketMQMessageListener * @RocketMQMessageListener(topic = \\&quot;powernode\\&quot;, consumerGroup = \\&quot;powernode-group\\&quot;) topic指定消费的主题，consumerGroup指定消费组 ,一个主题可以有多个消费者组,一个消息可以被多个不同的组的消费者都消费* 2.实现Rocket MQListener接口，**注意泛型的使用，可以为具体的类型，如果想拿到消息*** *** 的其他参数可以写成MessageExt** */ @Component @RocketMQMessageListener(topic = \\&quot;powernode\\&quot;, consumerGroup = \\&quot;powernode-group\\&quot;,messageModel = MessageModel.*CLUSTERING*) public class SimpleMsgListener implements RocketMQListener\\&lt;String\\&gt; &#123; /* * 消费消息的方法 * * @param message */ @Override public void onMessage(String message) &#123; System.*out*.println(message); &#125; &#125; ​ 启动rocketmq-consumer查看控制台，发现我们已经监听到消息了 RocketMQ发送对象消息和集合消息我们接着在上面项目里面做 发送对象消息主要是监听的时候泛型中写对象的类型即可 修改rocketmq-producer添加一个Order类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 package com.powernode.domain; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import java.util.Date; /* \\* 订单对象 \\*/ @Data @AllArgsConstructor @NoArgsConstructor public class Order &#123; /* \\* 订单号 \\*/ private String orderId; /* \\* 订单名称 \\*/ private String orderName; /* \\* 订单价格 \\*/ private Double price; /* \\* 订单号创建时间 \\*/ private Date createTime; /* \\* 订单描述 \\*/ private String desc; &#125; 修改rocketmq-producer添加一个单元测试12345678910111213141516171819202122232425262728293031/* * 测试发送对象消息 * * @throws Exception */ @Test public void testObjectMsg() throws Exception &#123; Order order = new Order(); order.setOrderId(UUID.*randomUUID*().toString()); order.setOrderName(\\&quot;我的订单\\&quot;); order.setPrice(998D); order.setCreateTime(new Date()); order.setDesc(\\&quot;加急配送\\&quot;); // 往powernode-obj主题发送一个订单对象 rocketMQTemplate.syncSend(\\&quot;powernode-obj\\&quot;, order); &#125; ​ 发送此消息修改rocketmq-consumer也添加一个Order类（拷贝过来）修改rocketmq-consumer添加一个ObjMsgListener1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.powernode.listener; import com.powernode.domain.Order; import org.apache.rocketmq.spring.annotation.RocketMQMessageListener; import org.apache.rocketmq.spring.core.RocketMQListener; import org.springframework.stereotype.Component; /* \\* 创建一个对象消息的监听 \\* 1.类上添加注解@Component和@RocketMQMessageListener \\* 2.实现RocketMQListener接口，注意泛型的使用 \\*/ @Component @RocketMQMessageListener(topic = \\&quot;powernode-obj\\&quot;, consumerGroup = \\&quot;powernode-obj-group\\&quot;) public class ObjMsgListener implements RocketMQListener\\&lt;**Order*&gt; &#123; /* \\* 消费消息的方法 \\ \\* @param message \\*/ @Override public void onMessage(**Order** message) &#123; System.*out*.println(message); &#125; &#125; 重启rocketmq-consumer后查看控制台对象消息已经监听到了 发送集合消息和对象消息同理，创建一个Order的集合，发送出去，监听方注意修改泛型中的类型为Object即可，这里就不做重复演示了 RocketMQ集成SpringBoot发送不同消息模式发送同步消息理解为：消息由消费者发送到broker后，会得到一个确认，是具有可靠性的 这种可靠性同步地发送方式使用的比较广泛，比如：重要的消息通知，短信通知等。 我们在上面的快速入门中演示的消息，就是同步消息，即 rocketMQTemplate.syncSend() rocketMQTemplate.send() rocketMQTemplate.convertAndSend() 这三种发送消息的方法，底层都是调用syncSend，发送的是同步消息 发送异步消息rocketMQTemplate.asyncSend() 修改rocketmq-producer添加一个单元测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* \\* 测试异步发送消息 \\ \\* @throws Exception \\*/ @Test public void testAsyncSend() throws Exception &#123; // 发送异步消息，发送完以后会有一个异步通知 rocketMQTemplate.**asyncSend**(\\&quot;powernode\\&quot;, \\&quot;发送一个异步消息\\&quot;, new SendCallback() &#123; /* \\* 成功的回调 \\* @param sendResult \\*/ @Override public void onSuccess(SendResult sendResult) &#123; System.*out*.println(\\&quot;发送成功\\&quot;); &#125; /* \\* 失败的回调 \\* @param throwable \\*/ @Override public void onException(Throwable throwable) &#123; System.*out*.println(\\&quot;发送失败\\&quot;); &#125; &#125;); // 测试一下异步的效果 System.*out*.println(\\&quot;谁先执行\\&quot;); // 挂起jvm 不让方法结束 System.*in*.read(); &#125; 运行查看控制台效果谁先发送打印在前面 发送单向消息这种方式主要用在不关心发送结果的场景，这种方式吞吐量很大，但是存在消息丢失的风险，例如日志信息的发送 修改rocketmq-producer添加一个单元测试12345678910111213141516171819/* \\* 测试单向消息 \\ \\* @throws Exception \\*/ @Test public void testOnWay() throws Exception &#123; // 发送单向消息，没有返回值和结果 rocketMQTemplate.**sendOneWay**(\\&quot;powernode\\&quot;, \\&quot;这是一个单向消息\\&quot;); &#125; 发送延迟消息修改rocketmq-producer添加一个单元测试123456789101112131415161718192021222324252627/* \\* 测试延迟消息 \\ \\* @throws Exception \\*/ @Test public void testDelay() throws Exception &#123; // 构建消息对象 Message\\&lt;String\\&gt; message = MessageBuilder.*withPayload*(\\&quot;我是一个延迟消息\\&quot;).build(); // 发送一个延时消息，延迟等级为4级，也就是30s后被监听消费 SendResult sendResult = rocketMQTemplate.syncSend(\\&quot;powernode\\&quot;, message, 2000, 4); System.*out*.println(sendResult.getSendStatus()); &#125; 运行后，查看消费者端，过了30s才被消费这里注意的是RocketMQ不支持任意时间的延时 只支持以下几个固定的延时等级，等级1就对应1s，以此类推，最高支持2h延迟 private String messageDelayLevel &#x3D; &quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m8m 9m 10m 20m 30m 1h 2h&quot;; 发送顺序消息修改Order表添加一个顺序字段1234567/* \\* 订单的流程顺序 \\*/ private Integer seq; 修改rocketmq-producer添加一个单元测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* \\* 测试顺序消费 \\* mq会根据hash的值来存放到一个队列里面去 \\ \\* @throws Exception \\*/ @Test public void testOrderly() throws Exception &#123; List\\&lt;Order\\&gt; orders = Arrays.*asList*( new Order(UUID.*randomUUID*().toString().substring(0, 5), \\&quot;张三的下订单\\&quot;, null, null, null, 1), new Order(UUID.*randomUUID*().toString().substring(0, 5), \\&quot;张三的发短信\\&quot;, null, null, null, 1), new Order(UUID.*randomUUID*().toString().substring(0, 5), \\&quot;张三的物流\\&quot;, null, null, null, 1), new Order(UUID.*randomUUID*().toString().substring(0, 5), \\&quot;张三的签收\\&quot;, null, null, null, 1), new Order(UUID.*randomUUID*().toString().substring(0, 5), \\&quot;李四的下订单\\&quot;, null, null, null, 2), new Order(UUID.*randomUUID*().toString().substring(0, 5), \\&quot;李四的发短信\\&quot;, null, null, null, 2), new Order(UUID.*randomUUID*().toString().substring(0, 5), \\&quot;李四的物流\\&quot;, null, null, null, 2), new Order(UUID.*randomUUID*().toString().substring(0, 5), \\&quot;李四的签收\\&quot;, null, null, null, 2) ); // 我们控制流程为 下订单-\\&gt;发短信-\\&gt;物流-\\&gt;签收 hash的值为seq，也就是说 seq相同的会放在同一个队列里面，顺序消费 orders.forEach(order -\\&gt; &#123; rocketMQTemplate.syncSendOrderly(\\&quot;powernode-obj\\&quot;, order, String.*valueOf*(order.getSeq())); &#125;); &#125; 发送消息修改rocketmq-consumer的ObjMsgListener1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 package com.powernode.listener; import com.powernode.domain.Order; import org.apache.rocketmq.spring.annotation.ConsumeMode; import org.apache.rocketmq.spring.annotation.RocketMQMessageListener; import org.apache.rocketmq.spring.core.RocketMQListener; import org.springframework.stereotype.Component; /* \\* @Author 武汉动力节点 \\* 创建一个对象消息的监听 \\* 1.类上添加注解@Component和@RocketMQMessageListener \\* 2.实现RocketMQListener接口，注意泛型的使用 \\* consumeMode 指定消费类型 \\* CONCURRENTLY 并发消费 \\* ORDERLY 顺序消费 messages orderly. one queue, one thread \\*/ @Component @RocketMQMessageListener(topic = \\&quot;powernode-obj\\&quot;, consumerGroup = \\&quot;powernode-obj-group\\&quot;, **consumeMode = ConsumeMode.*ORDERLY** ) public class ObjMsgListener implements RocketMQListener\\&lt;Order\\&gt; &#123; /* \\* 消费消息的方法 \\ \\* @param message \\*/ @Override public void onMessage(Order message) &#123; System.*out*.println(message); &#125; &#125; 重启rocketmq-consumer查看控制台，消息按照我们的放入顺序进行消费了 发送事务消息修改rocketmq-producer添加一个单元测试123456789101112131415161718192021222324252627282930313233343536373839404142/* \\* 测试事务消息 \\* 默认是sync（同步的） \\* 事务消息会有确认和回查机制 \\ 事务 消息都会走到同一个监听回调里面，所以我们需要使用tag或者key来区分过滤 \\ \\* @throws Exception \\*/ @Test public void testTrans() throws Exception &#123; // 构建消息体 Message\\&lt;String\\&gt; message = MessageBuilder.*withPayload*(\\&quot;这是一个事务消息\\&quot;).build(); // 发送事务消息（同步的） 最后一个参数才是消息主题 TransactionSendResult transaction = rocketMQTemplate.sendMessageInTransaction(\\&quot;powernode\\&quot;, message, \\&quot;消息的参数\\&quot;); // 拿到本地事务状态 System.*out*.println(transaction.getLocalTransactionState()); // 挂起jvm，因为事务的回查需要一些时间 System.*in*.read(); &#125; 修改rocketmq-producer添加一个本地事务消息的监听（半消息）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/* * 事务消息的监听与回查 * 类上添加注解@RocketMQTransactionListener 表示这个类是本地事务消息的监听类 * 实现RocketMQLocalTransactionListener接口 * 两个方法为执行本地事务，与回查本地事务 */ @Component @RocketMQTransactionListener(corePoolSize = 4,maximumPoolSize = 8) public class TmMsgListener implements RocketMQLocalTransactionListener &#123; /* * 执行本地事务，这里可以执行一些业务 * 比如操作数据库，操作成功就return RocketMQLocalTransactionState.COMMIT; * 可以使用try catch来控制成功或者失败; * @param msg * @param arg * @return */ @Override public RocketMQLocalTransactionState executeLocalTransaction(Message msg, Object arg) &#123; // 拿到消息参数 System.*out*.println(arg); // 拿到消息头 System.*out*.println(msg.getHeaders()); // 返回状态COMMIT,UNKNOWN return RocketMQLocalTransactionState.*UNKNOWN*; &#125; /* * 回查本地事务，只有上面的执行方法返回UNKNOWN时，才执行下面的方法 默认是1min回查 * 此方法为回查方法，执行需要等待一会 * xxx.isSuccess() 这里可以执行一些检查的方法 如果返回COMMIT，那么本地事务就算是提交成功了，消息就会被消费者看到 * * @param msg * @return */ @Override public RocketMQLocalTransactionState checkLocalTransaction(Message msg) &#123; System.*out*.println(msg); return RocketMQLocalTransactionState.*COMMIT*; &#125; &#125; 测试发送事务，建议断点启动 消息会先到事务监听类的执行方法， 如果返回状态为COMMIT，则消费者可以直接监听到 如果返回状态为ROLLBACK，则消息发送失败，直接回滚 如果返回状态为UNKNOW，则过一会会走回查方法 如果回查方法返回状态为UNKNOW或者ROLLBACK，则消息发送失败，直接回滚 如果回查方法返回状态为COMMIT，则消费者可以直接监听到 RocketMQ集成SpringBoot的消息过滤tag过滤（常在消费者端过滤）我们从源码注释得知，tag带在主题后面用：来携带，感谢注释 我们往下去看源码，在 org.apache.rocketmq.spring.support.RocketMQUtil的getAndWrapMessage方法里面看到了具体细节，我们也知道了keys在消息头里面携带 修改rocketmq-producer添加一个单元测试123456789101112131415161718192021/* \\* 发送一个带tag的消息 \\ \\* @throws Exception \\*/ @Test public void testTagMsg() throws Exception &#123; // 发送一个tag为java的数据 rocketMQTemplate.syncSend(\\&quot;powernode-tag:java\\&quot;, \\&quot;我是一个带tag的消息\\&quot;); &#125; 发送消息修改rocketmq-consumer添加一个TagMsgListener1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 package com.powernode.listener; import org.apache.rocketmq.spring.annotation.RocketMQMessageListener; import org.apache.rocketmq.spring.annotation.SelectorType; import org.apache.rocketmq.spring.core.RocketMQListener; import org.springframework.stereotype.Component; /* \\* @Author 武汉动力节点 \\* 创建一个简单的标签消息的监听 \\* 1.类上添加注解@Component和@RocketMQMessageListener \\* selectorType = SelectorType.TAG, 指定使用tag过滤。(也可以使用sql92 需要在配置文件broker.conf中开启enbalePropertyFilter=true) \\* selectorExpression = \\&quot;java\\&quot; 表达式，默认是\\*,支持\\&quot;tag1 \\\\ tag2 \\\\ tag3\\&quot; \\* 2.实现RocketMQListener接口，注意泛型的使用 \\*/ @Component @RocketMQMessageListener(topic = \\&quot;powernode-tag\\&quot;, consumerGroup = \\&quot;powernode-tag-group\\&quot;, selectorType = SelectorType.*TAG*, selectorExpression = \\&quot;java\\&quot; ) public class TagMsgListener implements RocketMQListener\\&lt;String\\&gt; &#123; /* \\* 消费消息的方法 \\ \\* @param message \\*/ @Override public void onMessage(String message) &#123; System.*out*.println(message); &#125; &#125; 重启rocketmq-consumer查看控制台 Key过滤（可以在事务监听的类里面区分）修改rocketmq-producer添加一个单元测试12345678910111213141516171819202122232425262728/* \\* 发送一个带key的消息,我们使用事务消息 打断点查看消息头 \\ \\* @throws Exception \\*/ @Test public void testKeyMsg() throws Exception &#123; // 发送一个key为spring的事务消息 Message\\&lt;String\\&gt; message = MessageBuilder.*withPayload*(\\&quot;我是一个带key的消息\\&quot;) **.setHeader(RocketMQHeaders.*KEYS*, \\&quot;spring\\&quot;)* .build(); rocketMQTemplate.sendMessageInTransaction(\\&quot;powernode\\&quot;, message, \\&quot;我是一个带key的消息\\&quot;); &#125; 断点发送这个消息，查看事务里面消息头 我们在mq的控制台也可以看到 RocketMQ集成SpringBoot消息消费两种模式Rocketmq消息消费的模式分为两种：负载均衡模式和广播模式 负载均衡模式表示多个消费者交替消费同一个主题里面的消息 广播模式表示每个每个消费者都消费一遍订阅的主题的消息 再搭建一个消费者rocketmq-consumer-b，依赖和配置文件和rocketmq-consumer一致，记住端口修改一下，避免占用rocketmq-consumer-b添加一个监听12345678910111213141516171819202122232425262728293031323334353637383940414243 package com.powernode.listener; import org.apache.rocketmq.spring.annotation.MessageModel; import org.apache.rocketmq.spring.annotation.RocketMQMessageListener; import org.apache.rocketmq.spring.core.RocketMQListener; import org.springframework.stereotype.Component; /* \\* messageModel 指定消息消费的模式 \\* CLUSTERING 为负载均衡模式 \\* BROADCASTING 为广播模式 \\*/ @Component @RocketMQMessageListener(topic = \\&quot;powernode\\&quot;, consumerGroup = \\&quot;powernode-group\\&quot;, **messageModel = MessageModel.*CLUSTERING** ) public class ConsumerBListener implements RocketMQListener\\&lt;String\\&gt; &#123; @Override public void onMessage(String message) &#123; System.*out*.println(message); &#125; &#125; 修改rocketmq-consumer的SimpleMsgListener1234567891011121314151617181920212223242526272829303132333435363738394041/* * 创建一个简单消息的监听 * 1.类上添加注解@Component和@RocketMQMessageListener * * @RocketMQMessageListener(topic = \\&quot;powernode\\&quot;, consumerGroup = \\&quot;powernode-group\\&quot;) topic指定消费的主题，consumerGroup指定消费组 ,一个主题可以有多个消费者组,一个消息可以被多个不同的组的消费者都消费* * 2.实现RocketMQListener接口，注意泛型的使用 */ @Component @RocketMQMessageListener(topic = \\&quot;powernode\\&quot;, consumerGroup = \\&quot;powernode-group\\&quot;, **messageModel = MessageModel.*CLUSTERING***) public class SimpleMsgListener implements RocketMQListener\\&lt;String\\&gt; &#123; @Override public void onMessage(String message) &#123; System.*out*.println(new Date()); System.*out*.println(message); &#125; &#125; 启动两个消费者在生产者里面添加一个单元测试并且运行12345678910111213141516171819202122/* \\* 测试消息消费的模式 \\ \\* @throws Exception \\*/ @Test public void testMsgModel() throws Exception &#123; for (int i = 0; i \\&lt; 10; i++) &#123; rocketMQTemplate.syncSend(\\&quot;powernode\\&quot;, \\&quot;我是消息\\&quot; + i); &#125; &#125; 查看两个消费者的控制台，发现是负载均衡的模式 修改两个消费者的模式为BROADCASTING重启测试，结果是广播模式，每个消费者都消费了这些消息 项目中 一般部署多态机器 消费者 2 - 3 根据业务可以选择具体的模式来配置 重置消费点位, 将一个组的消费节点 设置在之前的某一个时间点上去从这个时间点开始往后消费 跳过堆积 选择一个组 跳过堆积以后 这个组里面的的所有都不会被消费了 如何解决消息堆积问题？一般认为单条队列消息差值&gt;&#x3D;10w时 算堆积问题 什么情况下会出现堆积 生产太快了 生产方可以做业务限流 增加消费者数量,但是消费者数量&lt;&#x3D;队列数量,适当的设置最大的消费线程数量(根据IO(2n)&#x2F;CPU(n+1)) 动态扩容队列数量,从而增加消费者数量 消费者消费出现问题 排查消费者程序的问题 如何确保消息不丢失？ 生产者使用同步发送模式 ，收到mq的返回确认以后顺便往自己的数据库里面写 msgId status(0) time 消费者消费以后 修改数据这条消息的状态 &#x3D; 1 写一个定时任务 间隔两天去查询数据 如果有status &#x3D; 0 and time &lt; day-2 将mq的刷盘机制设置为同步刷盘 使用集群模式 ，搞主备模式，将消息持久化在不同的硬件上 可以开启mq的trace机制，消息跟踪机制 1.在broker.conf中开启消息追踪 traceTopicEnable&#x3D;true 2.重启broker即可 3.生产者配置文件开启消息轨迹 enable-msg-trace: true 1&lt;!-- --&gt; 消费者开启消息轨迹功能，可以给单独的某一个消费者开启 enableMsgTrace &#x3D; true 在rocketmq的面板中可以查看消息轨迹 默认会将消息轨迹的数据存在 RMQ_SYS_TRACE_TOPIC 主题里面 安全 开启acl的控制 在broker.conf中开启aclEnable&#x3D;true 配置账号密码 修改plain_acl.yml 修改控制面板的配置文件 放开52&#x2F;53行 把49行改为true上传到服务器的jar包平级目录下即可","categories":[{"name":"mq","slug":"mq","permalink":"http://example.com/mq/"}],"tags":[{"name":"mq","slug":"mq","permalink":"http://example.com/tags/mq/"}]},{"title":"RocketMq（四）--消息发送","slug":"mq/RocketMq/RocketMq（四）-消息发送","date":"2023-06-19T02:19:02.000Z","updated":"2023-06-19T02:34:16.798Z","comments":true,"path":"2023/06/19/mq/RocketMq/RocketMq（四）-消息发送/","link":"","permalink":"http://example.com/2023/06/19/mq/RocketMq/RocketMq%EF%BC%88%E5%9B%9B%EF%BC%89-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/","excerpt":"","text":"消费模式MQ的消费模式可以大致分为两种，一种是推Push，一种是拉Pull。 Push是服务端【MQ】主动推送消息给客户端，优点是及时性较好，但如果客户端没有做好流控，一旦服务端推送大量消息到客户端时，就会导致客户端消息堆积甚至崩溃。 Pull是客户端需要主动到服务端取数据，优点是客户端可以依据自己的消费能力进行消费，但拉取的频率也需要用户自己控制，拉取频繁容易造成服务端和客户端的压力，拉取间隔长又容易造成消费不及时。 Push模式也是基于pull模式的，只能客户端内部封装了api，一般场景下，上游消息生产量小或者均速的时候，选择push模式。在特殊场景下，例如电商大促，抢优惠券等场景可以选择pull模式 RocketMQ发送同步消息上面的快速入门就是发送同步消息，发送过后会有一个返回值，也就是mq服务器接收到消息后返回的一个确认，这种方式非常安全，但是性能上并没有这么高，而且在mq集群中，也是要等到所有的从机都复制了消息以后才会返回，所以针对重要的消息可以选择这种方式 RocketMQ发送异步消息异步消息通常用在对响应时间敏感的业务场景，即发送端不能容忍长时间地等待Broker的响应。发送完以后会有一个异步消息通知 异步消息生产者1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 @Test public void testAsyncProducer() throws Exception &#123; // 创建默认的生产者* DefaultMQProducer producer = new DefaultMQProducer(//&quot;test-group//&quot;); // 设置nameServer地址* producer.setNamesrvAddr(//&quot;localhost:9876//&quot;); // 启动实例* producer.start(); Message msg = new Message(//&quot;TopicTest//&quot;, (//&quot;异步消息//&quot;).getBytes()); producer.send(msg, new SendCallback() &#123; @Override public void onSuccess(SendResult sendResult) &#123; System.out.println(//&quot;发送成功//&quot;); &#125; //@Override public void onException(Throwable e) &#123; System.*out*.println(//&quot;发送失败//&quot;); &#125; &#125;); System.*out*.println(//&quot;看看谁先执行//&quot;); // 挂起jvm 因为回调是异步的不然测试不出来* System.*in*.read(); // 关闭实例* producer.shutdown(); &#125; 异步消息消费者12345678910111213141516171819202122232425262728293031323334353637383940414243444546//@Test public void testAsyncConsumer() throws Exception &#123; // 创建默认消费者组* DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(//&quot;consumer-group//&quot;); // 设置nameServer地址* consumer.setNamesrvAddr(//&quot;localhost:9876//&quot;); // 订阅一个主题来消费//*表示没有过滤参数 表示这个主题的任何消息* consumer.subscribe(//&quot;TopicTest//&quot;,//&quot;//*//&quot;); // 注册一个消费监听 MessageListenerConcurrently是并发消费* // 默认是20个线程一起消费，可以参看 consumer.setConsumeThreadMax()* consumer.registerMessageListener(new MessageListenerConcurrently() &#123; //@Override public ConsumeConcurrentlyStatus consumeMessage(List//&lt;MessageExt//&gt; msgs, ConsumeConcurrentlyContext context) &#123; // 这里执行消费的代码 默认是多线程消费* System.*out*.println(Thread.*currentThread*().getName() + //&quot;//-//-//--//&quot; + msgs); return ConsumeConcurrentlyStatus.*CONSUME_SUCCESS*; &#125; &#125;); consumer.start(); System.*in*.read(); &#125; ​ RocketMQ发送单向消息这种方式主要用在不关心发送结果的场景，这种方式吞吐量很大，但是存在消息丢失的风险，例如日志信息的发送 单向消息生产者123456789101112131415161718192021222324252627//@Test public void testOnewayProducer() throws Exception &#123; // 创建默认的生产者* DefaultMQProducer producer = new DefaultMQProducer(//&quot;test-group//&quot;); // 设置nameServer地址* producer.setNamesrvAddr(//&quot;localhost:9876//&quot;); // 启动实例* producer.start(); Message msg = new Message(//&quot;TopicTest//&quot;, (//&quot;单向消息//&quot;).getBytes()); // 发送单向消息* producer.sendOneway(msg); // 关闭实例* producer.shutdown(); &#125; ​ 单向消息消费者消费者和上面一样 RocketMQ发送延迟消息消息放入mq后，过一段时间，才会被监听到，然后消费 比如下订单业务，提交了一个订单就可以发送一个延时消息，30min后去检查这个订单的状态，如果还是未付款就取消订单释放库存。 延迟消息生产者123456789101112131415161718192021222324252627282930313233343536373839//@Test public void testDelayProducer() throws Exception &#123; // 创建默认的生产者* DefaultMQProducer producer = new DefaultMQProducer(//&quot;test-group//&quot;); // 设置nameServer地址* producer.setNamesrvAddr(//&quot;localhost:9876//&quot;); // 启动实例* producer.start(); Message msg = new Message(//&quot;TopicTest//&quot;, (//&quot;延迟消息//&quot;).getBytes()); // 给这个消息设定一个延迟等级* // messageDelayLevel =//&quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h* msg.setDelayTimeLevel(3); // 发送单向消息* producer.send(msg); // 打印时间* System.*out*.println(new Date()); // 关闭实例* producer.shutdown(); &#125; 延迟消息消费者消费者和上面一样 这里注意的是RocketMQ不支持任意时间的延时 只支持以下几个固定的延时等级，等级1就对应1s，以此类推，最高支持2h延迟 private String messageDelayLevel &#x3D;&#x2F;&#x2F;“1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m8m 9m 10m 20m 30m 1h 2h&#x2F;&#x2F;“; RocketMQ发送顺序消息消息有序指的是可以按照消息的发送顺序来消费(FIFO)。RocketMQ可以严格的保证消息有序，可以分为：分区有序或者全局有序。 可能大家会有疑问，mq不就是FIFO吗？ rocketMq的broker的机制，导致了rocketMq会有这个问题 因为一个broker中对应了四个queue 顺序消费的原理解析，在默认的情况下消息发送会采取RoundRobin轮询方式把消息发送到不同的queue(分区队列)；而消费消息的时候从多个queue上拉取消息，这种情况发送和消费是不能保证顺序。但是如果控制发送的顺序消息只依次发送到同一个queue中，消费的时候只从这个queue上依次拉取，则就保证了顺序。当发送和消费参与的queue只有一个，则是全局有序；如果多个queue参与，则为分区有序，即相对每个queue，消息都是有序的。 下面用订单进行分区有序的示例。一个订单的顺序流程是：下订单、发短信通知、物流、签收。订单顺序号相同的消息会被先后发送到同一个队列中，消费时，同一个顺序获取到的肯定是同一个队列。 场景分析模拟一个订单的发送流程，创建两个订单，发送的消息分别是 订单号111 消息流程 下订单-&#x2F;&#x2F;&gt;物流-&#x2F;&#x2F;&gt;签收 订单号112 消息流程 下订单-&#x2F;&#x2F;&gt;物流-&#x2F;&#x2F;&gt;拒收 创建一个订单对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//@Data //@AllArgsConstructor //@NoArgsConstructor public class Order &#123; *///*// *//* 订单id* *//*/* private Integer orderId; *///*// *//* 订单编号* *//*/* private Integer orderNumber; *///*// *//* 订单价格* *//*/* private Double price; *///*// *//* 订单号创建时间* *//*/* private Date createTime; *///*// *//* 订单描述* *//*/* private String desc; &#125; 顺序消息生产者123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//@Test public void testOrderlyProducer() throws Exception &#123; // 创建默认的生产者* DefaultMQProducer producer = new DefaultMQProducer(//&quot;test-group//&quot;); // 设置nameServer地址* producer.setNamesrvAddr(//&quot;localhost:9876//&quot;); // 启动实例* producer.start(); List//&lt;Order//&gt; orderList = Arrays.*asList*( new Order(1, 111, 59D, new Date(),//&quot;下订单//&quot;), new Order(2, 111, 59D, new Date(),//&quot;物流//&quot;), new Order(3, 111, 59D, new Date(),//&quot;签收//&quot;), new Order(4, 112, 89D, new Date(),//&quot;下订单//&quot;), new Order(5, 112, 89D, new Date(),//&quot;物流//&quot;), new Order(6, 112, 89D, new Date(),//&quot;拒收//&quot;) ); // 循环集合开始发送* orderList.forEach(order -//&gt; &#123; Message message = new Message(//&quot;TopicTest//&quot;, order.toString().getBytes()); try &#123; // 发送的时候 相同的订单号选择同一个队列* producer.send(message, new MessageQueueSelector() &#123; //@Override public MessageQueue select(List//&lt;MessageQueue//&gt; mqs, Message msg, Object arg) &#123; // 当前主题有多少个队列* int queueNumber = mqs.size(); // 这个arg就是后面传入的 order.getOrderNumber()* Integer i = (Integer) arg; // 用这个值去%队列的个数得到一个队列* int index = i % queueNumber; // 返回选择的这个队列即可 ，那么相同的订单号 就会被放在相同的队列里 实现FIFO了* return mqs.get(index); &#125; &#125;, order.getOrderNumber()); &#125; catch (Exception e) &#123; System.*out*.println(//&quot;发送异常//&quot;); &#125; &#125;); // 关闭实例* producer.shutdown(); &#125; ​ 顺序消息消费者，测试时一会即可有延迟123456789101112131415161718192021222324252627282930313233343536373839404142//@Test public void testOrderlyConsumer() throws Exception &#123; // 创建默认消费者组* DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(//&quot;consumer-group//&quot;); // 设置nameServer地址* consumer.setNamesrvAddr(//&quot;localhost:9876//&quot;); // 订阅一个主题来消费//*表示没有过滤参数 表示这个主题的任何消息* consumer.subscribe(//&quot;TopicTest//&quot;,//&quot;//*//&quot;); // 注册一个消费监听 MessageListenerOrderly 是顺序消费 单线程消费* consumer.registerMessageListener(**new MessageListenerOrderly()&#123; //@Override public ConsumeOrderlyStatus consumeMessage(List//&lt;MessageExt//&gt; msgs, ConsumeOrderlyContext context) &#123; MessageExt messageExt = msgs.get(0); System.*out*.println(new String(messageExt.getBody())); return ConsumeOrderlyStatus.*SUCCESS*; &#125; &#125;); consumer.start(); System.*in*.read(); &#125; RocketMQ发送批量消息Rocketmq可以一次性发送一组消息，那么这一组消息会被当做一个消息消费 批量消息生产者123456789101112131415161718192021222324252627282930313233343536//@Test public void testBatchProducer() throws Exception &#123; // 创建默认的生产者* DefaultMQProducer producer = new DefaultMQProducer(//&quot;test-group//&quot;); // 设置nameServer地址* producer.setNamesrvAddr(//&quot;localhost:9876//&quot;); // 启动实例* producer.start(); List//&lt;Message//&gt; msgs = Arrays.*asList*( new Message(//&quot;TopicTest//&quot;,//&quot;我是一组消息的A消息//&quot;.getBytes()), new Message(//&quot;TopicTest//&quot;,//&quot;我是一组消息的B消息//&quot;.getBytes()), new Message(//&quot;TopicTest//&quot;,//&quot;我是一组消息的C消息//&quot;.getBytes()) ); SendResult send = producer.send(msgs); System.*out*.println(send); // 关闭实例* producer.shutdown(); &#125; 批量消息消费者12345678910111213141516171819202122232425262728293031323334353637383940414243444546//@Test public void testBatchConsumer() throws Exception &#123; // 创建默认消费者组* DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(//&quot;consumer-group//&quot;); // 设置nameServer地址* consumer.setNamesrvAddr(//&quot;localhost:9876//&quot;); // 订阅一个主题来消费 表达式，默认是// consumer.subscribe(//&quot;TopicTest//&quot;,//&quot;//*//&quot;); // 注册一个消费监听 MessageListenerConcurrently是并发消费* // 默认是20个线程一起消费，可以参看 consumer.setConsumeThreadMax()* consumer.registerMessageListener(new MessageListenerConcurrently() &#123; //@Override public ConsumeConcurrentlyStatus consumeMessage(List//&lt;MessageExt//&gt; msgs, ConsumeConcurrentlyContext context) &#123; // 这里执行消费的代码 默认是多线程消费* System.*out*.println(Thread.*currentThread*().getName() + //&quot;//-//-//--//&quot; + new String(msgs.get(0).getBody())); return ConsumeConcurrentlyStatus.*CONSUME_SUCCESS*; &#125; &#125;); consumer.start(); System.*in*.read(); &#125; RocketMQ发送事务消息事务消息的发送流程它可以被认为是一个两阶段的提交消息实现，以确保分布式系统的最终一致性。事务性消息确保本地事务的执行和消息的发送可以原子地执行。 上图说明了事务消息的大致方案，其中分为两个流程：正常事务消息的发送及提交、事务消息的补偿流程。 事务消息发送及提交 发送消息（half消息）。 服务端响应消息写入结果。 根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）。 根据本地事务状态执行Commit或Rollback（Commit操作生成消息索引，消息对消费者可见） 事务补偿 对没有Commit&#x2F;Rollback的事务消息（pending状态的消息），从服务端发起一次”回查” Producer收到回查消息，检查回查消息对应的本地事务的状态 根据本地事务状态，重新Commit或者Rollback 其中，补偿阶段用于解决消息UNKNOW或者Rollback发生超时或者失败的情况。 事务消息状态 事务消息共有三种状态，提交状态、回滚状态、中间状态： TransactionStatus.CommitTransaction:提交事务，它允许消费者消费此消息。 TransactionStatus.RollbackTransaction:回滚事务，它代表该消息将被删除，不允许被消费。 TransactionStatus.Unknown:中间状态，它代表需要检查消息队列来确定状态。 事务消息生产者123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109 *///*// *//* TransactionalMessageCheckService的检测频率默认1分钟，可通过在broker. conf文件中设置transactionCheckInterval的值来改变默认值，单位为毫秒。* *//* 从broker配置文件中获取transactionTimeOut参数值。* *//* 从broker配置文件中获取transactionCheckMax参数值，表示 事务的最大检测次数，如果超过检测次数，消息会默认为丢弃，即回滚消息。* *// *//*//@throws Exception* *//*/* //@Test public void testTransactionProducer() throws Exception &#123; // 创建一个事务消息生产者* TransactionMQProducer producer = new TransactionMQProducer(//&quot;test-group//&quot;); producer.setNamesrvAddr(//&quot;localhost:9876//&quot;); // 设置事务消息监听器* producer.setTransactionListener(new TransactionListener() &#123; // 这个是执行本地业务方法* //@Override public LocalTransactionState executeLocalTransaction(Message msg, Object arg) &#123; System.*out*.println(new Date()); System.*out*.println(new String(msg.getBody())); // 这个可以使用try catch对业务代码进行性包裹* // COMMIT_MESSAGE 表示允许消费者消费该消息* // ROLLBACK_MESSAGE 表示该消息将被删除，不允许消费* // UNKNOW表示需要MQ回查才能确定状态 那么过一会 代码会走下面的checkLocalTransaction(msg)方法* return LocalTransactionState.*UNKNOW*; &#125; // 这里是回查方法 回查不是再次执行业务操作，而是确认上面的操作是否有结果* // 默认是1min回查 默认回查15次 超过次数则丢弃打印日志 可以通过参数设置* // transactionTimeOut 超时时间* // transactionCheckMax 最大回查次数* // transactionCheckInterval 回查间隔时间单位毫秒* // 触发条件* // 1.当上面执行本地事务返回结果UNKNOW时,或者下面的回查方法也返回UNKNOW时 会触发回查* // 2.当 上面操作超过20s没有做出一个结果，也就是超时或者卡主了，也会进行回查* //@Override public LocalTransactionState checkLocalTransaction(MessageExt msg) &#123; System.*err*.println(new Date()); System.*err*.println(new String(msg.getBody())); // 这里* return LocalTransactionState.*UNKNOW*; &#125; &#125;); producer.start(); Message message = new Message(//&quot;TopicTest2//&quot;, //&quot;我是一个事务消息//&quot;.getBytes()); // 发送消息* producer.sendMessageInTransaction(message, null); System.*out*.println(new Date()); System.*in*.read(); &#125; 事务消息消费者1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//@Test public void testTransactionConsumer() throws Exception &#123; // 创建默认消费者组* DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(//&quot;consumer-group//&quot;); // 设置nameServer地址* consumer.setNamesrvAddr(//&quot;localhost:9876//&quot;); // 订阅一个主题来消费//*表示没有过滤参数 表示这个主题的任何消息* consumer.subscribe(//&quot;TopicTest2//&quot;,//&quot;//*//&quot;); // 注册一个消费监听 MessageListenerConcurrently是并发消费* // 默认是20个线程一起消费，可以参看 consumer.setConsumeThreadMax()* consumer.registerMessageListener(new MessageListenerConcurrently() &#123; //@Override public ConsumeConcurrentlyStatus consumeMessage(List//&lt;MessageExt//&gt; msgs, ConsumeConcurrentlyContext context) &#123; // 这里执行消费的代码 默认是多线程消费* System.*out*.println(Thread.*currentThread*().getName() + //&quot;//-//-//--//&quot; + new String(msgs.get(0).getBody())); return ConsumeConcurrentlyStatus.*CONSUME_SUCCESS*; &#125; &#125;); consumer.start(); System.*in*.read(); &#125; 测试结果 RocketMQ发送带标签的消息，消息过滤Rocketmq提供消息过滤功能，通过tag或者key进行区分 我们往一个主题里面发送消息的时候，根据业务逻辑，可能需要区分，比如带有tagA标签的被A消费，带有tagB标签的被B消费，还有在事务监听的类里面，只要是事务消息都要走同一个监听，我们也需要通过过滤才区别对待 标签消息生产者12345678910111213141516171819202122232425262728//@Test public void testTagProducer() throws Exception &#123; // 创建默认的生产者* DefaultMQProducer producer = new DefaultMQProducer(//&quot;test-group//&quot;); // 设置nameServer地址* producer.setNamesrvAddr(//&quot;localhost:9876//&quot;); // 启动实例* producer.start(); Message msg = new Message(//&quot;TopicTest//&quot;,**//&quot;tagA//&quot;**, //&quot;我是一个带标记的消息//&quot;.getBytes()); SendResult send = producer.send(msg); System.*out*.println(send); // 关闭实例* producer.shutdown(); &#125; 标签消息消费者12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//@Test public void testTagConsumer() throws Exception &#123; // 创建默认消费者组* DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(//&quot;consumer-group//&quot;); // 设置nameServer地址* consumer.setNamesrvAddr(//&quot;localhost:9876//&quot;); // 订阅一个主题来消费 表达式，默认是//*,支持//&quot;tagA//// tagB//// tagC//&quot; 这样或者的写法 只要是符合任何一个标签都可以消费* consumer.subscribe(//&quot;TopicTest//&quot;,//&quot;tagA//// tagB//// tagC//&quot;); // 注册一个消费监听 MessageListenerConcurrently是并发消费* // 默认是20个线程一起消费，可以参看 consumer.setConsumeThreadMax()* consumer.registerMessageListener(new MessageListenerConcurrently() &#123; //@Override public ConsumeConcurrentlyStatus consumeMessage(List//&lt;MessageExt//&gt; msgs, ConsumeConcurrentlyContext context) &#123; // 这里执行消费的代码 默认是多线程消费* System.*out*.println(Thread.*currentThread*().getName() + //&quot;//-//-//--//&quot; + new String(msgs.get(0).getBody())); System.*out*.println(msgs.get(0).getTags()); return ConsumeConcurrentlyStatus.*CONSUME_SUCCESS*; &#125; &#125;); consumer.start(); System.*in*.read(); &#125; 什么时候该用 Topic，什么时候该用 Tag？总结：不同的业务应该使用不同的Topic如果是相同的业务里面有不同表的表现形式，那么我们要使用tag进行区分 可以从以下几个方面进行判断： 1.消息类型是否一致：如普通消息、事务消息、定时（延时）消息、顺序消息，不同的消息类型使用不同的Topic，无法通过 Tag 进行区分。 2.业务是否相关联：没有直接关联的消息，如淘宝交易消息，京东物流消息使用不同的Topic进行区分；而同样是天猫交易消息，电器类订单、女装类订单、化妆品类订单的消息可以用Tag 进行区分。 3.消息优先级是否一致：如同样是物流消息，盒马必须小时内送达，天猫超市 24小时内送达，淘宝物流则相对会慢一些，不同优先级的消息用不同的 Topic进行区分。 4.消息量级是否相当：有些业务消息虽然量小但是实时性要求高，如果跟某些万亿量级的消息使用同一个Topic，则有可能会因为过长的等待时间而”饿死”，此时需要将不同量级的消息进行拆分，使用不同的Topic。 总的来说，针对消息分类，您可以选择创建多个 Topic，或者在同一个 Topic下创建多个 Tag。但通常情况下，不同的 Topic 之间的消息没有必然的联系，而Tag 则用来区分同一个 Topic下相互关联的消息，例如全集和子集的关系、流程先后的关系。 RocketMQ中消息的Key在rocketmq中的消息，默认会有一个messageId当做消息的唯一标识，我们也可以给消息携带一个key，用作唯一标识或者业务标识，包括在控制面板查询的时候也可以使用messageId或者key来进行查询 带key消息生产者12345678910111213141516171819202122232425262728//@Test public void testKeyProducer() throws Exception &#123; // 创建默认的生产者* DefaultMQProducer producer = new DefaultMQProducer(//&quot;test-group//&quot;); // 设置nameServer地址* producer.setNamesrvAddr(//&quot;localhost:9876//&quot;); // 启动实例* producer.start(); Message msg = new Message(//&quot;TopicTest//&quot;,//&quot;tagA//&quot;,**//&quot;key//&quot;**, //&quot;我是一个带标记和key的消息//&quot;.getBytes()); SendResult send = producer.send(msg); System.*out*.println(send); // 关闭实例* producer.shutdown(); &#125; 带key消息消费者123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//@Test public void testKeyConsumer() throws Exception &#123; // 创建默认消费者组* DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(//&quot;consumer-group//&quot;); // 设置nameServer地址* consumer.setNamesrvAddr(//&quot;localhost:9876//&quot;); // 订阅一个主题来消费 表达式，默认是//*,支持//&quot;tagA//// tagB//// tagC//&quot; 这样或者的写法 只要是符合任何一个标签都可以消费* consumer.subscribe(//&quot;TopicTest//&quot;,//&quot;tagA//// tagB//// tagC//&quot;); // 注册一个消费监听 MessageListenerConcurrently是并发消费* // 默认是20个线程一起消费，可以参看 consumer.setConsumeThreadMax()* consumer.registerMessageListener(new MessageListenerConcurrently() &#123; //@Override public ConsumeConcurrentlyStatus consumeMessage(List//&lt;MessageExt//&gt; msgs, ConsumeConcurrentlyContext context) &#123; // 这里执行消费的代码 默认是多线程消费* System.*out*.println(Thread.*currentThread*().getName() + //&quot;//-//-//--//&quot; + new String(msgs.get(0).getBody())); System.*out*.println(msgs.get(0).getTags()); System.*out*.println(msgs.get(0).getKeys()); return ConsumeConcurrentlyStatus.*CONSUME_SUCCESS*; &#125; &#125;); consumer.start(); System.*in*.read(); &#125; RocketMQ重试机制生产者重试1234567// 失败的情况重发3次producer.setRetryTimesWhenSendFailed(3);// 消息在1S内没有发送成功，就会重试producer.send(msg, 1000); 消费者重试在消费者放returnConsumeConcurrentlyStatus.RECONSUME_LATER;后就会执行重试 上图代码中说明了，我们再实际生产过程中，一般重试3-5次，如果还没有消费成功，则可以把消息签收了，通知人工等处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 *///*// *//* 测试消费者* *// *//*//@throws Exception* *//*/* //@Test public void testConsumer() throws Exception &#123; // 创建默认消费者组* DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(//&quot;consumer-group//&quot;); // 设置nameServer地址* consumer.setNamesrvAddr(//&quot;localhost:9876//&quot;); // 订阅一个主题来消费//*表示没有过滤参数 表示这个主题的任何消息* consumer.subscribe(//&quot;TopicTest//&quot;,//&quot;//*//&quot;); // 注册一个消费监听* consumer.registerMessageListener(new MessageListenerConcurrently() &#123; //@Override public ConsumeConcurrentlyStatus consumeMessage(List//&lt;MessageExt//&gt; msgs, ConsumeConcurrentlyContext context) &#123; try &#123; // 这里执行消费的代码* System.*out*.println(Thread.*currentThread*().getName() + //&quot;//-//-//--//&quot; + msgs); // 这里制造一个错误* int i = 10 / 0; &#125; catch (Exception e) &#123; // 出现问题 判断重试的次数* MessageExt messageExt = msgs.get(0); // 获取重试的次数 失败一次消息中的失败次数会累加一次* int reconsumeTimes = messageExt.getReconsumeTimes(); if (reconsumeTimes//&gt;= 3) &#123; // 则把消息确认了，可以将这条消息记录到日志或者数据库 通知人工处理* return ConsumeConcurrentlyStatus.*CONSUME_SUCCESS*; &#125; else &#123; return ConsumeConcurrentlyStatus.*RECONSUME_LATER*; &#125; &#125; return ConsumeConcurrentlyStatus.*CONSUME_SUCCESS*; &#125; &#125;); consumer.start(); System.*in*.read(); &#125; RocketMQ死信消息当消费重试到达阈值以后，消息不会被投递给消费者了，而是进入了死信队列 当一条消息初次消费失败，RocketMQ会自动进行消息重试，达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息。此时，该消息不会立刻被丢弃，而是将其发送到该消费者对应的特殊队列中，这类消息称为死信消息（Dead-LetterMessage），存储死信消息的特殊队列称为死信队列（Dead-LetterQueue），死信队列是死信Topic下分区数唯一的单独队列。如果产生了死信消息，那对应的ConsumerGroup的死信Topic名称为%DLQ%ConsumerGroupName，死信队列的消息将不会再被消费。可以利用RocketMQAdmin工具或者RocketMQDashboard上查询到对应死信消息的信息。我们也可以去监听死信队列，然后进行自己的业务上的逻辑 消息生产者123456789101112131415161718//@Test public void testDeadMsgProducer() throws Exception &#123; DefaultMQProducer producer = new DefaultMQProducer(//&quot;dead-group//&quot;); producer.setNamesrvAddr(//&quot;localhost:9876//&quot;); producer.start(); Message message = new Message(//&quot;dead-topic//&quot;, //&quot;我是一个死信消息//&quot;.getBytes()); producer.send(message); producer.shutdown(); &#125; ​ 消息消费者12345678910111213141516171819202122232425262728293031323334353637//@Test public void testDeadMsgConsumer() throws Exception &#123; DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(//&quot;dead-group//&quot;); consumer.setNamesrvAddr(//&quot;localhost:9876//&quot;); consumer.subscribe(//&quot;dead-topic//&quot;,//&quot;//*//&quot;); // 设置最大消费重试次数 2 次* consumer.setMaxReconsumeTimes(2); consumer.registerMessageListener(new MessageListenerConcurrently() &#123; //@Override public ConsumeConcurrentlyStatus consumeMessage(List//&lt;MessageExt//&gt; msgs, ConsumeConcurrentlyContext context) &#123; System.*out*.println(msgs); // 测试消费失败* return ConsumeConcurrentlyStatus.*RECONSUME_LATER*; &#125; &#125;); consumer.start(); System.*in*.read(); &#125; 死信消费者注意权限问题 123456789101112131415161718192021222324252627282930313233343536373839//@Test public void testDeadMq() throws Exception&#123; DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(//&quot;dead-group//&quot;); consumer.setNamesrvAddr(//&quot;localhost:9876//&quot;); // 消费重试到达阈值以后，消息不会被投递给消费者了，而是进入了死信队列* // 队列名称 默认是 %DLQ% + 消费者组名* consumer.subscribe(//&quot;%DLQ%dead-group//&quot;,//&quot;//*//&quot;); consumer.registerMessageListener(new MessageListenerConcurrently() &#123; //@Override public ConsumeConcurrentlyStatus consumeMessage(List//&lt;MessageExt//&gt; msgs, ConsumeConcurrentlyContext context) &#123; System.*out*.println(msgs); // 处理消息 签收了* return ConsumeConcurrentlyStatus.*CONSUME_SUCCESS*; &#125; &#125;); consumer.start(); System.*in*.read(); &#125; 控制台显示 RocketMQ消息重复消费问题为什么会出现重复消费问题呢？BROADCASTING(广播)模式下，所有注册的消费者都会消费，而这些消费者通常是集群部署的一个个微服务，这样就会多台机器重复消费，当然这个是根据需要来选择。 CLUSTERING（负载均衡）模式下，如果一个topic被多个consumerGroup消费，也会重复消费。 即使是在CLUSTERING模式下，同一个consumerGroup下，一个队列只会分配给一个消费者，看起来好像是不会重复消费。但是，有个特殊情况：一个消费者新上线后，同组的所有消费者要重新负载均衡（反之一个消费者掉线后，也一样）。一个队列所对应的新的消费者要获取之前消费的offset（偏移量，也就是消息消费的点位），此时之前的消费者可能已经消费了一条消息，但是并没有把offset提交给broker，那么新的消费者可能会重新消费一次。虽然orderly模式是前一个消费者先解锁，后一个消费者加锁再消费的模式，比起concurrently要严格了，但是加锁的线程和提交offset的线程不是同一个，所以还是会出现极端情况下的重复消费。 还有在发送批量消息的时候，会被当做一条消息进行处理，那么如果批量消息中有一条业务处理成功，其他失败了，还是会被重新消费一次。 那么如果在CLUSTERING（负载均衡）模式下，并且在同一个消费者组中，不希望一条消息被重复消费，改怎么办呢？我们可以想到去重操作，找到消息唯一的标识，可以是msgId也可以是你自定义的唯一的key，这样就可以去重了 解决方案使用去重方案解决，例如将消息的唯一标识存起来，然后每次消费之前先判断是否存在这个唯一标识，如果存在则不消费，如果不存在则消费，并且消费以后将这个标记保存。 想法很好，但是消息的体量是非常大的，可能在生产环境中会到达上千万甚至上亿条，那么我们该如何选择一个容器来保存所有消息的标识，并且又可以快速的判断是否存在呢？ 我们可以选择布隆过滤器(BloomFilter) 布隆过滤器（BloomFilter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。 在hutool的工具中我们可以直接使用，当然你自己使用redis的bitmap类型手写一个也是可以的https://hutool.cn/docs/#/bloomFilter/%E6%A6%82%E8%BF%B0 测试生产者12345678910111213141516171819202122232425262728293031323334//@Test public void testRepeatProducer() throws Exception &#123; // 创建默认的生产者* DefaultMQProducer producer = new DefaultMQProducer(//&quot;test-group//&quot;); // 设置nameServer地址* producer.setNamesrvAddr(//&quot;localhost:9876//&quot;); // 启动实例* producer.start(); // 我们可以使用自定义key当做唯一标识* String keyId = UUID.*randomUUID*().toString(); System.*out*.println(keyId); Message msg = new Message(//&quot;TopicTest//&quot;,//&quot;tagA//&quot;, keyId, //&quot;我是一个测试消息//&quot;.getBytes()); SendResult send = producer.send(msg); System.*out*.println(send); // 关闭实例* producer.shutdown(); &#125; 添加hutool的依赖123456789//&lt;dependency//&gt; //&lt;groupId//&gt;cn.hutool//&lt;/groupId//&gt; //&lt;artifactId//&gt;hutool-all//&lt;/artifactId//&gt; //&lt;version//&gt;5.7.11//&lt;/version//&gt; //&lt;/dependency//&gt; ​ 测试消费者1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 *///*// *//* 在boot项目中可以使用@Bean在整个容器中放置一个单利对象* *//*/* public static BitMapBloomFilter *bloomFilter* = new BitMapBloomFilter(100); //@Test public void testRepeatConsumer() throws Exception &#123; // 创建默认消费者组* DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(//&quot;consumer-group//&quot;); consumer.setMessageModel(MessageModel.*BROADCASTING*); // 设置nameServer地址* consumer.setNamesrvAddr(//&quot;localhost:9876//&quot;); // 订阅一个主题来消费 表达式，默认是// consumer.subscribe(//&quot;TopicTest//&quot;,//&quot;//*//&quot;); // 注册一个消费监听 MessageListenerConcurrently是并发消费* // 默认是20个线程一起消费，可以参看 consumer.setConsumeThreadMax()* consumer.registerMessageListener(new MessageListenerConcurrently() &#123; //@Override public ConsumeConcurrentlyStatus consumeMessage(List//&lt;MessageExt//&gt; msgs, ConsumeConcurrentlyContext context) &#123; // 拿到消息的key* MessageExt messageExt = msgs.get(0); String keys = messageExt.getKeys(); // 判断是否存在布隆过滤器中* if (*bloomFilter*.contains(keys)) &#123; // 直接返回了 不往下处理业务* return ConsumeConcurrentlyStatus.*CONSUME_SUCCESS*; &#125; // 这个处理业务，然后放入过滤器中* // do sth//...* *bloomFilter*.add(keys); return ConsumeConcurrentlyStatus.*CONSUME_SUCCESS*; &#125; &#125;); consumer.start(); System.*in*.read(); &#125;","categories":[{"name":"mq","slug":"mq","permalink":"http://example.com/mq/"}],"tags":[{"name":"mq","slug":"mq","permalink":"http://example.com/tags/mq/"}]},{"title":"RocketMq（三）--快速入门","slug":"mq/RocketMq/RocketMq（三）-快速入门","date":"2023-06-19T02:09:19.000Z","updated":"2023-06-19T02:15:15.542Z","comments":true,"path":"2023/06/19/mq/RocketMq/RocketMq（三）-快速入门/","link":"","permalink":"http://example.com/2023/06/19/mq/RocketMq/RocketMq%EF%BC%88%E4%B8%89%EF%BC%89-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","excerpt":"","text":"RocketMQ快速入门RocketMQ提供了发送多种发送消息的模式，例如同步消息，异步消息，顺序消息，延迟消息，事务消息等，我们一一学习 消息发送和监听的流程我们先搞清楚消息发送和监听的流程，然后我们在开始敲代码 消息生产者12345678910111.创建消息生产者producer，并制定生产者组名 2.指定Nameserver地址 3.启动producer 4.创建消息对象，指定主题Topic、Tag和消息体等 5.发送消息 6.关闭生产者producer 消息消费者123456789101.创建消费者consumer，制定消费者组名 2.指定Nameserver地址 3.创建监听订阅主题Topic和Tag等 4.处理消息 5.启动消费者consumer 搭建Rocketmq-demo加入依赖12345678910111213141516171819202122232425262728293031323334353637&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt; &lt;version&gt;4.9.2&lt;/version&gt; &lt;!--docker的用下面这个版本--&gt; &lt;version&gt;4.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.22&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 编写生产者123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 */*** ** 测试生产者* *** **@throws Exception* **/* @Test public void testProducer() throws Exception &#123; *// 创建默认的生产者* DefaultMQProducer producer = new DefaultMQProducer(&quot;test-group&quot;); *// 设置nameServer地址* producer.setNamesrvAddr(&quot;localhost:9876&quot;); *// 启动实例* producer.start(); for (int i = 0; i&lt; 10; i++) &#123; *// 创建消息* *// 第一个参数：主题的名字* *// 第二个参数：消息内容* Message msg = new Message(&quot;TopicTest&quot;, (&quot;Hello RocketMQ&quot; + i).getBytes()); SendResult send = producer.send(msg); System.*out*.println(send); &#125; *// 关闭实例* producer.shutdown(); &#125; ​ 编写消费者12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 */*** ** 测试消费者* *** **@throws Exception* **/* @Test public void testConsumer() throws Exception &#123; *// 创建默认消费者组* DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;consumer-group&quot;); *// 设置nameServer地址* consumer.setNamesrvAddr(&quot;localhost:9876&quot;); *// 订阅一个主题来消费*表示没有过滤参数 表示这个主题的任何消息* consumer.subscribe(&quot;TopicTest&quot;,&quot;*&quot;); *// 注册一个消费监听 MessageListenerConcurrently 是多线程消费，默认20个线程，可以参看consumer.setConsumeThreadMax()* consumer.registerMessageListener(new MessageListenerConcurrently() &#123; @Override public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) &#123; System.*out*.println(Thread.*currentThread*().getName() + &quot;----&quot; + msgs); *// 返回消费的状态 如果是CONSUME_SUCCESS 则成功，若为RECONSUME_LATER则该条消息会被重回队列，重新被投递* *// 重试的时间为messageDelayLevel =&quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h* *// 也就是第一次1s 第二次5s 第三次10s.... 如果重试了18次 那么这个消息就会被终止发送给消费者* *// return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;* return ConsumeConcurrentlyStatus.*RECONSUME_LATER*; &#125; &#125;); *// 这个start一定要写在registerMessageListener下面* consumer.start(); System.*in*.read(); &#125; 测试启动生产者和消费者进行测试","categories":[{"name":"mq","slug":"mq","permalink":"http://example.com/mq/"}],"tags":[{"name":"mq","slug":"mq","permalink":"http://example.com/tags/mq/"}]},{"title":"RocketMq（二）--安装","slug":"mq/RocketMq/RocketMq（二）-安装","date":"2023-06-19T01:57:39.000Z","updated":"2023-06-19T02:07:08.144Z","comments":true,"path":"2023/06/19/mq/RocketMq/RocketMq（二）-安装/","link":"","permalink":"http://example.com/2023/06/19/mq/RocketMq/RocketMq%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%AE%89%E8%A3%85/","excerpt":"","text":"RocketMQ安装了解了mq的基本概念和角色以后，我们开始安装rocketmq，建议在linux上 下载RocketMQ下载地址：[https://rocketmq.apache.org/dowloading/releases/]{.underline} 注意选择版本，这里我们选择4.9.2的版本，后面使用alibaba时对应 下载地址： https://archive.apache.org/dist/rocketmq/4.9.2/rocketmq-all-4.9.2-bin-release.zip 上传服务器在root目录下创建文件夹 mkdir rocketmq 将下载后的压缩包上传到阿里云服务器或者虚拟机中去 解压 unzip rocketmq-all-4.9.2-bin-release.zip 如果你的服务器没有unzip命令，则下载安装一个 yum install unzip 目录分析 Benchmark：包含一些性能测试的脚本； Bin：可执行文件目录； Conf：配置文件目录； Lib：第三方依赖； LICENSE：授权信息; NOTICE：版本公告； 配置环境变量 vim &#x2F;etc&#x2F;profile 在文件末尾添加 export NAMESRV_ADDR&#x3D;阿里云公网IP:9876 修改nameServer的运行脚本进入bin目录下，修改runserver.sh文件,将71行和76行的Xms和Xmx等改小一点 vim runserver.sh 保存退出 修改broker的运行脚本进入bin目录下，修改runbroker.sh文件,修改67行 保存退出 修改broker的配置文件进入conf目录下，修改broker.conf文件 12345678910111213141516171819brokerClusterName = DefaultCluster brokerName = broker-a brokerId = 0 deleteWhen = 04 fileReservedTime = 48 brokerRole = ASYNC_MASTER flushDiskType = ASYNC_FLUSH [namesrvAddr=localhost:9876] [autoCreateTopicEnable=true] [brokerIP1=阿里云公网IP] [添加参数解释] [namesrvAddr：nameSrv地址可以写localhost因为nameSrv和broker在一个服务器] [autoCreateTopicEnable：自动创建主题，不然需要手动创建出来] [brokerIP1：broker也需要一个公网ip，如果不指定，那么是阿里云的内网地址，我们再本地无法连接使用] 启动首先在安装目录下创建一个logs文件夹，用于存放日志 mkdir logs 一次运行两条命令 启动nameSrv nohup sh bin&#x2F;mqnamesrv &gt; .&#x2F;logs&#x2F;namesrv.log &amp; 启动broker 这里的-c是指定使用的配置文件 nohup sh bin&#x2F;mqbroker -c conf&#x2F;broker.conf &gt; .&#x2F;logs&#x2F;broker.log &amp; 查看启动结果 RocketMQ控制台的安装RocketMQ-ConsoleRocketmq 控制台可以可视化MQ的消息发送！ 旧版本源码是在rocketmq-external里的rocketmq-console，新版本已经单独拆分成dashboard 网址：[https://github.com/apache/rocketmq-dashboard]{.underline} 下载地址： https://github.com/apache/rocketmq-dashboard/archive/refs/tags/rocketmq-dashboard-1.0.0.zip 下载后解压出来，在跟目录下执行 mvn clean package -Dmaven.test.skip&#x3D;true 将jar包上传到服务器上去 然后运行 nohup java -jar .&#x2F;rocketmq-dashboard-1.0.0.jar rocketmq.config.namesrvAddr&#x3D;127.0.0.1:9876 &gt; .&#x2F;rocketmq-4.9.3&#x2F;logs&#x2F;dashboard.log &amp; 命令拓展:--server.port指定运行的端口 --rocketmq.config.namesrvAddr&#x3D;127.0.0.1:9876 指定namesrv地址 访问： http://localhost:8001 运行访问端口是8001，如果从官网拉下来打包的话，默认端口是8080 RocketMQ安装之docker下载RockerMQ需要的镜像+———————————————————————–+ docker pull rocketmqinc&#x2F;rocketmq docker pull styletang&#x2F;rocketmq-console-ng+———————————————————————–+ 启动NameServer服务创建NameServer数据存储路径 mkdir -p &#x2F;home&#x2F;rocketmq&#x2F;data&#x2F;namesrv&#x2F;logs &#x2F;home&#x2F;rocketmq&#x2F;data&#x2F;namesrv&#x2F;store 启动NameServer容器 docker run -d --name rmqnamesrv -p 9876:9876 -v &#x2F;home&#x2F;rocketmq&#x2F;data&#x2F;namesrv&#x2F;logs:&#x2F;root&#x2F;logs -v &#x2F;home&#x2F;rocketmq&#x2F;data&#x2F;namesrv&#x2F;store:&#x2F;root&#x2F;store -e &quot;MAX_POSSIBLE_HEAP&#x3D;100000000&quot; rocketmqinc&#x2F;rocketmq sh mqnamesrv 启动Broker服务创建Broker数据存储路径 mkdir -p &#x2F;home&#x2F;rocketmq&#x2F;data&#x2F;broker&#x2F;logs &#x2F;home&#x2F;rocketmq&#x2F;data&#x2F;broker&#x2F;store 创建conf配置文件目录 mkdir &#x2F;home&#x2F;rocketmq&#x2F;conf 在配置文件目录下创建broker.conf配置文件123456789101112131415161718192021222324252627282930313233+-----------------------------------------------------------------------+ # 所属集群名称，如果节点较多可以配置多个* brokerClusterName = DefaultCluster #broker名称，master和slave使用相同的名称，表明他们的主从关系* brokerName = broker-a #0表示Master，大于0表示不同的slave* brokerId = 0 #表示几点做消息删除动作，默认是凌晨4点* deleteWhen = 04 #在磁盘上保留消息的时长，单位是小时* fileReservedTime = 48 #有三个值：SYNC_MASTER， ASYNC_MASTER，SLAVE；同步和异步表示Master和Slave之间同步数据的机制；* brokerRole = ASYNC_MASTER #刷盘策略，取值为：ASYNC_FLUSH，SYNC_FLUSH表示同步刷盘和异步刷盘；SYNC_FLUSH消息写入磁盘后才返回成功状态，ASYNC_FLUSH不需要；* flushDiskType = ASYNC_FLUSH # 设置broker节点所在服务器的ip地址* brokerIP1 = 你服务器外网ip 启动Broker容器 docker run -d --name rmqbroker --link rmqnamesrv:namesrv -p 10911:10911 -p 10909:10909 -v &#x2F;home&#x2F;rocketmq&#x2F;data&#x2F;broker&#x2F;logs:&#x2F;root&#x2F;logs -v &#x2F;home&#x2F;rocketmq&#x2F;data&#x2F;broker&#x2F;store:&#x2F;root&#x2F;store -v &#x2F;home&#x2F;rocketmq&#x2F;conf&#x2F;broker.conf:&#x2F;opt&#x2F;rocketmq-4.4.0&#x2F;conf&#x2F;broker.conf --privileged&#x3D;true -e &quot;NAMESRV_ADDR&#x3D;namesrv:9876&quot; -e &quot;MAX_POSSIBLE_HEAP&#x3D;200000000&quot; rocketmqinc&#x2F;rocketmq sh mqbroker -c &#x2F;opt&#x2F;rocketmq-4.4.0&#x2F;conf&#x2F;broker.conf 启动控制台1234567docker run -d \\--name rmqadmin -e \\&quot;JAVA_OPTS=-Drocketmq.namesrv.addr=你的外网地址:9876 \\\\ -Dcom.rocketmq.sendMessageWithVIPChannel=false \\\\ -Duser.timezone=\\&#x27;Asia/Shanghai\\&#x27;\\&quot; -v /etc/localtime:/etc/localtime -p 9999:8080 styletang/rocketmq-console-ng 正常启动后的docker ps 访问控制台 http:&#x2F;&#x2F;你的服务器外网ip:9999&#x2F;","categories":[{"name":"mq","slug":"mq","permalink":"http://example.com/mq/"}],"tags":[{"name":"mq","slug":"mq","permalink":"http://example.com/tags/mq/"}]},{"title":"RocketMq（一）--简介","slug":"mq/RocketMq/RocketMq（一）-简介","date":"2023-06-19T01:50:01.000Z","updated":"2023-06-19T01:55:56.260Z","comments":true,"path":"2023/06/19/mq/RocketMq/RocketMq（一）-简介/","link":"","permalink":"http://example.com/2023/06/19/mq/RocketMq/RocketMq%EF%BC%88%E4%B8%80%EF%BC%89-%E7%AE%80%E4%BB%8B/","excerpt":"","text":"RocketMQ简介MQ&#x3D;&#x3D;&#x3D;&#x3D;Message Queue 官网：[http://rocketmq.apache.org/]{.underline} RocketMQ是阿里巴巴2016年MQ中间件，使用Java语言开发，RocketMQ是一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。同时，广泛应用于多个领域，包括异步通信解耦、企业解决方案、金融支付、电信、电子商务、快递物流、广告营销、社交、即时通信、移动应用、手游、视频、物联网、车联网等。 具有以下特点： 能够保证严格的消息顺序 提供丰富的消息拉取模式 高效的订阅者水平扩展能力 实时的消息订阅机制 亿级消息堆积能力 为什么要使用MQ1，要做到系统解耦，当新的模块进来时，可以做到代码改动最小; 能够解耦 2，设置流程缓冲池，可以让后端系统按自身吞吐能力进行消费，不被冲垮; 能够削峰，限流 3，强弱依赖梳理能把非关键调用链路的操作异步化并提升整体系统的吞吐能力;能够异步 [Mq的作用 削峰限流 异步 解耦合]{.mark} 定义中间件（缓存中间件 redis memcache 数据库中间件 mycat canal 消息中间件mq） 面向消息的中间件(message-oriented middleware)MOM能够很好的解决以上的问题。 是指利用高效可靠的消息传递机制进行与平台无关（跨平台）的数据交流，并基于数据通信来进行分布式系统的集成。 通过提供消息传递和消息排队模型在分布式环境下提供应用解耦，弹性伸缩，冗余存储，流量削峰，异步通信，数据同步等 大致流程 发送者把消息发给消息服务器[MQ]，消息服务器把消息存放在若干队列&#x2F;主题中，在合适的时候，消息服务器会把消息转发给接受者。在这个过程中，发送和接受是异步的,也就是发送无需等待，发送者和接受者的生命周期也没有必然关系在发布pub&#x2F;订阅sub模式下，也可以完成一对多的通信，可以让一个消息有多个接受者[微信订阅号就是这样的] 特点异步处理模式消息发送者可以发送一个消息而无需等待响应。消息发送者把消息发送到一条虚拟的通道(主题或队列)上; 消息接收者则订阅或监听该通道。一条信息可能最终转发给一个或多个消息接收者，这些接收者都无需对消息发送者做出回应。整个过程都是异步的。 案例： 也就是说，一个系统和另一个系统间进行通信的时候，假如系统A希望发送一个消息给系统B，让它去处理，但是系统A不关注系统B到底怎么处理或者有没有处理好，所以系统A把消息发送给MQ，然后就不管这条消息的”死活”了，接着系统B从MQ里面消费出来处理即可。至于怎么处理，是否处理完毕，什么时候处理，都是系统B的事，与系统A无关。 这样的一种通信方式，就是所谓的”异步”通信方式，对于系统A来说，只要把消息发给MQ,然后系统B就会异步处去进行处理了，系统A不能”同步”的等待系统B处理完。这样的好处是什么呢？解耦 应用系统的解耦 发送者和接收者不必了解对方，只需要确认消息 发送者和接收者不必同时在线 现实中的业务 各个MQ产品的比较 RocketMQ重要概念【重点】Producer：消息的发送者，生产者；举例：发件人 Consumer：消息接收者，消费者；举例：收件人 Broker：暂存和传输消息的通道；举例：快递 NameServer：管理Broker；举例：各个快递公司的管理机构相当于broker的注册中心，保留了broker的信息 Queue：队列，消息存放的位置，一个Broker中可以有多个队列 Topic：主题，消息的分类 ProducerGroup：生产者组 ConsumerGroup：消费者组，多个消费者组可以同时消费一个主题的消息 消息发送的流程是，Producer询问NameServer，NameServer分配一个broker然后Consumer也要询问NameServer，得到一个具体的broker，然后消费消息 生产和消费理解【重点】","categories":[{"name":"mq","slug":"mq","permalink":"http://example.com/mq/"}],"tags":[{"name":"mq","slug":"mq","permalink":"http://example.com/tags/mq/"}]},{"title":"spring-ioc-demo","slug":"spring/spring-ioc-demo","date":"2023-06-19T01:21:46.000Z","updated":"2023-06-19T01:26:12.520Z","comments":true,"path":"2023/06/19/spring/spring-ioc-demo/","link":"","permalink":"http://example.com/2023/06/19/spring/spring-ioc-demo/","excerpt":"","text":"部分关于spring-ioc源码简单手写 gitee地址：https://gitee.com/zhangying17865151388/spring-ioc-demo.git","categories":[{"name":"spring","slug":"spring","permalink":"http://example.com/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://example.com/tags/spring/"}]},{"title":"设计模式（六）","slug":"设计模式/设计模式（六）","date":"2023-06-16T06:01:23.000Z","updated":"2023-06-16T06:02:38.035Z","comments":true,"path":"2023/06/16/设计模式/设计模式（六）/","link":"","permalink":"http://example.com/2023/06/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%85%AD%EF%BC%89/","excerpt":"","text":"6，行为型模式6.11 解释器模式6.11.1 概述 如上图，设计一个软件用来进行加减计算。我们第一想法就是使用工具类，提供对应的加法和减法的工具方法。 123456789101112131415161718//用于两个整数相加public static int add(int a,int b)&#123; return a + b;&#125;//用于两个整数相加public static int add(int a,int b,int c)&#123; return a + b + c;&#125;//用于n个整数相加public static int add(Integer ... arr) &#123; int sum = 0; for (Integer i : arr) &#123; sum += i; &#125; return sum;&#125; 上面的形式比较单一、有限，如果形式变化非常多，这就不符合要求，因为加法和减法运算，两个运算符与数值可以有无限种组合方式。比如 1+2+3+4+5、1+2+3-4等等。 显然，现在需要一种翻译识别机器，能够解析由数字以及 + - 符号构成的合法的运算序列。如果把运算符和数字都看作节点的话，能够逐个节点的进行读取解析运算，这就是解释器模式的思维。 定义： 给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。 在解释器模式中，我们需要将待解决的问题，提取出规则，抽象为一种“语言”。比如加减法运算，规则为：由数值和+-符号组成的合法序列，“1+3-2” 就是这种语言的句子。 解释器就是要解析出来语句的含义。但是如何描述规则呢？ 文法（语法）规则： 文法是用于描述语言的语法结构的形式规则。 1234expression ::= value | plus | minusplus ::= expression ‘+’ expression minus ::= expression ‘-’ expression value ::= integer 注意： 这里的符号“::&#x3D;”表示“定义为”的意思，竖线 | 表示或，左右的其中一个，引号内为字符本身，引号外为语法。 上面规则描述为 ： 表达式可以是一个值，也可以是plus或者minus运算，而plus和minus又是由表达式结合运算符构成，值的类型为整型数。 抽象语法树： 在计算机科学中，抽象语法树（AbstractSyntaxTree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。 用树形来表示符合文法规则的句子。 6.11.2 结构解释器模式包含以下主要角色。 抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。 终结符表达式（Terminal Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。 非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。 环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。 客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。 6.11.3 案例实现【例】设计实现加减法的软件 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122//抽象角色AbstractExpressionpublic abstract class AbstractExpression &#123; public abstract int interpret(Context context);&#125;//终结符表达式角色public class Value extends AbstractExpression &#123; private int value; public Value(int value) &#123; this.value = value; &#125; @Override public int interpret(Context context) &#123; return value; &#125; @Override public String toString() &#123; return new Integer(value).toString(); &#125;&#125;//非终结符表达式角色 加法表达式public class Plus extends AbstractExpression &#123; private AbstractExpression left; private AbstractExpression right; public Plus(AbstractExpression left, AbstractExpression right) &#123; this.left = left; this.right = right; &#125; @Override public int interpret(Context context) &#123; return left.interpret(context) + right.interpret(context); &#125; @Override public String toString() &#123; return &quot;(&quot; + left.toString() + &quot; + &quot; + right.toString() + &quot;)&quot;; &#125;&#125;///非终结符表达式角色 减法表达式public class Minus extends AbstractExpression &#123; private AbstractExpression left; private AbstractExpression right; public Minus(AbstractExpression left, AbstractExpression right) &#123; this.left = left; this.right = right; &#125; @Override public int interpret(Context context) &#123; return left.interpret(context) - right.interpret(context); &#125; @Override public String toString() &#123; return &quot;(&quot; + left.toString() + &quot; - &quot; + right.toString() + &quot;)&quot;; &#125;&#125;//终结符表达式角色 变量表达式public class Variable extends AbstractExpression &#123; private String name; public Variable(String name) &#123; this.name = name; &#125; @Override public int interpret(Context ctx) &#123; return ctx.getValue(this); &#125; @Override public String toString() &#123; return name; &#125;&#125;//环境类public class Context &#123; private Map&lt;Variable, Integer&gt; map = new HashMap&lt;Variable, Integer&gt;(); public void assign(Variable var, Integer value) &#123; map.put(var, value); &#125; public int getValue(Variable var) &#123; Integer value = map.get(var); return value; &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; Context context = new Context(); Variable a = new Variable(&quot;a&quot;); Variable b = new Variable(&quot;b&quot;); Variable c = new Variable(&quot;c&quot;); Variable d = new Variable(&quot;d&quot;); Variable e = new Variable(&quot;e&quot;); //Value v = new Value(1); context.assign(a, 1); context.assign(b, 2); context.assign(c, 3); context.assign(d, 4); context.assign(e, 5); AbstractExpression expression = new Minus(new Plus(new Plus(new Plus(a, b), c), d), e); System.out.println(expression + &quot;= &quot; + expression.interpret(context)); &#125;&#125; 6.11.4 优缺点1，优点： 易于改变和扩展文法。 由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。 实现文法较为容易。 在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂。 增加新的解释表达式较为方便。 如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合 “开闭原则”。 2，缺点： 对于复杂文法难以维护。 在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护。 执行效率较低。 由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。 6.11.5 使用场景 当语言的文法较为简单，且执行效率不是关键问题时。 当问题重复出现，且可以用一种简单的语言来进行表达时。 当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候。 7，自定义Spring框架7.1 spring使用回顾自定义spring框架前，先回顾一下spring框架的使用，从而分析spring的核心，并对核心功能进行模拟。 数据访问层。定义UserDao接口及其子实现类 12345678910public interface UserDao &#123; public void add();&#125;public class UserDaoImpl implements UserDao &#123; public void add() &#123; System.out.println(&quot;userDaoImpl ....&quot;); &#125;&#125; 业务逻辑层。定义UserService接口及其子实现类 1234567891011121314151617public interface UserService &#123; public void add();&#125;public class UserServiceImpl implements UserService &#123; private UserDao userDao; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public void add() &#123; System.out.println(&quot;userServiceImpl ...&quot;); userDao.add(); &#125;&#125; 定义UserController类，使用main方法模拟controller层 12345678910public class UserController &#123; public static void main(String[] args) &#123; //创建spring容器对象 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //从IOC容器中获取UserService对象 UserService userService = applicationContext.getBean(&quot;userService&quot;, UserService.class); //调用UserService对象的add方法 userService.add(); &#125;&#125; 编写配置文件。在类路径下编写一个名为ApplicationContext.xml的配置文件 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 代码运行结果如下： 通过上面代码及结果可以看出： userService对象是从applicationContext容器对象获取到的，也就是userService对象交由spring进行管理。 上面结果可以看到调用了UserDao对象中的add方法，也就是说UserDao子实现类对象也交由spring管理了。 UserService中的userDao变量我们并没有进行赋值，但是可以正常使用，说明spring已经将UserDao对象赋值给了userDao变量。 上面三点体现了Spring框架的IOC（Inversion of Control）和DI（Dependency Injection, DI） 7.2 spring核心功能结构Spring大约有20个模块，由1300多个不同的文件构成。这些模块可以分为: 核心容器、AOP和设备支持、数据访问与集成、Web组件、通信报文和集成测试等，下面是 Spring 框架的总体架构图： 核心容器由 beans、core、context 和 expression（Spring Expression Language，SpEL）4个模块组成。 spring-beans和spring-core模块是Spring框架的核心模块，包含了控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）。BeanFactory使用控制反转对应用程序的配置和依赖性规范与实际的应用程序代码进行了分离。BeanFactory属于延时加载，也就是说在实例化容器对象后并不会自动实例化Bean，只有当Bean被使用时，BeanFactory才会对该 Bean 进行实例化与依赖关系的装配。 spring-context模块构架于核心模块之上，扩展了BeanFactory，为它添加了Bean生命周期控制、框架事件体系及资源加载透明化等功能。此外，该模块还提供了许多企业级支持，如邮件访问、远程访问、任务调度等，ApplicationContext 是该模块的核心接口，它的超类是 BeanFactory。与BeanFactory不同，ApplicationContext实例化后会自动对所有的单实例Bean进行实例化与依赖关系的装配，使之处于待用状态。 spring-context-support模块是对Spring IoC容器及IoC子容器的扩展支持。 spring-context-indexer模块是Spring的类管理组件和Classpath扫描组件。 spring-expression 模块是统一表达式语言（EL）的扩展模块，可以查询、管理运行中的对象，同时也可以方便地调用对象方法，以及操作数组、集合等。它的语法类似于传统EL，但提供了额外的功能，最出色的要数函数调用和简单字符串的模板函数。EL的特性是基于Spring产品的需求而设计的，可以非常方便地同Spring IoC进行交互。 7.1.1 bean概述Spring 就是面向 Bean 的编程（BOP,Bean Oriented Programming），Bean 在 Spring 中处于核心地位。Bean对于Spring的意义就像Object对于OOP的意义一样，Spring中没有Bean也就没有Spring存在的意义。Spring IoC容器通过配置文件或者注解的方式来管理bean对象之间的依赖关系。 spring中bean用于对一个类进行封装。如下面的配置： 1234&lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt; 为什么Bean如此重要呢？ spring 将bean对象交由一个叫IOC容器进行管理。 bean对象之间的依赖关系在配置文件中体现，并由spring完成。 7.3 Spring IOC相关接口分析7.3.1 BeanFactory解析Spring中Bean的创建是典型的工厂模式，这一系列的Bean工厂，即IoC容器，为开发者管理对象之间的依赖关系提供了很多便利和基础服务，在Spring中有许多IoC容器的实现供用户选择，其相互关系如下图所示。 其中，BeanFactory作为最顶层的一个接口，定义了IoC容器的基本功能规范，BeanFactory有三个重要的子接口：ListableBeanFactory、HierarchicalBeanFactory和AutowireCapableBeanFactory。但是从类图中我们可以发现最终的默认实现类是DefaultListableBeanFactory，它实现了所有的接口。 那么为何要定义这么多层次的接口呢？ 每个接口都有它的使用场合，主要是为了区分在Spring内部操作过程中对象的传递和转化，对对象的数据访问所做的限制。例如， ListableBeanFactory接口表示这些Bean可列表化。 HierarchicalBeanFactory表示这些Bean 是有继承关系的，也就是每个 Bean 可能有父 Bean AutowireCapableBeanFactory 接口定义Bean的自动装配规则。 这三个接口共同定义了Bean的集合、Bean之间的关系及Bean行为。最基本的IoC容器接口是BeanFactory，来看一下它的源码： 1234567891011121314151617181920212223242526public interface BeanFactory &#123; String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;; //根据bean的名称获取IOC容器中的的bean对象 Object getBean(String name) throws BeansException; //根据bean的名称获取IOC容器中的的bean对象，并指定获取到的bean对象的类型，这样我们使用时就不需要进行类型强转了 &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException; Object getBean(String name, Object... args) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException; &lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(Class&lt;T&gt; requiredType); &lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(ResolvableType requiredType); //判断容器中是否包含指定名称的bean对象 boolean containsBean(String name); //根据bean的名称判断是否是单例 boolean isSingleton(String name) throws NoSuchBeanDefinitionException; boolean isPrototype(String name) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException; @Nullable Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException; String[] getAliases(String name);&#125; 在BeanFactory里只对IoC容器的基本行为做了定义，根本不关心你的Bean是如何定义及怎样加载的。正如我们只关心能从工厂里得到什么产品，不关心工厂是怎么生产这些产品的。 BeanFactory有一个很重要的子接口，就是ApplicationContext接口，该接口主要来规范容器中的bean对象是非延时加载，即在创建容器对象的时候就对象bean进行初始化，并存储到一个容器中。 要知道工厂是如何产生对象的，我们需要看具体的IoC容器实现，Spring提供了许多IoC容器实现，比如： ClasspathXmlApplicationContext : 根据类路径加载xml配置文件，并创建IOC容器对象。 FileSystemXmlApplicationContext ：根据系统路径加载xml配置文件，并创建IOC容器对象。 AnnotationConfigApplicationContext ：加载注解类配置，并创建IOC容器。 7.3.2 BeanDefinition解析Spring IoC容器管理我们定义的各种Bean对象及其相互关系，而Bean对象在Spring实现中是以BeanDefinition来描述的，如下面配置文件 1234&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;bean标签还有很多属性： scope、init-method、destory-method等。 其继承体系如下图所示。 7.3.3 BeanDefinitionReader解析Bean的解析过程非常复杂，功能被分得很细，因为这里需要被扩展的地方很多，必须保证足够的灵活性，以应对可能的变化。Bean的解析主要就是对Spring配置文件的解析。这个解析过程主要通过BeanDefinitionReader来完成，看看Spring中BeanDefinitionReader的类结构图，如下图所示。 看看BeanDefinitionReader接口定义的功能来理解它具体的作用： 123456789101112131415161718192021public interface BeanDefinitionReader &#123; //获取BeanDefinitionRegistry注册器对象 BeanDefinitionRegistry getRegistry(); @Nullable ResourceLoader getResourceLoader(); @Nullable ClassLoader getBeanClassLoader(); BeanNameGenerator getBeanNameGenerator(); /* 下面的loadBeanDefinitions都是加载bean定义，从指定的资源中 */ int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException; int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException; int loadBeanDefinitions(String location) throws BeanDefinitionStoreException; int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException;&#125; 7.3.4 BeanDefinitionRegistry解析BeanDefinitionReader用来解析bean定义，并封装BeanDefinition对象，而我们定义的配置文件中定义了很多bean标签，所以就有一个问题，解析的BeanDefinition对象存储到哪儿？答案就是BeanDefinition的注册中心，而该注册中心顶层接口就是BeanDefinitionRegistry。 123456789101112131415161718192021public interface BeanDefinitionRegistry extends AliasRegistry &#123; //往注册表中注册bean void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException; //从注册表中删除指定名称的bean void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException; //获取注册表中指定名称的bean BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException; //判断注册表中是否已经注册了指定名称的bean boolean containsBeanDefinition(String beanName); //获取注册表中所有的bean的名称 String[] getBeanDefinitionNames(); int getBeanDefinitionCount(); boolean isBeanNameInUse(String beanName);&#125; 继承结构图如下： 从上面类图可以看到BeanDefinitionRegistry接口的子实现类主要有以下几个： DefaultListableBeanFactory 在该类中定义了如下代码，就是用来注册bean 1private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256); SimpleBeanDefinitionRegistry 在该类中定义了如下代码，就是用来注册bean 1private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(64); 7.3.5 创建容器ClassPathXmlApplicationContext对Bean配置资源的载入是从refresh（）方法开始的。refresh（）方法是一个模板方法，规定了 IoC 容器的启动流程，有些逻辑要交给其子类实现。它对 Bean 配置资源进行载入，ClassPathXmlApplicationContext通过调用其父类AbstractApplicationContext的refresh（）方法启动整个IoC容器对Bean定义的载入过程。 7.4 自定义SpringIOC现要对下面的配置文件进行解析，并自定义Spring框架的IOC对涉及到的对象进行管理。 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 7.4.1 定义bean相关的pojo类7.4.1.1 PropertyValue类用于封装bean的属性，体现到上面的配置文件就是封装bean标签的子标签property标签数据。 123456789101112131415161718192021222324252627282930313233343536373839public class PropertyValue &#123; private String name; private String ref; private String value; public PropertyValue() &#123; &#125; public PropertyValue(String name, String ref,String value) &#123; this.name = name; this.ref = ref; this.value = value; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getRef() &#123; return ref; &#125; public void setRef(String ref) &#123; this.ref = ref; &#125; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125;&#125; 7.4.1.2 MutablePropertyValues类一个bean标签可以有多个property子标签，所以再定义一个MutablePropertyValues类，用来存储并管理多个PropertyValue对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class MutablePropertyValues implements Iterable&lt;PropertyValue&gt; &#123; private final List&lt;PropertyValue&gt; propertyValueList; public MutablePropertyValues() &#123; this.propertyValueList = new ArrayList&lt;PropertyValue&gt;(); &#125; public MutablePropertyValues(List&lt;PropertyValue&gt; propertyValueList) &#123; this.propertyValueList = (propertyValueList != null ? propertyValueList : new ArrayList&lt;PropertyValue&gt;()); &#125; public PropertyValue[] getPropertyValues() &#123; return this.propertyValueList.toArray(new PropertyValue[0]); &#125; public PropertyValue getPropertyValue(String propertyName) &#123; for (PropertyValue pv : this.propertyValueList) &#123; if (pv.getName().equals(propertyName)) &#123; return pv; &#125; &#125; return null; &#125; @Override public Iterator&lt;PropertyValue&gt; iterator() &#123; return propertyValueList.iterator(); &#125; public boolean isEmpty() &#123; return this.propertyValueList.isEmpty(); &#125; public MutablePropertyValues addPropertyValue(PropertyValue pv) &#123; for (int i = 0; i &lt; this.propertyValueList.size(); i++) &#123; PropertyValue currentPv = this.propertyValueList.get(i); if (currentPv.getName().equals(pv.getName())) &#123; this.propertyValueList.set(i, new PropertyValue(pv.getName(),pv.getRef(), pv.getValue())); return this; &#125; &#125; this.propertyValueList.add(pv); return this; &#125; public boolean contains(String propertyName) &#123; return getPropertyValue(propertyName) != null; &#125;&#125; 7.4.1.3 BeanDefinition类BeanDefinition类用来封装bean信息的，主要包含id（即bean对象的名称）、class（需要交由spring管理的类的全类名）及子标签property数据。 12345678910111213141516171819202122232425262728293031323334public class BeanDefinition &#123; private String id; private String className; private MutablePropertyValues propertyValues; public BeanDefinition() &#123; propertyValues = new MutablePropertyValues(); &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getClassName() &#123; return className; &#125; public void setClassName(String className) &#123; this.className = className; &#125; public void setPropertyValues(MutablePropertyValues propertyValues) &#123; this.propertyValues = propertyValues; &#125; public MutablePropertyValues getPropertyValues() &#123; return propertyValues; &#125;&#125; 7.4.2 定义注册表相关类7.4.2.1 BeanDefinitionRegistry接口BeanDefinitionRegistry接口定义了注册表的相关操作，定义如下功能： 注册BeanDefinition对象到注册表中 从注册表中删除指定名称的BeanDefinition对象 根据名称从注册表中获取BeanDefinition对象 判断注册表中是否包含指定名称的BeanDefinition对象 获取注册表中BeanDefinition对象的个数 获取注册表中所有的BeanDefinition的名称 1234567891011121314151617public interface BeanDefinitionRegistry &#123; //注册BeanDefinition对象到注册表中 void registerBeanDefinition(String beanName, BeanDefinition beanDefinition); //从注册表中删除指定名称的BeanDefinition对象 void removeBeanDefinition(String beanName) throws Exception; //根据名称从注册表中获取BeanDefinition对象 BeanDefinition getBeanDefinition(String beanName) throws Exception; boolean containsBeanDefinition(String beanName); int getBeanDefinitionCount(); String[] getBeanDefinitionNames();&#125; 7.4.2.2 SimpleBeanDefinitionRegistry类该类实现了BeanDefinitionRegistry接口，定义了Map集合作为注册表容器。 12345678910111213141516171819202122232425262728293031323334public class SimpleBeanDefinitionRegistry implements BeanDefinitionRegistry &#123; private Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new HashMap&lt;String, BeanDefinition&gt;(); @Override public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) &#123; beanDefinitionMap.put(beanName,beanDefinition); &#125; @Override public void removeBeanDefinition(String beanName) throws Exception &#123; beanDefinitionMap.remove(beanName); &#125; @Override public BeanDefinition getBeanDefinition(String beanName) throws Exception &#123; return beanDefinitionMap.get(beanName); &#125; @Override public boolean containsBeanDefinition(String beanName) &#123; return beanDefinitionMap.containsKey(beanName); &#125; @Override public int getBeanDefinitionCount() &#123; return beanDefinitionMap.size(); &#125; @Override public String[] getBeanDefinitionNames() &#123; return beanDefinitionMap.keySet().toArray(new String[1]); &#125;&#125; 7.4.3 定义解析器相关类7.4.3.1 BeanDefinitionReader接口BeanDefinitionReader是用来解析配置文件并在注册表中注册bean的信息。定义了两个规范： 获取注册表的功能，让外界可以通过该对象获取注册表对象。 加载配置文件，并注册bean数据。 1234567public interface BeanDefinitionReader &#123; //获取注册表对象 BeanDefinitionRegistry getRegistry(); //加载配置文件并在注册表中进行注册 void loadBeanDefinitions(String configLocation) throws Exception;&#125; 7.4.3.2 XmlBeanDefinitionReader类XmlBeanDefinitionReader类是专门用来解析xml配置文件的。该类实现BeanDefinitionReader接口并实现接口中的两个功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class XmlBeanDefinitionReader implements BeanDefinitionReader &#123; private BeanDefinitionRegistry registry; public XmlBeanDefinitionReader() &#123; this.registry = new SimpleBeanDefinitionRegistry(); &#125; @Override public BeanDefinitionRegistry getRegistry() &#123; return registry; &#125; @Override public void loadBeanDefinitions(String configLocation) throws Exception &#123; InputStream is = this.getClass().getClassLoader().getResourceAsStream(configLocation); SAXReader reader = new SAXReader(); Document document = reader.read(is); Element rootElement = document.getRootElement(); //解析bean标签 parseBean(rootElement); &#125; private void parseBean(Element rootElement) &#123; List&lt;Element&gt; elements = rootElement.elements(); for (Element element : elements) &#123; String id = element.attributeValue(&quot;id&quot;); String className = element.attributeValue(&quot;class&quot;); BeanDefinition beanDefinition = new BeanDefinition(); beanDefinition.setId(id); beanDefinition.setClassName(className); List&lt;Element&gt; list = element.elements(&quot;property&quot;); MutablePropertyValues mutablePropertyValues = new MutablePropertyValues(); for (Element element1 : list) &#123; String name = element1.attributeValue(&quot;name&quot;); String ref = element1.attributeValue(&quot;ref&quot;); String value = element1.attributeValue(&quot;value&quot;); PropertyValue propertyValue = new PropertyValue(name,ref,value); mutablePropertyValues.addPropertyValue(propertyValue); &#125; beanDefinition.setPropertyValues(mutablePropertyValues); registry.registerBeanDefinition(id,beanDefinition); &#125; &#125;&#125; 7.4.4 IOC容器相关类7.4.4.1 BeanFactory接口在该接口中定义IOC容器的统一规范即获取bean对象。 123456public interface BeanFactory &#123; //根据bean对象的名称获取bean对象 Object getBean(String name) throws Exception; //根据bean对象的名称获取bean对象，并进行类型转换 &lt;T&gt; T getBean(String name, Class&lt;? extends T&gt; clazz) throws Exception;&#125; 7.4.4.2 ApplicationContext接口该接口的所以的子实现类对bean对象的创建都是非延时的，所以在该接口中定义 refresh() 方法，该方法主要完成以下两个功能： 加载配置文件。 根据注册表中的BeanDefinition对象封装的数据进行bean对象的创建。 1234public interface ApplicationContext extends BeanFactory &#123; //进行配置文件加载并进行对象创建 void refresh() throws IllegalStateException, Exception;&#125; 7.4.4.3 AbstractApplicationContext类 作为ApplicationContext接口的子类，所以该类也是非延时加载，所以需要在该类中定义一个Map集合，作为bean对象存储的容器。 声明BeanDefinitionReader类型的变量，用来进行xml配置文件的解析，符合单一职责原则。 BeanDefinitionReader类型的对象创建交由子类实现，因为只有子类明确到底创建BeanDefinitionReader哪儿个子实现类对象。 1234567891011121314151617181920212223242526272829public abstract class AbstractApplicationContext implements ApplicationContext &#123; protected BeanDefinitionReader beanDefinitionReader; //用来存储bean对象的容器 key存储的是bean的id值，value存储的是bean对象 protected Map&lt;String, Object&gt; singletonObjects = new HashMap&lt;String, Object&gt;(); //存储配置文件的路径 protected String configLocation; public void refresh() throws IllegalStateException, Exception &#123; //加载BeanDefinition beanDefinitionReader.loadBeanDefinitions(configLocation); //初始化bean finishBeanInitialization(); &#125; //bean的初始化 private void finishBeanInitialization() throws Exception &#123; BeanDefinitionRegistry registry = beanDefinitionReader.getRegistry(); String[] beanNames = registry.getBeanDefinitionNames(); for (String beanName : beanNames) &#123; BeanDefinition beanDefinition = registry.getBeanDefinition(beanName); getBean(beanName); &#125; &#125;&#125; 注意：该类finishBeanInitialization()方法中调用getBean()方法使用到了模板方法模式。 7.4.4.4 ClassPathXmlApplicationContext类该类主要是加载类路径下的配置文件，并进行bean对象的创建，主要完成以下功能： 在构造方法中，创建BeanDefinitionReader对象。 在构造方法中，调用refresh()方法，用于进行配置文件加载、创建bean对象并存储到容器中。 重写父接口中的getBean()方法，并实现依赖注入操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class ClassPathXmlApplicationContext extends AbstractApplicationContext&#123; public ClassPathXmlApplicationContext(String configLocation) &#123; this.configLocation = configLocation; //构建XmlBeanDefinitionReader对象 beanDefinitionReader = new XmlBeanDefinitionReader(); try &#123; this.refresh(); &#125; catch (Exception e) &#123; &#125; &#125; //根据bean的id属性值获取bean对象 @Override public Object getBean(String name) throws Exception &#123; //return singletonObjects.get(name); Object obj = singletonObjects.get(name); if(obj != null) &#123; return obj; &#125; BeanDefinitionRegistry registry = beanDefinitionReader.getRegistry(); BeanDefinition beanDefinition = registry.getBeanDefinition(name); if(beanDefinition == null) &#123; return null; &#125; String className = beanDefinition.getClassName(); Class&lt;?&gt; clazz = Class.forName(className); Object beanObj = clazz.newInstance(); MutablePropertyValues propertyValues = beanDefinition.getPropertyValues(); for (PropertyValue propertyValue : propertyValues) &#123; String propertyName = propertyValue.getName(); String value = propertyValue.getValue(); String ref = propertyValue.getRef(); if(ref != null &amp;&amp; !&quot;&quot;.equals(ref)) &#123; Object bean = getBean(ref); String methodName = StringUtils.getSetterMethodNameByFieldName(propertyName); Method[] methods = clazz.getMethods(); for (Method method : methods) &#123; if(method.getName().equals(methodName)) &#123; method.invoke(beanObj,bean); &#125; &#125; &#125; if(value != null &amp;&amp; !&quot;&quot;.equals(value)) &#123; String methodName = StringUtils.getSetterMethodNameByFieldName(propertyName); Method method = clazz.getMethod(methodName, String.class); method.invoke(beanObj,value); &#125; &#125; singletonObjects.put(name,beanObj); return beanObj; &#125; @Override public &lt;T&gt; T getBean(String name, Class&lt;? extends T&gt; clazz) throws Exception &#123; Object bean = getBean(name); if(bean != null) &#123; return clazz.cast(bean); &#125; return null; &#125;&#125; 7.4.5 自定义Spring IOC总结7.4.5.1 使用到的设计模式 工厂模式。这个使用工厂模式 + 配置文件的方式。 单例模式。Spring IOC管理的bean对象都是单例的，此处的单例不是通过构造器进行单例的控制的，而是spring框架对每一个bean只创建了一个对象。 模板方法模式。AbstractApplicationContext类中的finishBeanInitialization()方法调用了子类的getBean()方法，因为getBean()的实现和环境息息相关。 迭代器模式。对于MutablePropertyValues类定义使用到了迭代器模式，因为此类存储并管理PropertyValue对象，也属于一个容器，所以给该容器提供一个遍历方式。 spring框架其实使用到了很多设计模式，如AOP使用到了代理模式，选择JDK代理或者CGLIB代理使用到了策略模式，还有适配器模式，装饰者模式，观察者模式等。 7.4.5.2 符合大部分设计原则7.4.5.3 整个设计和Spring的设计还是有一定的出入spring框架底层是很复杂的，进行了很深入的封装，并对外提供了很好的扩展性。而我们自定义SpringIOC有以下几个目的： 了解Spring底层对对象的大体管理机制。 了解设计模式在具体的开发中的使用。 以后学习spring源码，通过该案例的实现，可以降低spring学习的入门成本。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式（五）","slug":"设计模式/设计模式（五）","date":"2023-06-16T06:00:14.000Z","updated":"2023-06-16T06:01:14.344Z","comments":true,"path":"2023/06/16/设计模式/设计模式（五）/","link":"","permalink":"http://example.com/2023/06/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%94%EF%BC%89/","excerpt":"","text":"6，行为型模式6.5 状态模式6.5.1 概述【例】通过按钮来控制一个电梯的状态，一个电梯有开门状态，关门状态，停止状态，运行状态。每一种状态改变，都有可能要根据其他状态来更新处理。例如，如果电梯门现在处于运行时状态，就不能进行开门操作，而如果电梯门是停止状态，就可以执行开门操作。 类图如下： 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123public interface ILift &#123; //电梯的4个状态 //开门状态 public final static int OPENING_STATE = 1; //关门状态 public final static int CLOSING_STATE = 2; //运行状态 public final static int RUNNING_STATE = 3; //停止状态 public final static int STOPPING_STATE = 4; //设置电梯的状态 public void setState(int state); //电梯的动作 public void open(); public void close(); public void run(); public void stop();&#125;public class Lift implements ILift &#123; private int state; @Override public void setState(int state) &#123; this.state = state; &#125; //执行关门动作 @Override public void close() &#123; switch (this.state) &#123; case OPENING_STATE: System.out.println(&quot;电梯关门了。。。&quot;);//只有开门状态可以关闭电梯门，可以对应电梯状态表来看 this.setState(CLOSING_STATE);//关门之后电梯就是关闭状态了 break; case CLOSING_STATE: //do nothing //已经是关门状态，不能关门 break; case RUNNING_STATE: //do nothing //运行时电梯门是关着的，不能关门 break; case STOPPING_STATE: //do nothing //停止时电梯也是关着的，不能关门 break; &#125; &#125; //执行开门动作 @Override public void open() &#123; switch (this.state) &#123; case OPENING_STATE://门已经开了，不能再开门了 //do nothing break; case CLOSING_STATE://关门状态，门打开: System.out.println(&quot;电梯门打开了。。。&quot;); this.setState(OPENING_STATE); break; case RUNNING_STATE: //do nothing 运行时电梯不能开门 break; case STOPPING_STATE: System.out.println(&quot;电梯门开了。。。&quot;);//电梯停了，可以开门了 this.setState(OPENING_STATE); break; &#125; &#125; //执行运行动作 @Override public void run() &#123; switch (this.state) &#123; case OPENING_STATE://电梯不能开着门就走 //do nothing break; case CLOSING_STATE://门关了，可以运行了 System.out.println(&quot;电梯开始运行了。。。&quot;); this.setState(RUNNING_STATE);//现在是运行状态 break; case RUNNING_STATE: //do nothing 已经是运行状态了 break; case STOPPING_STATE: System.out.println(&quot;电梯开始运行了。。。&quot;); this.setState(RUNNING_STATE); break; &#125; &#125; //执行停止动作 @Override public void stop() &#123; switch (this.state) &#123; case OPENING_STATE: //开门的电梯已经是是停止的了(正常情况下) //do nothing break; case CLOSING_STATE://关门时才可以停止 System.out.println(&quot;电梯停止了。。。&quot;); this.setState(STOPPING_STATE); break; case RUNNING_STATE://运行时当然可以停止了 System.out.println(&quot;电梯停止了。。。&quot;); this.setState(STOPPING_STATE); break; case STOPPING_STATE: //do nothing break; &#125; &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; Lift lift = new Lift(); lift.setState(ILift.STOPPING_STATE);//电梯是停止的 lift.open();//开门 lift.close();//关门 lift.run();//运行 lift.stop();//停止 &#125;&#125; 问题分析： 使用了大量的switch…case这样的判断（if…else也是一样)，使程序的可阅读性变差。 扩展性很差。如果新加了断电的状态，我们需要修改上面判断逻辑 定义： 对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。 6.5.2 结构状态模式包含以下主要角色。 环境（Context）角色：也称为上下文，它定义了客户程序需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。 抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。 具体状态（Concrete State）角色：实现抽象状态所对应的行为。 6.5.3 案例实现对上述电梯的案例使用状态模式进行改进。类图如下： 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201//抽象状态类public abstract class LiftState &#123; //定义一个环境角色，也就是封装状态的变化引起的功能变化 protected Context context; public void setContext(Context context) &#123; this.context = context; &#125; //电梯开门动作 public abstract void open(); //电梯关门动作 public abstract void close(); //电梯运行动作 public abstract void run(); //电梯停止动作 public abstract void stop();&#125;//开启状态public class OpenningState extends LiftState &#123; //开启当然可以关闭了，我就想测试一下电梯门开关功能 @Override public void open() &#123; System.out.println(&quot;电梯门开启...&quot;); &#125; @Override public void close() &#123; //状态修改 super.context.setLiftState(Context.closeingState); //动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作 super.context.getLiftState().close(); &#125; //电梯门不能开着就跑，这里什么也不做 @Override public void run() &#123; //do nothing &#125; //开门状态已经是停止的了 @Override public void stop() &#123; //do nothing &#125;&#125;//运行状态public class RunningState extends LiftState &#123; //运行的时候开电梯门？你疯了！电梯不会给你开的 @Override public void open() &#123; //do nothing &#125; //电梯门关闭？这是肯定了 @Override public void close() &#123;//虽然可以关门，但这个动作不归我执行 //do nothing &#125; //这是在运行状态下要实现的方法 @Override public void run() &#123; System.out.println(&quot;电梯正在运行...&quot;); &#125; //这个事绝对是合理的，光运行不停止还有谁敢做这个电梯？！估计只有上帝了 @Override public void stop() &#123; super.context.setLiftState(Context.stoppingState); super.context.stop(); &#125;&#125;//停止状态public class StoppingState extends LiftState &#123; //停止状态，开门，那是要的！ @Override public void open() &#123; //状态修改 super.context.setLiftState(Context.openningState); //动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作 super.context.getLiftState().open(); &#125; @Override public void close() &#123;//虽然可以关门，但这个动作不归我执行 //状态修改 super.context.setLiftState(Context.closeingState); //动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作 super.context.getLiftState().close(); &#125; //停止状态再跑起来，正常的很 @Override public void run() &#123; //状态修改 super.context.setLiftState(Context.runningState); //动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作 super.context.getLiftState().run(); &#125; //停止状态是怎么发生的呢？当然是停止方法执行了 @Override public void stop() &#123; System.out.println(&quot;电梯停止了...&quot;); &#125;&#125;//关闭状态public class ClosingState extends LiftState &#123; @Override //电梯门关闭，这是关闭状态要实现的动作 public void close() &#123; System.out.println(&quot;电梯门关闭...&quot;); &#125; //电梯门关了再打开，逗你玩呢，那这个允许呀 @Override public void open() &#123; super.context.setLiftState(Context.openningState); super.context.open(); &#125; //电梯门关了就跑，这是再正常不过了 @Override public void run() &#123; super.context.setLiftState(Context.runningState); super.context.run(); &#125; //电梯门关着，我就不按楼层 @Override public void stop() &#123; super.context.setLiftState(Context.stoppingState); super.context.stop(); &#125;&#125;//环境角色public class Context &#123; //定义出所有的电梯状态 public final static OpenningState openningState = new OpenningState();//开门状态，这时候电梯只能关闭 public final static ClosingState closeingState = new ClosingState();//关闭状态，这时候电梯可以运行、停止和开门 public final static RunningState runningState = new RunningState();//运行状态，这时候电梯只能停止 public final static StoppingState stoppingState = new StoppingState();//停止状态，这时候电梯可以开门、运行 //定义一个当前电梯状态 private LiftState liftState; public LiftState getLiftState() &#123; return this.liftState; &#125; public void setLiftState(LiftState liftState) &#123; //当前环境改变 this.liftState = liftState; //把当前的环境通知到各个实现类中 this.liftState.setContext(this); &#125; public void open() &#123; this.liftState.open(); &#125; public void close() &#123; this.liftState.close(); &#125; public void run() &#123; this.liftState.run(); &#125; public void stop() &#123; this.liftState.stop(); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; Context context = new Context(); context.setLiftState(new ClosingState()); context.open(); context.close(); context.run(); context.stop(); &#125;&#125; 6.5.4 优缺点1，优点： 将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 2，缺点： 状态模式的使用必然会增加系统类和对象的个数。 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 状态模式对”开闭原则”的支持并不太好。 6.5.5 使用场景 当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。 一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。 6.6 观察者模式6.6.1 概述定义： 又被称为发布-订阅（Publish&#x2F;Subscribe）模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。 6.6.2 结构在观察者模式中有如下角色： Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。 ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。 Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。 ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。 6.6.3 案例实现【例】微信公众号 在使用微信公众号时，大家都会有这样的体验，当你关注的公众号中有新内容更新的话，它就会推送给关注公众号的微信用户端。我们使用观察者模式来模拟这样的场景，微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了程序猿这个公众号。 类图如下： 代码如下： 定义抽象观察者类，里面定义一个更新的方法 123public interface Observer &#123; void update(String message);&#125; 定义具体观察者类，微信用户是观察者，里面实现了更新的方法 123456789101112public class WeixinUser implements Observer &#123; // 微信用户名 private String name; public WeixinUser(String name) &#123; this.name = name; &#125; @Override public void update(String message) &#123; System.out.println(name + &quot;-&quot; + message); &#125;&#125; 定义抽象主题类，提供了attach、detach、notify三个方法 1234567891011public interface Subject &#123; //增加订阅者 public void attach(Observer observer); //删除订阅者 public void detach(Observer observer); //通知订阅者更新消息 public void notify(String message);&#125; 微信公众号是具体主题（具体被观察者），里面存储了订阅该公众号的微信用户，并实现了抽象主题中的方法 123456789101112131415161718192021public class SubscriptionSubject implements Subject &#123; //储存订阅公众号的微信用户 private List&lt;Observer&gt; weixinUserlist = new ArrayList&lt;Observer&gt;(); @Override public void attach(Observer observer) &#123; weixinUserlist.add(observer); &#125; @Override public void detach(Observer observer) &#123; weixinUserlist.remove(observer); &#125; @Override public void notify(String message) &#123; for (Observer observer : weixinUserlist) &#123; observer.update(message); &#125; &#125;&#125; 客户端程序 12345678910111213141516public class Client &#123; public static void main(String[] args) &#123; SubscriptionSubject mSubscriptionSubject=new SubscriptionSubject(); //创建微信用户 WeixinUser user1=new WeixinUser(&quot;孙悟空&quot;); WeixinUser user2=new WeixinUser(&quot;猪悟能&quot;); WeixinUser user3=new WeixinUser(&quot;沙悟净&quot;); //订阅公众号 mSubscriptionSubject.attach(user1); mSubscriptionSubject.attach(user2); mSubscriptionSubject.attach(user3); //公众号更新发出消息给订阅的微信用户 mSubscriptionSubject.notify(&quot;传智黑马的专栏更新了&quot;); &#125;&#125; 6.6.4 优缺点1，优点： 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。 被观察者发送通知，所有注册的观察者都会收到信息【可以实现广播机制】 2，缺点： 如果观察者非常多的话，那么所有的观察者收到被观察者发送的通知会耗时 如果被观察者有循环依赖的话，那么被观察者发送通知会使观察者循环调用，会导致系统崩溃 6.6.5 使用场景 对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。 当一个抽象模型有两个方面，其中一个方面依赖于另一方面时。 6.6.6 JDK中提供的实现在 Java 中，通过 java.util.Observable 类和 java.util.Observer 接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例。 1，Observable类 Observable 类是抽象目标类（被观察者），它有一个 Vector 集合成员变量，用于保存所有要通知的观察者对象，下面来介绍它最重要的 3 个方法。 void addObserver(Observer o) 方法：用于将新的观察者对象添加到集合中。 void notifyObservers(Object arg) 方法：调用集合中的所有观察者对象的 update方法，通知它们数据发生改变。通常越晚加入集合的观察者越先得到通知。 void setChange() 方法：用来设置一个 boolean 类型的内部标志，注明目标对象发生了变化。当它为true时，notifyObservers() 才会通知观察者。 2，Observer 接口 Observer 接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用 update 方法，进行相应的工作。 【例】警察抓小偷 警察抓小偷也可以使用观察者模式来实现，警察是观察者，小偷是被观察者。代码如下： 小偷是一个被观察者，所以需要继承Observable类 1234567891011121314151617181920212223public class Thief extends Observable &#123; private String name; public Thief(String name) &#123; this.name = name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void steal() &#123; System.out.println(&quot;小偷：我偷东西了，有没有人来抓我！！！&quot;); super.setChanged(); //changed = true super.notifyObservers(); &#125;&#125; 警察是一个观察者，所以需要让其实现Observer接口 1234567891011121314151617181920public class Policemen implements Observer &#123; private String name; public Policemen(String name) &#123; this.name = name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; @Override public void update(Observable o, Object arg) &#123; System.out.println(&quot;警察：&quot; + ((Thief) o).getName() + &quot;，我已经盯你很久了，你可以保持沉默，但你所说的将成为呈堂证供！！！&quot;); &#125;&#125; 客户端代码 123456789101112public class Client &#123; public static void main(String[] args) &#123; //创建小偷对象 Thief t = new Thief(&quot;隔壁老王&quot;); //创建警察对象 Policemen p = new Policemen(&quot;小李&quot;); //让警察盯着小偷 t.addObserver(p); //小偷偷东西 t.steal(); &#125;&#125; 6.7 中介者模式6.7.1 概述一般来说，同事类之间的关系是比较复杂的，多个同事类之间互相关联时，他们之间的关系会呈现为复杂的网状结构，这是一种过度耦合的架构，即不利于类的复用，也不稳定。例如在下左图中，有六个同事类对象，假如对象1发生变化，那么将会有4个对象受到影响。如果对象2发生变化，那么将会有5个对象受到影响。也就是说，同事类之间直接关联的设计是不好的。 如果引入中介者模式，那么同事类之间的关系将变为星型结构，从下右图中可以看到，任何一个类的变动，只会影响的类本身，以及中介者，这样就减小了系统的耦合。一个好的设计，必定不会把所有的对象关系处理逻辑封装在本类中，而是使用一个专门的类来管理那些不属于自己的行为。 定义： 又叫调停模式，定义一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。 6.7.2 结构中介者模式包含以下主要角色： 抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。 具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。 抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。 具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。 6.7.3 案例实现【例】租房 现在租房基本都是通过房屋中介，房主将房屋托管给房屋中介，而租房者从房屋中介获取房屋信息。房屋中介充当租房者与房屋所有者之间的中介者。 类图如下： 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//抽象中介者public abstract class Mediator &#123; //申明一个联络方法 public abstract void constact(String message,Person person);&#125;//抽象同事类public abstract class Person &#123; protected String name; protected Mediator mediator; public Person(String name,Mediator mediator)&#123; this.name = name; this.mediator = mediator; &#125;&#125;//具体同事类 房屋拥有者public class HouseOwner extends Person &#123; public HouseOwner(String name, Mediator mediator) &#123; super(name, mediator); &#125; //与中介者联系 public void constact(String message)&#123; mediator.constact(message, this); &#125; //获取信息 public void getMessage(String message)&#123; System.out.println(&quot;房主&quot; + name +&quot;获取到的信息：&quot; + message); &#125;&#125;//具体同事类 承租人public class Tenant extends Person &#123; public Tenant(String name, Mediator mediator) &#123; super(name, mediator); &#125; //与中介者联系 public void constact(String message)&#123; mediator.constact(message, this); &#125; //获取信息 public void getMessage(String message)&#123; System.out.println(&quot;租房者&quot; + name +&quot;获取到的信息：&quot; + message); &#125;&#125;//中介机构public class MediatorStructure extends Mediator &#123; //首先中介结构必须知道所有房主和租房者的信息 private HouseOwner houseOwner; private Tenant tenant; public HouseOwner getHouseOwner() &#123; return houseOwner; &#125; public void setHouseOwner(HouseOwner houseOwner) &#123; this.houseOwner = houseOwner; &#125; public Tenant getTenant() &#123; return tenant; &#125; public void setTenant(Tenant tenant) &#123; this.tenant = tenant; &#125; public void constact(String message, Person person) &#123; if (person == houseOwner) &#123; //如果是房主，则租房者获得信息 tenant.getMessage(message); &#125; else &#123; //反正则是房主获得信息 houseOwner.getMessage(message); &#125; &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; //一个房主、一个租房者、一个中介机构 MediatorStructure mediator = new MediatorStructure(); //房主和租房者只需要知道中介机构即可 HouseOwner houseOwner = new HouseOwner(&quot;张三&quot;, mediator); Tenant tenant = new Tenant(&quot;李四&quot;, mediator); //中介结构要知道房主和租房者 mediator.setHouseOwner(houseOwner); mediator.setTenant(tenant); tenant.constact(&quot;需要租三室的房子&quot;); houseOwner.constact(&quot;我这有三室的房子，你需要租吗？&quot;); &#125;&#125; 6.7.4 优缺点1，优点： 松散耦合 中介者模式通过把多个同事对象之间的交互封装到中介者对象里面，从而使得同事对象之间松散耦合，基本上可以做到互补依赖。这样一来，同事对象就可以独立地变化和复用，而不再像以前那样“牵一处而动全身”了。 集中控制交互 多个同事对象的交互，被封装在中介者对象里面集中管理，使得这些交互行为发生变化的时候，只需要修改中介者对象就可以了，当然如果是已经做好的系统，那么就扩展中介者对象，而各个同事类不需要做修改。 一对多关联转变为一对一的关联 没有使用中介者模式的时候，同事对象之间的关系通常是一对多的，引入中介者对象以后，中介者对象和同事对象的关系通常变成双向的一对一，这会让对象的关系更容易理解和实现。 2，缺点： 当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。 6.7.5 使用场景 系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。 当想创建一个运行于多个类之间的对象，又不想生成新的子类时。 6.8 迭代器模式6.8.1 概述定义： 提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 6.8.2 结构迭代器模式主要包含以下角色： 抽象聚合（Aggregate）角色：定义存储、添加、删除聚合元素以及创建迭代器对象的接口。 具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。 抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、next() 等方法。 具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。 6.8.3 案例实现【例】定义一个可以存储学生对象的容器对象，将遍历该容器的功能交由迭代器实现，涉及到的类如下： 代码如下： 定义迭代器接口，声明hasNext、next方法 1234public interface StudentIterator &#123; boolean hasNext(); Student next();&#125; 定义具体的迭代器类，重写所有的抽象方法 1234567891011121314151617181920public class StudentIteratorImpl implements StudentIterator &#123; private List&lt;Student&gt; list; private int position = 0; public StudentIteratorImpl(List&lt;Student&gt; list) &#123; this.list = list; &#125; @Override public boolean hasNext() &#123; return position &lt; list.size(); &#125; @Override public Student next() &#123; Student currentStudent = list.get(position); position ++; return currentStudent; &#125;&#125; 定义抽象容器类，包含添加元素，删除元素，获取迭代器对象的方法 1234567public interface StudentAggregate &#123; void addStudent(Student student); void removeStudent(Student student); StudentIterator getStudentIterator();&#125; 定义具体的容器类，重写所有的方法 12345678910111213141516171819public class StudentAggregateImpl implements StudentAggregate &#123; private List&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); // 学生列表 @Override public void addStudent(Student student) &#123; this.list.add(student); &#125; @Override public void removeStudent(Student student) &#123; this.list.remove(student); &#125; @Override public StudentIterator getStudentIterator() &#123; return new StudentIteratorImpl(list); &#125;&#125; 6.8.4 优缺点1，优点： 它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。 迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。 在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足 “开闭原则” 的要求。 2，缺点： 增加了类的个数，这在一定程度上增加了系统的复杂性。 6.8.5 使用场景 当需要为聚合对象提供多种遍历方式时。 当需要为遍历不同的聚合结构提供一个统一的接口时。 当访问一个聚合对象的内容而无须暴露其内部细节的表示时。 6.8.6 JDK源码解析迭代器模式在JAVA的很多集合类中被广泛应用，接下来看看JAVA源码中是如何使用迭代器模式的。 12345List&lt;String&gt; list = new ArrayList&lt;&gt;();Iterator&lt;String&gt; iterator = list.iterator(); //list.iterator()方法返回的肯定是Iterator接口的子实现类对象while (iterator.hasNext()) &#123; System.out.println(iterator.next());&#125; 看完这段代码是不是很熟悉，与我们上面代码基本类似。单列集合都使用到了迭代器，我们以ArrayList举例来说明 List：抽象聚合类 ArrayList：具体的聚合类 Iterator：抽象迭代器 list.iterator()：返回的是实现了 Iterator 接口的具体迭代器对象 具体的来看看 ArrayList的代码实现 123456789101112131415161718192021222324252627282930313233public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // 下一个要返回元素的索引 int lastRet = -1; // 上一个返回元素的索引 int expectedModCount = modCount; Itr() &#123;&#125; //判断是否还有元素 public boolean hasNext() &#123; return cursor != size; &#125; //获取下一个元素 public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; ...&#125; 这部分代码还是比较简单，大致就是在 iterator 方法中返回了一个实例化的 Iterator 对象。Itr是一个内部类，它实现了 Iterator 接口并重写了其中的抽象方法。 注意： ​ 当我们在使用JAVA开发的时候，想使用迭代器模式的话，只要让我们自己定义的容器类实现java.util.Iterable并实现其中的iterator()方法使其返回一个 java.util.Iterator 的实现类就可以了。 6.9 访问者模式6.9.1 概述定义： 封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。 6.9.2 结构访问者模式包含以下主要角色: 抽象访问者（Visitor）角色：定义了对每一个元素（Element）访问的行为，它的参数就是可以访问的元素，它的方法个数理论上来讲与元素类个数（Element的实现类个数）是一样的，从这点不难看出，访问者模式要求元素类的个数不能改变。 具体访问者（ConcreteVisitor）角色：给出对每一个元素类访问时所产生的具体行为。 抽象元素（Element）角色：定义了一个接受访问者的方法（accept），其意义是指，每一个元素都要可以被访问者访问。 具体元素（ConcreteElement）角色： 提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。 对象结构（Object Structure）角色：定义当中所提到的对象结构，对象结构是一个抽象表述，具体点可以理解为一个具有容器性质或者复合对象特性的类，它会含有一组元素（Element），并且可以迭代这些元素，供访问者访问。 6.9.3 案例实现【例】给宠物喂食 现在养宠物的人特别多，我们就以这个为例，当然宠物还分为狗，猫等，要给宠物喂食的话，主人可以喂，其他人也可以喂食。 访问者角色：给宠物喂食的人 具体访问者角色：主人、其他人 抽象元素角色：动物抽象类 具体元素角色：宠物狗、宠物猫 结构对象角色：主人家 类图如下： 代码如下： 创建抽象访问者接口 12345public interface Person &#123; void feed(Cat cat); void feed(Dog dog);&#125; 创建不同的具体访问者角色（主人和其他人），都需要实现 Person接口 123456789101112131415161718192021222324public class Owner implements Person &#123; @Override public void feed(Cat cat) &#123; System.out.println(&quot;主人喂食猫&quot;); &#125; @Override public void feed(Dog dog) &#123; System.out.println(&quot;主人喂食狗&quot;); &#125;&#125;public class Someone implements Person &#123; @Override public void feed(Cat cat) &#123; System.out.println(&quot;其他人喂食猫&quot;); &#125; @Override public void feed(Dog dog) &#123; System.out.println(&quot;其他人喂食狗&quot;); &#125;&#125; 定义抽象节点 – 宠物 123public interface Animal &#123; void accept(Person person);&#125; 定义实现Animal接口的 具体节点（元素） 1234567891011121314151617public class Dog implements Animal &#123; @Override public void accept(Person person) &#123; person.feed(this); System.out.println(&quot;好好吃，汪汪汪！！！&quot;); &#125;&#125;public class Cat implements Animal &#123; @Override public void accept(Person person) &#123; person.feed(this); System.out.println(&quot;好好吃，喵喵喵！！！&quot;); &#125;&#125; 定义对象结构，此案例中就是主人的家 123456789101112131415public class Home &#123; private List&lt;Animal&gt; nodeList = new ArrayList&lt;Animal&gt;(); public void action(Person person) &#123; for (Animal node : nodeList) &#123; node.accept(person); &#125; &#125; //添加操作 public void add(Animal animal) &#123; nodeList.add(animal); &#125;&#125; 测试类 12345678910111213public class Client &#123; public static void main(String[] args) &#123; Home home = new Home(); home.add(new Dog()); home.add(new Cat()); Owner owner = new Owner(); home.action(owner); Someone someone = new Someone(); home.action(someone); &#125;&#125; 6.9.4 优缺点1，优点： 扩展性好 在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。 复用性好 通过访问者来定义整个对象结构通用的功能，从而提高复用程度。 分离无关行为 通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。 2，缺点： 对象结构变化很困难 在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。 违反了依赖倒置原则 访问者模式依赖了具体类，而没有依赖抽象类。 6.9.5 使用场景 对象结构相对稳定，但其操作算法经常变化的程序。 对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。 6.9.6 扩展访问者模式用到了一种双分派的技术。 1，分派： 变量被声明时的类型叫做变量的静态类型，有些人又把静态类型叫做明显类型；而变量所引用的对象的真实类型又叫做变量的实际类型。比如 Map map = new HashMap() ，map变量的静态类型是 Map ，实际类型是 HashMap 。根据对象的类型而对方法进行的选择，就是分派(Dispatch)，分派(Dispatch)又分为两种，即静态分派和动态分派。 静态分派(Static Dispatch) 发生在编译时期，分派根据静态类型信息发生。静态分派对于我们来说并不陌生，方法重载就是静态分派。 动态分派(Dynamic Dispatch) 发生在运行时期，动态分派动态地置换掉某个方法。Java通过方法的重写支持动态分派。 2，动态分派： 通过方法的重写支持动态分派。 1234567891011121314151617181920212223242526272829public class Animal &#123; public void execute() &#123; System.out.println(&quot;Animal&quot;); &#125;&#125;public class Dog extends Animal &#123; @Override public void execute() &#123; System.out.println(&quot;dog&quot;); &#125;&#125;public class Cat extends Animal &#123; @Override public void execute() &#123; System.out.println(&quot;cat&quot;); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; Animal a = new Dog(); a.execute(); Animal a1 = new Cat(); a1.execute(); &#125;&#125; 上面代码的结果大家应该直接可以说出来，这不就是多态吗！运行执行的是子类中的方法。 Java编译器在编译时期并不总是知道哪些代码会被执行，因为编译器仅仅知道对象的静态类型，而不知道对象的真实类型；而方法的调用则是根据对象的真实类型，而不是静态类型。 3，静态分派： 通过方法重载支持静态分派。 1234567891011121314151617181920212223242526272829303132333435public class Animal &#123;&#125;public class Dog extends Animal &#123;&#125;public class Cat extends Animal &#123;&#125;public class Execute &#123; public void execute(Animal a) &#123; System.out.println(&quot;Animal&quot;); &#125; public void execute(Dog d) &#123; System.out.println(&quot;dog&quot;); &#125; public void execute(Cat c) &#123; System.out.println(&quot;cat&quot;); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; Animal a = new Animal(); Animal a1 = new Dog(); Animal a2 = new Cat(); Execute exe = new Execute(); exe.execute(a); exe.execute(a1); exe.execute(a2); &#125;&#125; 运行结果： 这个结果可能出乎一些人的意料了，为什么呢？ 重载方法的分派是根据静态类型进行的，这个分派过程在编译时期就完成了。 4，双分派： 所谓双分派技术就是在选择一个方法的时候，不仅仅要根据消息接收者（receiver）的运行时区别，还要根据参数的运行时区别。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Animal &#123; public void accept(Execute exe) &#123; exe.execute(this); &#125;&#125;public class Dog extends Animal &#123; public void accept(Execute exe) &#123; exe.execute(this); &#125;&#125;public class Cat extends Animal &#123; public void accept(Execute exe) &#123; exe.execute(this); &#125;&#125;public class Execute &#123; public void execute(Animal a) &#123; System.out.println(&quot;animal&quot;); &#125; public void execute(Dog d) &#123; System.out.println(&quot;dog&quot;); &#125; public void execute(Cat c) &#123; System.out.println(&quot;cat&quot;); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; Animal a = new Animal(); Animal d = new Dog(); Animal c = new Cat(); Execute exe = new Execute(); a.accept(exe); d.accept(exe); c.accept(exe); &#125;&#125; 在上面代码中，客户端将Execute对象做为参数传递给Animal类型的变量调用的方法，这里完成第一次分派，这里是方法重写，所以是动态分派，也就是执行实际类型中的方法，同时也将自己this作为参数传递进去，这里就完成了第二次分派，这里的Execute类中有多个重载的方法，而传递进行的是this，就是具体的实际类型的对象。 说到这里，我们已经明白双分派是怎么回事了，但是它有什么效果呢？就是可以实现方法的动态绑定，我们可以对上面的程序进行修改。 运行结果如下： 双分派实现动态绑定的本质，就是在重载方法委派的前面加上了继承体系中覆盖的环节，由于覆盖是动态的，所以重载就是动态的了。 6.10 备忘录模式6.10.1 概述备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原，很多软件都提供了撤销（Undo）操作，如 Word、记事本、Photoshop、IDEA等软件在编辑时按 Ctrl+Z 组合键时能撤销当前操作，使文档恢复到之前的状态；还有在 浏览器 中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。 定义： 又叫快照模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。 6.10.2 结构备忘录模式的主要角色如下： 发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。 备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。 管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。 备忘录有两个等效的接口： 窄接口：管理者(Caretaker)对象（和其他发起人对象之外的任何对象）看到的是备忘录的窄接口(narror Interface)，这个窄接口只允许他把备忘录对象传给其他的对象。 宽接口：与管理者看到的窄接口相反，发起人对象可以看到一个宽接口(wide Interface)，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态。 6.10.3 案例实现【例】游戏挑战BOSS 游戏中的某个场景，一游戏角色有生命力、攻击力、防御力等数据，在打Boss前和后一定会不一样的，我们允许玩家如果感觉与Boss决斗的效果不理想可以让游戏恢复到决斗之前的状态。 要实现上述案例，有两种方式： “白箱”备忘录模式 “黑箱”备忘录模式 6.10.3.1 “白箱”备忘录模式备忘录角色对任何对象都提供一个接口，即宽接口，备忘录角色的内部所存储的状态就对所有对象公开。类图如下： 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137//游戏角色类public class GameRole &#123; private int vit; //生命力 private int atk; //攻击力 private int def; //防御力 //初始化状态 public void initState() &#123; this.vit = 100; this.atk = 100; this.def = 100; &#125; //战斗 public void fight() &#123; this.vit = 0; this.atk = 0; this.def = 0; &#125; //保存角色状态 public RoleStateMemento saveState() &#123; return new RoleStateMemento(vit, atk, def); &#125; //回复角色状态 public void recoverState(RoleStateMemento roleStateMemento) &#123; this.vit = roleStateMemento.getVit(); this.atk = roleStateMemento.getAtk(); this.def = roleStateMemento.getDef(); &#125; public void stateDisplay() &#123; System.out.println(&quot;角色生命力：&quot; + vit); System.out.println(&quot;角色攻击力：&quot; + atk); System.out.println(&quot;角色防御力：&quot; + def); &#125; public int getVit() &#123; return vit; &#125; public void setVit(int vit) &#123; this.vit = vit; &#125; public int getAtk() &#123; return atk; &#125; public void setAtk(int atk) &#123; this.atk = atk; &#125; public int getDef() &#123; return def; &#125; public void setDef(int def) &#123; this.def = def; &#125;&#125;//游戏状态存储类(备忘录类)public class RoleStateMemento &#123; private int vit; private int atk; private int def; public RoleStateMemento(int vit, int atk, int def) &#123; this.vit = vit; this.atk = atk; this.def = def; &#125; public int getVit() &#123; return vit; &#125; public void setVit(int vit) &#123; this.vit = vit; &#125; public int getAtk() &#123; return atk; &#125; public void setAtk(int atk) &#123; this.atk = atk; &#125; public int getDef() &#123; return def; &#125; public void setDef(int def) &#123; this.def = def; &#125;&#125;//角色状态管理者类public class RoleStateCaretaker &#123; private RoleStateMemento roleStateMemento; public RoleStateMemento getRoleStateMemento() &#123; return roleStateMemento; &#125; public void setRoleStateMemento(RoleStateMemento roleStateMemento) &#123; this.roleStateMemento = roleStateMemento; &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; System.out.println(&quot;------------大战Boss前------------&quot;); //大战Boss前 GameRole gameRole = new GameRole(); gameRole.initState(); gameRole.stateDisplay(); //保存进度 RoleStateCaretaker roleStateCaretaker = new RoleStateCaretaker(); roleStateCaretaker.setRoleStateMemento(gameRole.saveState()); System.out.println(&quot;------------大战Boss后------------&quot;); //大战Boss时，损耗严重 gameRole.fight(); gameRole.stateDisplay(); System.out.println(&quot;------------恢复之前状态------------&quot;); //恢复之前状态 gameRole.recoverState(roleStateCaretaker.getRoleStateMemento()); gameRole.stateDisplay(); &#125;&#125; 分析：白箱备忘录模式是破坏封装性的。但是通过程序员自律，同样可以在一定程度上实现模式的大部分用意。 6.10.3.2 “黑箱”备忘录模式备忘录角色对发起人对象提供一个宽接口，而为其他对象提供一个窄接口。在Java语言中，实现双重接口的办法就是将备忘录类设计成发起人类的内部成员类。 将 RoleStateMemento 设为 GameRole 的内部类，从而将 RoleStateMemento 对象封装在 GameRole 里面；在外面提供一个标识接口 Memento 给 RoleStateCaretaker 及其他对象使用。这样 GameRole 类看到的是 RoleStateMemento 所有的接口，而RoleStateCaretaker 及其他对象看到的仅仅是标识接口 Memento 所暴露出来的接口，从而维护了封装型。类图如下： 代码如下： 窄接口Memento，这是一个标识接口，因此没有定义出任何的方法 12public interface Memento &#123;&#125; 定义发起人类 GameRole，并在内部定义备忘录内部类 RoleStateMemento（该内部类设置为私有的） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/游戏角色类public class GameRole &#123; private int vit; //生命力 private int atk; //攻击力 private int def; //防御力 //初始化状态 public void initState() &#123; this.vit = 100; this.atk = 100; this.def = 100; &#125; //战斗 public void fight() &#123; this.vit = 0; this.atk = 0; this.def = 0; &#125; //保存角色状态 public Memento saveState() &#123; return new RoleStateMemento(vit, atk, def); &#125; //回复角色状态 public void recoverState(Memento memento) &#123; RoleStateMemento roleStateMemento = (RoleStateMemento) memento; this.vit = roleStateMemento.getVit(); this.atk = roleStateMemento.getAtk(); this.def = roleStateMemento.getDef(); &#125; public void stateDisplay() &#123; System.out.println(&quot;角色生命力：&quot; + vit); System.out.println(&quot;角色攻击力：&quot; + atk); System.out.println(&quot;角色防御力：&quot; + def); &#125; public int getVit() &#123; return vit; &#125; public void setVit(int vit) &#123; this.vit = vit; &#125; public int getAtk() &#123; return atk; &#125; public void setAtk(int atk) &#123; this.atk = atk; &#125; public int getDef() &#123; return def; &#125; public void setDef(int def) &#123; this.def = def; &#125; private class RoleStateMemento implements Memento &#123; private int vit; private int atk; private int def; public RoleStateMemento(int vit, int atk, int def) &#123; this.vit = vit; this.atk = atk; this.def = def; &#125; public int getVit() &#123; return vit; &#125; public void setVit(int vit) &#123; this.vit = vit; &#125; public int getAtk() &#123; return atk; &#125; public void setAtk(int atk) &#123; this.atk = atk; &#125; public int getDef() &#123; return def; &#125; public void setDef(int def) &#123; this.def = def; &#125; &#125;&#125; 负责人角色类 RoleStateCaretaker 能够得到的备忘录对象是以 Memento 为接口的，由于这个接口仅仅是一个标识接口，因此负责人角色不可能改变这个备忘录对象的内容 123456789101112//角色状态管理者类public class RoleStateCaretaker &#123; private Memento memento; public Memento getMemento() &#123; return memento; &#125; public void setMemento(Memento memento) &#123; this.memento = memento; &#125;&#125; 客户端测试类 1234567891011121314151617181920212223public class Client &#123; public static void main(String[] args) &#123; System.out.println(&quot;------------大战Boss前------------&quot;); //大战Boss前 GameRole gameRole = new GameRole(); gameRole.initState(); gameRole.stateDisplay(); //保存进度 RoleStateCaretaker roleStateCaretaker = new RoleStateCaretaker(); roleStateCaretaker.setMemento(gameRole.saveState()); System.out.println(&quot;------------大战Boss后------------&quot;); //大战Boss时，损耗严重 gameRole.fight(); gameRole.stateDisplay(); System.out.println(&quot;------------恢复之前状态------------&quot;); //恢复之前状态 gameRole.recoverState(roleStateCaretaker.getMemento()); gameRole.stateDisplay(); &#125;&#125; 6.10.4 优缺点1，优点： 提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。 实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。 简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。 2，缺点： 资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。 6.10.5 使用场景 需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。 需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，idea等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式（四）","slug":"设计模式/设计模式（四）","date":"2023-06-16T05:59:00.000Z","updated":"2023-06-16T05:59:46.592Z","comments":true,"path":"2023/06/16/设计模式/设计模式（四）/","link":"","permalink":"http://example.com/2023/06/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"","text":"5，结构型模式5.6 组合模式5.6.1 概述 ​ 对于这个图片肯定会非常熟悉，上图我们可以看做是一个文件系统，对于这样的结构我们称之为树形结构。在树形结构中可以通过调用某个方法来遍历整个树，当我们找到某个叶子节点后，就可以对叶子节点进行相关的操作。可以将这颗树理解成一个大的容器，容器里面包含很多的成员对象，这些成员对象即可是容器对象也可以是叶子对象。但是由于容器对象和叶子对象在功能上面的区别，使得我们在使用的过程中必须要区分容器对象和叶子对象，但是这样就会给客户带来不必要的麻烦，作为客户而已，它始终希望能够一致的对待容器对象和叶子对象。 定义： ​ 又名部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。 5.6.2 结构组合模式主要包含三种角色： 抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。 树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。 叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。 5.6.3 案例实现【例】软件菜单 如下图，我们在访问别的一些管理系统时，经常可以看到类似的菜单。一个菜单可以包含菜单项（菜单项是指不再包含其他内容的菜单条目），也可以包含带有其他菜单项的菜单，因此使用组合模式描述菜单就很恰当，我们的需求是针对一个菜单，打印出其包含的所有菜单以及菜单项的名称。 要实现该案例，我们先画出类图： 代码实现： 不管是菜单还是菜单项，都应该继承自统一的接口，这里姑且将这个统一的接口称为菜单组件。 123456789101112131415161718192021222324252627282930//菜单组件 不管是菜单还是菜单项，都应该继承该类public abstract class MenuComponent &#123; protected String name; protected int level; //添加菜单 public void add(MenuComponent menuComponent)&#123; throw new UnsupportedOperationException(); &#125; //移除菜单 public void remove(MenuComponent menuComponent)&#123; throw new UnsupportedOperationException(); &#125; //获取指定的子菜单 public MenuComponent getChild(int i)&#123; throw new UnsupportedOperationException(); &#125; //获取菜单名称 public String getName()&#123; return name; &#125; public void print()&#123; throw new UnsupportedOperationException(); &#125;&#125; 这里的MenuComponent定义为抽象类，因为有一些共有的属性和行为要在该类中实现，Menu和MenuItem类就可以只覆盖自己感兴趣的方法，而不用搭理不需要或者不感兴趣的方法，举例来说，Menu类可以包含子菜单，因此需要覆盖add()、remove()、getChild()方法，但是MenuItem就不应该有这些方法。这里给出的默认实现是抛出异常，你也可以根据自己的需要改写默认实现。 12345678910111213141516171819202122232425262728293031323334353637public class Menu extends MenuComponent &#123; private List&lt;MenuComponent&gt; menuComponentList; public Menu(String name,int level)&#123; this.level = level; this.name = name; menuComponentList = new ArrayList&lt;MenuComponent&gt;(); &#125; @Override public void add(MenuComponent menuComponent) &#123; menuComponentList.add(menuComponent); &#125; @Override public void remove(MenuComponent menuComponent) &#123; menuComponentList.remove(menuComponent); &#125; @Override public MenuComponent getChild(int i) &#123; return menuComponentList.get(i); &#125; @Override public void print() &#123; for (int i = 1; i &lt; level; i++) &#123; System.out.print(&quot;--&quot;); &#125; System.out.println(name); for (MenuComponent menuComponent : menuComponentList) &#123; menuComponent.print(); &#125; &#125;&#125; Menu类已经实现了除了getName方法的其他所有方法，因为Menu类具有添加菜单，移除菜单和获取子菜单的功能。 123456789101112131415public class MenuItem extends MenuComponent &#123; public MenuItem(String name,int level) &#123; this.name = name; this.level = level; &#125; @Override public void print() &#123; for (int i = 1; i &lt; level; i++) &#123; System.out.print(&quot;--&quot;); &#125; System.out.println(name); &#125;&#125; MenuItem是菜单项，不能再有子菜单，所以添加菜单，移除菜单和获取子菜单的功能并不能实现。 5.6.4 组合模式的分类在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式。 透明组合模式 透明组合模式中，抽象根节点角色中声明了所有用于管理成员对象的方法，比如在示例中 MenuComponent 声明了 add、remove 、getChild 方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的标准形式。 透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 add()、remove() 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码） 安全组合模式 在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在树枝节点 Menu 类中声明并实现这些方法。安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。 5.6.5 优点 组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。 在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭原则”。 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。 5.6.6 使用场景组合模式正是应树形结构而生，所以组合模式的使用场景就是出现树形结构的地方。比如：文件目录显示，多级目录呈现等树形结构数据的操作。 5.7 享元模式5.7.1 概述定义： ​ 运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。 5.7.2 结构享元（Flyweight ）模式中存在以下两种状态： 内部状态，即不会随着环境的改变而改变的可共享部分。 外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。 享元模式的主要有以下角色： 抽象享元角色（Flyweight）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。 具体享元（Concrete Flyweight）角色 ：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。 非享元（Unsharable Flyweight)角色 ：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。 享元工厂（Flyweight Factory）角色 ：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。 5.7.3 案例实现【例】俄罗斯方块 下面的图片是众所周知的俄罗斯方块中的一个个方块，如果在俄罗斯方块这个游戏中，每个不同的方块都是一个实例对象，这些对象就要占用很多的内存空间，下面利用享元模式进行实现。 先来看类图： 代码如下： 俄罗斯方块有不同的形状，我们可以对这些形状向上抽取出AbstractBox，用来定义共性的属性和行为。 1234567public abstract class AbstractBox &#123; public abstract String getShape(); public void display(String color) &#123; System.out.println(&quot;方块形状：&quot; + this.getShape() + &quot; 颜色：&quot; + color); &#125;&#125; 接下来就是定义不同的形状了，IBox类、LBox类、OBox类等。 1234567891011121314151617181920212223public class IBox extends AbstractBox &#123; @Override public String getShape() &#123; return &quot;I&quot;; &#125;&#125;public class LBox extends AbstractBox &#123; @Override public String getShape() &#123; return &quot;L&quot;; &#125;&#125;public class OBox extends AbstractBox &#123; @Override public String getShape() &#123; return &quot;O&quot;; &#125;&#125; 提供了一个工厂类（BoxFactory），用来管理享元对象（也就是AbstractBox子类对象），该工厂类对象只需要一个，所以可以使用单例模式。并给工厂类提供一个获取形状的方法。 1234567891011121314151617181920212223242526public class BoxFactory &#123; private static HashMap&lt;String, AbstractBox&gt; map; private BoxFactory() &#123; map = new HashMap&lt;String, AbstractBox&gt;(); AbstractBox iBox = new IBox(); AbstractBox lBox = new LBox(); AbstractBox oBox = new OBox(); map.put(&quot;I&quot;, iBox); map.put(&quot;L&quot;, lBox); map.put(&quot;O&quot;, oBox); &#125; public static final BoxFactory getInstance() &#123; return SingletonHolder.INSTANCE; &#125; private static class SingletonHolder &#123; private static final BoxFactory INSTANCE = new BoxFactory(); &#125; public AbstractBox getBox(String key) &#123; return map.get(key); &#125;&#125; 5.7.5 优缺点和使用场景1，优点 极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能 享元模式中的外部状态相对独立，且不影响内部状态 2，缺点： 为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部状态和外部状态，使程序逻辑复杂 3，使用场景： 一个系统有大量相同或者相似的对象，造成内存的大量耗费。 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。 在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。 5.7.6 JDK源码解析Integer类使用了享元模式。我们先看下面的例子： 12345678910111213public class Demo &#123; public static void main(String[] args) &#123; Integer i1 = 127; Integer i2 = 127; System.out.println(&quot;i1和i2对象是否是同一个对象？&quot; + (i1 == i2)); Integer i3 = 128; Integer i4 = 128; System.out.println(&quot;i3和i4对象是否是同一个对象？&quot; + (i3 == i4)); &#125;&#125; 运行上面代码，结果如下： 为什么第一个输出语句输出的是true，第二个输出语句输出的是false？通过反编译软件进行反编译，代码如下： 12345678910public class Demo &#123; public static void main(String[] args) &#123; Integer i1 = Integer.valueOf((int)127); Integer i2 Integer.valueOf((int)127); System.out.println((String)new StringBuilder().append((String)&quot;i1\\u548ci2\\u5bf9\\u8c61\\u662f\\u5426\\u662f\\u540c\\u4e00\\u4e2a\\u5bf9\\u8c61\\uff1f&quot;).append((boolean)(i1 == i2)).toString()); Integer i3 = Integer.valueOf((int)128); Integer i4 = Integer.valueOf((int)128); System.out.println((String)new StringBuilder().append((String)&quot;i3\\u548ci4\\u5bf9\\u8c61\\u662f\\u5426\\u662f\\u540c\\u4e00\\u4e2a\\u5bf9\\u8c61\\uff1f&quot;).append((boolean)(i3 == i4)).toString()); &#125;&#125; 上面代码可以看到，直接给Integer类型的变量赋值基本数据类型数据的操作底层使用的是 valueOf() ，所以只需要看该方法即可 1234567891011121314151617181920212223242526272829303132333435363738public final class Integer extends Number implements Comparable&lt;Integer&gt; &#123; public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125; &#125;&#125; 可以看到 Integer 默认先创建并缓存 -128 ~ 127 之间数的 Integer 对象，当调用 valueOf 时如果参数在 -128 ~ 127 之间则计算下标并从缓存中返回，否则创建一个新的 Integer 对象。 6，行为型模式行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。 行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。 行为型模式分为： 模板方法模式 策略模式 命令模式 职责链模式 状态模式 观察者模式 中介者模式 迭代器模式 访问者模式 备忘录模式 解释器模式 以上 11 种行为型模式，除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式。 6.1 模板方法模式6.1.1 概述在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。 例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。 定义： 定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。 6.1.2 结构模板方法（Template Method）模式包含以下主要角色： 抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。 基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种： 抽象方法(Abstract Method) ：一个抽象方法由抽象类声明、由其具体子类实现。 具体方法(Concrete Method) ：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。 钩子方法(Hook Method) ：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。 一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型。 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。 6.1.3 案例实现【例】炒菜 炒菜的步骤是固定的，分为倒油、热油、倒蔬菜、倒调料品、翻炒等步骤。现通过模板方法模式来用代码模拟。类图如下： 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public abstract class AbstractClass &#123; public final void cookProcess() &#123; //第一步：倒油 this.pourOil(); //第二步：热油 this.heatOil(); //第三步：倒蔬菜 this.pourVegetable(); //第四步：倒调味料 this.pourSauce(); //第五步：翻炒 this.fry(); &#125; public void pourOil() &#123; System.out.println(&quot;倒油&quot;); &#125; //第二步：热油是一样的，所以直接实现 public void heatOil() &#123; System.out.println(&quot;热油&quot;); &#125; //第三步：倒蔬菜是不一样的（一个下包菜，一个是下菜心） public abstract void pourVegetable(); //第四步：倒调味料是不一样 public abstract void pourSauce(); //第五步：翻炒是一样的，所以直接实现 public void fry()&#123; System.out.println(&quot;炒啊炒啊炒到熟啊&quot;); &#125;&#125;public class ConcreteClass_BaoCai extends AbstractClass &#123; @Override public void pourVegetable() &#123; System.out.println(&quot;下锅的蔬菜是包菜&quot;); &#125; @Override public void pourSauce() &#123; System.out.println(&quot;下锅的酱料是辣椒&quot;); &#125;&#125;public class ConcreteClass_CaiXin extends AbstractClass &#123; @Override public void pourVegetable() &#123; System.out.println(&quot;下锅的蔬菜是菜心&quot;); &#125; @Override public void pourSauce() &#123; System.out.println(&quot;下锅的酱料是蒜蓉&quot;); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; //炒手撕包菜 ConcreteClass_BaoCai baoCai = new ConcreteClass_BaoCai(); baoCai.cookProcess(); //炒蒜蓉菜心 ConcreteClass_CaiXin caiXin = new ConcreteClass_CaiXin(); caiXin.cookProcess(); &#125;&#125; 注意：为防止恶意操作，一般模板方法都加上 final 关键词。 6.1.3 优缺点优点： 提高代码复用性 将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。 实现了反向控制 通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”。 缺点： 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。 6.1.4 适用场景 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。 需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。 6.1.5 JDK源码解析InputStream类就使用了模板方法模式。在InputStream类中定义了多个 read() 方法，如下： 12345678910111213141516171819202122232425262728293031323334353637public abstract class InputStream implements Closeable &#123; //抽象方法，要求子类必须重写 public abstract int read() throws IOException; public int read(byte b[]) throws IOException &#123; return read(b, 0, b.length); &#125; public int read(byte b[], int off, int len) throws IOException &#123; if (b == null) &#123; throw new NullPointerException(); &#125; else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) &#123; throw new IndexOutOfBoundsException(); &#125; else if (len == 0) &#123; return 0; &#125; int c = read(); //调用了无参的read方法，该方法是每次读取一个字节数据 if (c == -1) &#123; return -1; &#125; b[off] = (byte)c; int i = 1; try &#123; for (; i &lt; len ; i++) &#123; c = read(); if (c == -1) &#123; break; &#125; b[off + i] = (byte)c; &#125; &#125; catch (IOException ee) &#123; &#125; return i; &#125;&#125; 从上面代码可以看到，无参的 read() 方法是抽象方法，要求子类必须实现。而 read(byte b[]) 方法调用了 read(byte b[], int off, int len) 方法，所以在此处重点看的方法是带三个参数的方法。 在该方法中第18行、27行，可以看到调用了无参的抽象的 read() 方法。 总结如下： 在InputStream父类中已经定义好了读取一个字节数组数据的方法是每次读取一个字节，并将其存储到数组的第一个索引位置，读取len个字节数据。具体如何读取一个字节数据呢？由子类实现。 6.2 策略模式6.2.1 概述先看下面的图片，我们去旅游选择出行模式有很多种，可以骑自行车、可以坐汽车、可以坐火车、可以坐飞机。 作为一个程序猿，开发需要选择一款开发工具，当然可以进行代码开发的工具有很多，可以选择Idea进行开发，也可以使用eclipse进行开发，也可以使用其他的一些开发工具。 定义： ​ 该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。 6.2.2 结构策略模式的主要角色如下： 抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。 具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。 环境（Context）类：持有一个策略类的引用，最终给客户端调用。 6.2.3 案例实现【例】促销活动 一家百货公司在定年度的促销活动。针对不同的节日（春节、中秋节、圣诞节）推出不同的促销活动，由促销员将促销活动展示给客户。类图如下： 代码如下： 定义百货公司所有促销活动的共同接口 123public interface Strategy &#123; void show();&#125; 定义具体策略角色（Concrete Strategy）：每个节日具体的促销活动 1234567891011121314151617181920212223//为春节准备的促销活动Apublic class StrategyA implements Strategy &#123; public void show() &#123; System.out.println(&quot;买一送一&quot;); &#125;&#125;//为中秋准备的促销活动Bpublic class StrategyB implements Strategy &#123; public void show() &#123; System.out.println(&quot;满200元减50元&quot;); &#125;&#125;//为圣诞准备的促销活动Cpublic class StrategyC implements Strategy &#123; public void show() &#123; System.out.println(&quot;满1000元加一元换购任意200元以下商品&quot;); &#125;&#125; 定义环境角色（Context）：用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员 12345678910111213public class SalesMan &#123; //持有抽象策略角色的引用 private Strategy strategy; public SalesMan(Strategy strategy) &#123; this.strategy = strategy; &#125; //向客户展示促销活动 public void salesManShow()&#123; strategy.show(); &#125; &#125; 6.2.4 优缺点1，优点： 策略类之间可以自由切换 由于策略类都实现同一个接口，所以使它们之间可以自由切换。 易于扩展 增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原则“ 避免使用多重条件选择语句（if else），充分体现面向对象设计思想。 2，缺点： 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。 策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。 6.2.5 使用场景 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。 6.2.6 JDK源码解析Comparator 中的策略模式。在Arrays类中有一个 sort() 方法，如下： 123456789101112public class Arrays&#123; public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) &#123; if (c == null) &#123; sort(a); &#125; else &#123; if (LegacyMergeSort.userRequested) legacyMergeSort(a, c); else TimSort.sort(a, 0, a.length, c, null, 0, 0); &#125; &#125;&#125; Arrays就是一个环境角色类，这个sort方法可以传一个新策略让Arrays根据这个策略来进行排序。就比如下面的测试类。 12345678910111213public class demo &#123; public static void main(String[] args) &#123; Integer[] data = &#123;12, 2, 3, 2, 4, 5, 1&#125;; // 实现降序排序 Arrays.sort(data, new Comparator&lt;Integer&gt;() &#123; public int compare(Integer o1, Integer o2) &#123; return o2 - o1; &#125; &#125;); System.out.println(Arrays.toString(data)); //[12, 5, 4, 3, 2, 2, 1] &#125;&#125; 这里我们在调用Arrays的sort方法时，第二个参数传递的是Comparator接口的子实现类对象。所以Comparator充当的是抽象策略角色，而具体的子实现类充当的是具体策略角色。环境角色类（Arrays）应该持有抽象策略的引用来调用。那么，Arrays类的sort方法到底有没有使用Comparator子实现类中的 compare() 方法吗？让我们继续查看TimSort类的 sort() 方法，代码如下： 12345678910111213141516171819202122232425262728293031323334353637class TimSort&lt;T&gt; &#123; static &lt;T&gt; void sort(T[] a, int lo, int hi, Comparator&lt;? super T&gt; c, T[] work, int workBase, int workLen) &#123; assert c != null &amp;&amp; a != null &amp;&amp; lo &gt;= 0 &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length; int nRemaining = hi - lo; if (nRemaining &lt; 2) return; // Arrays of size 0 and 1 are always sorted // If array is small, do a &quot;mini-TimSort&quot; with no merges if (nRemaining &lt; MIN_MERGE) &#123; int initRunLen = countRunAndMakeAscending(a, lo, hi, c); binarySort(a, lo, hi, lo + initRunLen, c); return; &#125; ... &#125; private static &lt;T&gt; int countRunAndMakeAscending(T[] a, int lo, int hi,Comparator&lt;? super T&gt; c) &#123; assert lo &lt; hi; int runHi = lo + 1; if (runHi == hi) return 1; // Find end of run, and reverse range if descending if (c.compare(a[runHi++], a[lo]) &lt; 0) &#123; // Descending while (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - 1]) &lt; 0) runHi++; reverseRange(a, lo, runHi); &#125; else &#123; // Ascending while (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - 1]) &gt;= 0) runHi++; &#125; return runHi - lo; &#125;&#125; 上面的代码中最终会跑到 countRunAndMakeAscending() 这个方法中。我们可以看见，只用了compare方法，所以在调用Arrays.sort方法只传具体compare重写方法的类对象就行，这也是Comparator接口中必须要子类实现的一个方法。 6.3 命令模式6.3.1 概述日常生活中，我们出去吃饭都会遇到下面的场景。 定义： 将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。 6.3.2 结构命令模式包含以下主要角色： 抽象命令类（Command）角色： 定义命令的接口，声明执行的方法。 具体命令（Concrete Command）角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。 实现者&#x2F;接收者（Receiver）角色： 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。 调用者&#x2F;请求者（Invoker）角色： 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。 6.3.3 案例实现将上面的案例用代码实现，那我们就需要分析命令模式的角色在该案例中由谁来充当。 服务员： 就是调用者角色，由她来发起命令。 资深大厨： 就是接收者角色，真正命令执行的对象。 订单： 命令中包含订单。 类图如下： 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116public interface Command &#123; void execute();//只需要定义一个统一的执行方法&#125;public class OrderCommand implements Command &#123; //持有接受者对象 private SeniorChef receiver; private Order order; public OrderCommand(SeniorChef receiver, Order order)&#123; this.receiver = receiver; this.order = order; &#125; public void execute() &#123; System.out.println(order.getDiningTable() + &quot;桌的订单：&quot;); Set&lt;String&gt; keys = order.getFoodDic().keySet(); for (String key : keys) &#123; receiver.makeFood(order.getFoodDic().get(key),key); &#125; try &#123; Thread.sleep(100);//停顿一下 模拟做饭的过程 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(order.getDiningTable() + &quot;桌的饭弄好了&quot;); &#125;&#125;public class Order &#123; // 餐桌号码 private int diningTable; // 用来存储餐名并记录份数 private Map&lt;String, Integer&gt; foodDic = new HashMap&lt;String, Integer&gt;(); public int getDiningTable() &#123; return diningTable; &#125; public void setDiningTable(int diningTable) &#123; this.diningTable = diningTable; &#125; public Map&lt;String, Integer&gt; getFoodDic() &#123; return foodDic; &#125; public void setFoodDic(String name, int num) &#123; foodDic.put(name,num); &#125;&#125;// 资深大厨类 是命令的Receiverpublic class SeniorChef &#123; public void makeFood(int num,String foodName) &#123; System.out.println(num + &quot;份&quot; + foodName); &#125;&#125;public class Waitor &#123; private ArrayList&lt;Command&gt; commands;//可以持有很多的命令对象 public Waitor() &#123; commands = new ArrayList(); &#125; public void setCommand(Command cmd)&#123; commands.add(cmd); &#125; // 发出命令 喊 订单来了，厨师开始执行 public void orderUp() &#123; System.out.println(&quot;美女服务员：叮咚，大厨，新订单来了.......&quot;); for (int i = 0; i &lt; commands.size(); i++) &#123; Command cmd = commands.get(i); if (cmd != null) &#123; cmd.execute(); &#125; &#125; &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; //创建2个order Order order1 = new Order(); order1.setDiningTable(1); order1.getFoodDic().put(&quot;西红柿鸡蛋面&quot;,1); order1.getFoodDic().put(&quot;小杯可乐&quot;,2); Order order2 = new Order(); order2.setDiningTable(3); order2.getFoodDic().put(&quot;尖椒肉丝盖饭&quot;,1); order2.getFoodDic().put(&quot;小杯雪碧&quot;,1); //创建接收者 SeniorChef receiver=new SeniorChef(); //将订单和接收者封装成命令对象 OrderCommand cmd1 = new OrderCommand(receiver, order1); OrderCommand cmd2 = new OrderCommand(receiver, order2); //创建调用者 waitor Waitor invoker = new Waitor(); invoker.setCommand(cmd1); invoker.setCommand(cmd2); //将订单带到柜台 并向厨师喊 订单来了 invoker.orderUp(); &#125;&#125; 6.3.4 优缺点1，优点： 降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。 增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。 可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。 方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。 2，缺点： 使用命令模式可能会导致某些系统有过多的具体命令类。 系统结构更加复杂。 6.3.5 使用场景 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。 系统需要在不同的时间指定请求、将请求排队和执行请求。 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。 6.3.6 JDK源码解析Runable是一个典型命令模式，Runnable担当命令的角色，Thread充当的是调用者，start方法就是其执行方法 12345678910111213141516171819202122232425262728293031//命令接口(抽象命令角色)public interface Runnable &#123; public abstract void run();&#125;//调用者public class Thread implements Runnable &#123; private Runnable target; public synchronized void start() &#123; if (threadStatus != 0) throw new IllegalThreadStateException(); group.add(this); boolean started = false; try &#123; start0(); started = true; &#125; finally &#123; try &#123; if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; &#125; &#125; &#125; private native void start0();&#125; 会调用一个native方法start0(),调用系统方法，开启一个线程。而接收者是对程序员开放的，可以自己定义接收者。 1234567891011121314/** * jdk Runnable 命令模式 * TurnOffThread ： 属于具体 */public class TurnOffThread implements Runnable&#123; private Receiver receiver; public TurnOffThread(Receiver receiver) &#123; this.receiver = receiver; &#125; public void run() &#123; receiver.turnOFF(); &#125;&#125; 1234567891011/** * 测试类 */public class Demo &#123; public static void main(String[] args) &#123; Receiver receiver = new Receiver(); TurnOffThread turnOffThread = new TurnOffThread(receiver); Thread thread = new Thread(turnOffThread); thread.start(); &#125;&#125; 6.4 责任链模式6.4.1 概述在现实生活中，常常会出现这样的事例：一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。例如，公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据自己要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这增加了难度。这样的例子还有很多，如找领导出差报销、生活中的“击鼓传花”游戏等。 定义： 又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。 6.4.2 结构职责链模式主要包含以下角色: 抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。 具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。 客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。 6.4.3 案例实现现需要开发一个请假流程控制系统。请假一天以下的假只需要小组长同意即可；请假1天到3天的假还需要部门经理同意；请求3天到7天还需要总经理同意才行。 类图如下： 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138//请假条public class LeaveRequest &#123; private String name;//姓名 private int num;//请假天数 private String content;//请假内容 public LeaveRequest(String name, int num, String content) &#123; this.name = name; this.num = num; this.content = content; &#125; public String getName() &#123; return name; &#125; public int getNum() &#123; return num; &#125; public String getContent() &#123; return content; &#125;&#125;//处理者抽象类public abstract class Handler &#123; protected final static int NUM_ONE = 1; protected final static int NUM_THREE = 3; protected final static int NUM_SEVEN = 7; //该领导处理的请假天数区间 private int numStart; private int numEnd; //领导上面还有领导 private Handler nextHandler; //设置请假天数范围 上不封顶 public Handler(int numStart) &#123; this.numStart = numStart; &#125; //设置请假天数范围 public Handler(int numStart, int numEnd) &#123; this.numStart = numStart; this.numEnd = numEnd; &#125; //设置上级领导 public void setNextHandler(Handler nextHandler)&#123; this.nextHandler = nextHandler; &#125; //提交请假条 public final void submit(LeaveRequest leave)&#123; if(0 == this.numStart)&#123; return; &#125; //如果请假天数达到该领导者的处理要求 if(leave.getNum() &gt;= this.numStart)&#123; this.handleLeave(leave); //如果还有上级 并且请假天数超过了当前领导的处理范围 if(null != this.nextHandler &amp;&amp; leave.getNum() &gt; numEnd)&#123; this.nextHandler.submit(leave);//继续提交 &#125; else &#123; System.out.println(&quot;流程结束&quot;); &#125; &#125; &#125; //各级领导处理请假条方法 protected abstract void handleLeave(LeaveRequest leave);&#125;//小组长public class GroupLeader extends Handler &#123; public GroupLeader() &#123; //小组长处理1-3天的请假 super(Handler.NUM_ONE, Handler.NUM_THREE); &#125; @Override protected void handleLeave(LeaveRequest leave) &#123; System.out.println(leave.getName() + &quot;请假&quot; + leave.getNum() + &quot;天,&quot; + leave.getContent() + &quot;。&quot;); System.out.println(&quot;小组长审批：同意。&quot;); &#125;&#125;//部门经理public class Manager extends Handler &#123; public Manager() &#123; //部门经理处理3-7天的请假 super(Handler.NUM_THREE, Handler.NUM_SEVEN); &#125; @Override protected void handleLeave(LeaveRequest leave) &#123; System.out.println(leave.getName() + &quot;请假&quot; + leave.getNum() + &quot;天,&quot; + leave.getContent() + &quot;。&quot;); System.out.println(&quot;部门经理审批：同意。&quot;); &#125;&#125;//总经理public class GeneralManager extends Handler &#123; public GeneralManager() &#123; //部门经理处理7天以上的请假 super(Handler.NUM_SEVEN); &#125; @Override protected void handleLeave(LeaveRequest leave) &#123; System.out.println(leave.getName() + &quot;请假&quot; + leave.getNum() + &quot;天,&quot; + leave.getContent() + &quot;。&quot;); System.out.println(&quot;总经理审批：同意。&quot;); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; //请假条来一张 LeaveRequest leave = new LeaveRequest(&quot;小花&quot;,5,&quot;身体不适&quot;); //各位领导 GroupLeader groupLeader = new GroupLeader(); Manager manager = new Manager(); GeneralManager generalManager = new GeneralManager(); groupLeader.setNextHandler(manager);//小组长的领导是部门经理 manager.setNextHandler(generalManager);//部门经理的领导是总经理 //之所以在这里设置上级领导，是因为可以根据实际需求来更改设置，如果实战中上级领导人都是固定的，则可以移到领导实现类中。 //提交申请 groupLeader.submit(leave); &#125;&#125; 6.4.4 优缺点1，优点： 降低了对象之间的耦合度 该模式降低了请求发送者和接收者的耦合度。 增强了系统的可扩展性 可以根据需要增加新的请求处理类，满足开闭原则。 增强了给对象指派职责的灵活性 当工作流程发生变化，可以动态地改变链内的成员或者修改它们的次序，也可动态地新增或者删除责任。 责任链简化了对象之间的连接 一个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。 责任分担 每个类只需要处理自己该处理的工作，不能处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。 2，缺点： 不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。 对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。 职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。 6.4.5 源码解析在javaWeb应用开发中，FilterChain是职责链（过滤器）模式的典型应用，以下是Filter的模拟实现分析: 模拟web请求Request以及web响应Response 1234567public interface Request&#123; &#125;public interface Response&#123; &#125; 模拟web过滤器Filter 123public interface Filter &#123; public void doFilter(Request req,Response res,FilterChain c);&#125; 模拟实现具体过滤器 12345678910111213141516171819202122232425public class FirstFilter implements Filter &#123; @Override public void doFilter(Request request, Response response, FilterChain chain) &#123; System.out.println(&quot;过滤器1 前置处理&quot;); // 先执行所有request再倒序执行所有response chain.doFilter(request, response); System.out.println(&quot;过滤器1 后置处理&quot;); &#125;&#125;public class SecondFilter implements Filter &#123; @Override public void doFilter(Request request, Response response, FilterChain chain) &#123; System.out.println(&quot;过滤器2 前置处理&quot;); // 先执行所有request再倒序执行所有response chain.doFilter(request, response); System.out.println(&quot;过滤器2 后置处理&quot;); &#125;&#125; 模拟实现过滤器链FilterChain 123456789101112131415161718192021public class FilterChain &#123; private List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;(); private int index = 0; // 链式调用 public FilterChain addFilter(Filter filter) &#123; this.filters.add(filter); return this; &#125; public void doFilter(Request request, Response response) &#123; if (index == filters.size()) &#123; return; &#125; Filter filter = filters.get(index); index++; filter.doFilter(request, response, this); &#125;&#125; 测试类 12345678910public class Client &#123; public static void main(String[] args) &#123; Request req = null; Response res = null ; FilterChain filterChain = new FilterChain(); filterChain.addFilter(new FirstFilter()).addFilter(new SecondFilter()); filterChain.doFilter(req,res); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式（三）","slug":"设计模式/设计模式（三）","date":"2023-06-16T05:55:17.000Z","updated":"2023-06-16T05:57:12.599Z","comments":true,"path":"2023/06/16/设计模式/设计模式（三）/","link":"","permalink":"http://example.com/2023/06/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"","text":"5，结构型模式结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。 由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。 结构型模式分为以下 7 种： 代理模式 适配器模式 装饰者模式 桥接模式 外观模式 组合模式 享元模式 5.1 代理模式5.1.1 概述由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。 Java中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。 5.1.2 结构代理（Proxy）模式分为三种角色： 抽象主题（Subject）类： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。 真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。 代理（Proxy）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。 5.1.3 静态代理我们通过案例来感受一下静态代理。 【例】火车站卖票 如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。类图如下： 代码如下： 12345678910111213141516171819202122232425262728293031//卖票接口public interface SellTickets &#123; void sell();&#125;//火车站 火车站具有卖票功能，所以需要实现SellTickets接口public class TrainStation implements SellTickets &#123; public void sell() &#123; System.out.println(&quot;火车站卖票&quot;); &#125;&#125;//代售点public class ProxyPoint implements SellTickets &#123; private TrainStation station = new TrainStation(); public void sell() &#123; System.out.println(&quot;代理点收取一些服务费用&quot;); station.sell(); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; ProxyPoint pp = new ProxyPoint(); pp.sell(); &#125;&#125; 从上面代码中可以看出测试类直接访问的是ProxyPoint类对象，也就是说ProxyPoint作为访问对象和目标对象的中介。同时也对sell方法进行了增强（代理点收取一些服务费用）。 5.1.4 JDK动态代理接下来我们使用动态代理实现上面案例，先说说JDK提供的动态代理。Java中提供了一个动态代理类Proxy，Proxy并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（newProxyInstance方法）来获取代理对象。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//卖票接口public interface SellTickets &#123; void sell();&#125;//火车站 火车站具有卖票功能，所以需要实现SellTickets接口public class TrainStation implements SellTickets &#123; public void sell() &#123; System.out.println(&quot;火车站卖票&quot;); &#125;&#125;//代理工厂，用来创建代理对象public class ProxyFactory &#123; private TrainStation station = new TrainStation(); public SellTickets getProxyObject() &#123; //使用Proxy获取代理对象 /* newProxyInstance()方法参数说明： ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可 Class&lt;?&gt;[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口 InvocationHandler h ： 代理对象的调用处理程序 */ SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(), station.getClass().getInterfaces(), new InvocationHandler() &#123; /* InvocationHandler中invoke方法参数说明： proxy ： 代理对象 method ： 对应于在代理对象上调用的接口方法的 Method 实例 args ： 代理对象调用接口方法时传递的实际参数 */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;代理点收取一些服务费用(JDK动态代理方式)&quot;); //执行真实对象 Object result = method.invoke(station, args); return result; &#125; &#125;); return sellTickets; &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; //获取代理对象 ProxyFactory factory = new ProxyFactory(); SellTickets proxyObject = factory.getProxyObject(); proxyObject.sell(); &#125;&#125; 使用了动态代理，我们思考下面问题： ProxyFactory是代理类吗？ ProxyFactory不是代理模式中所说的代理类，而代理类是程序在运行过程中动态的在内存中生成的类。通过阿里巴巴开源的 Java 诊断工具（Arthas【阿尔萨斯】）查看代理类的结构： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.sun.proxy;import com.itheima.proxy.dynamic.jdk.SellTickets;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;public final class $Proxy0 extends Proxy implements SellTickets &#123; private static Method m1; private static Method m2; private static Method m3; private static Method m0; public $Proxy0(InvocationHandler invocationHandler) &#123; super(invocationHandler); &#125; static &#123; try &#123; m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;)); m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]); m3 = Class.forName(&quot;com.itheima.proxy.dynamic.jdk.SellTickets&quot;).getMethod(&quot;sell&quot;, new Class[0]); m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]); return; &#125; catch (NoSuchMethodException noSuchMethodException) &#123; throw new NoSuchMethodError(noSuchMethodException.getMessage()); &#125; catch (ClassNotFoundException classNotFoundException) &#123; throw new NoClassDefFoundError(classNotFoundException.getMessage()); &#125; &#125; public final boolean equals(Object object) &#123; try &#123; return (Boolean)this.h.invoke(this, m1, new Object[]&#123;object&#125;); &#125; catch (Error | RuntimeException throwable) &#123; throw throwable; &#125; catch (Throwable throwable) &#123; throw new UndeclaredThrowableException(throwable); &#125; &#125; public final String toString() &#123; try &#123; return (String)this.h.invoke(this, m2, null); &#125; catch (Error | RuntimeException throwable) &#123; throw throwable; &#125; catch (Throwable throwable) &#123; throw new UndeclaredThrowableException(throwable); &#125; &#125; public final int hashCode() &#123; try &#123; return (Integer)this.h.invoke(this, m0, null); &#125; catch (Error | RuntimeException throwable) &#123; throw throwable; &#125; catch (Throwable throwable) &#123; throw new UndeclaredThrowableException(throwable); &#125; &#125; public final void sell() &#123; try &#123; this.h.invoke(this, m3, null); return; &#125; catch (Error | RuntimeException throwable) &#123; throw throwable; &#125; catch (Throwable throwable) &#123; throw new UndeclaredThrowableException(throwable); &#125; &#125;&#125; 从上面的类中，我们可以看到以下几个信息： 代理类（$Proxy0）实现了SellTickets。这也就印证了我们之前说的真实类和代理类实现同样的接口。 代理类（$Proxy0）将我们提供了的匿名内部类对象传递给了父类。 动态代理的执行流程是什么样？ 下面是摘取的重点代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//程序运行过程中动态生成的代理类public final class $Proxy0 extends Proxy implements SellTickets &#123; private static Method m3; public $Proxy0(InvocationHandler invocationHandler) &#123; super(invocationHandler); &#125; static &#123; m3 = Class.forName(&quot;com.itheima.proxy.dynamic.jdk.SellTickets&quot;).getMethod(&quot;sell&quot;, new Class[0]); &#125; public final void sell() &#123; this.h.invoke(this, m3, null); &#125;&#125;//Java提供的动态代理相关类public class Proxy implements java.io.Serializable &#123; protected InvocationHandler h; protected Proxy(InvocationHandler h) &#123; this.h = h; &#125;&#125;//代理工厂类public class ProxyFactory &#123; private TrainStation station = new TrainStation(); public SellTickets getProxyObject() &#123; SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(), station.getClass().getInterfaces(), new InvocationHandler() &#123; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;代理点收取一些服务费用(JDK动态代理方式)&quot;); Object result = method.invoke(station, args); return result; &#125; &#125;); return sellTickets; &#125;&#125;//测试访问类public class Client &#123; public static void main(String[] args) &#123; //获取代理对象 ProxyFactory factory = new ProxyFactory(); SellTickets proxyObject = factory.getProxyObject(); proxyObject.sell(); &#125;&#125; 执行流程如下： 1. 在测试类中通过代理对象调用sell()方法 2. 根据多态的特性，执行的是代理类（$Proxy0）中的sell()方法 3. 代理类（$Proxy0）中的sell()方法中又调用了InvocationHandler接口的子实现类对象的invoke方法 4. invoke方法通过反射执行了真实对象所属类(TrainStation)中的sell()方法 5.1.5 CGLIB动态代理同样是上面的案例，我们再次使用CGLIB代理实现。 如果没有定义SellTickets接口，只定义了TrainStation(火车站类)。很显然JDK代理是无法使用了，因为JDK动态代理要求必须定义接口，对接口进行代理。 CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。 CGLIB是第三方提供的包，所以需要引入jar包的坐标： 12345&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt; 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//火车站public class TrainStation &#123; public void sell() &#123; System.out.println(&quot;火车站卖票&quot;); &#125;&#125;//代理工厂public class ProxyFactory implements MethodInterceptor &#123; private TrainStation target = new TrainStation(); public TrainStation getProxyObject() &#123; //创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数 Enhancer enhancer =new Enhancer(); //设置父类的字节码对象 enhancer.setSuperclass(target.getClass()); //设置回调函数 enhancer.setCallback(this); //创建代理对象 TrainStation obj = (TrainStation) enhancer.create(); return obj; &#125; /* intercept方法参数说明： o ： 代理对象 method ： 真实对象中的方法的Method实例 args ： 实际参数 methodProxy ：代理对象中的方法的method实例 */ public TrainStation intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; System.out.println(&quot;代理点收取一些服务费用(CGLIB动态代理方式)&quot;); TrainStation result = (TrainStation) methodProxy.invokeSuper(o, args); return result; &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; //创建代理工厂对象 ProxyFactory factory = new ProxyFactory(); //获取代理对象 TrainStation proxyObject = factory.getProxyObject(); proxyObject.sell(); &#125;&#125; 5.1.6 三种代理的对比 jdk代理和CGLIB代理 使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的类或者方法进行代理，因为CGLib原理是动态生成被代理类的子类。 在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以如果有接口使用JDK动态代理，如果没有接口使用CGLIB代理。 动态代理和静态代理 动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。 如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题 5.1.7 优缺点优点： 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用； 代理对象可以扩展目标对象的功能； 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度； 缺点： 增加了系统的复杂度； 5.1.8 使用场景 远程（Remote）代理 本地服务通过网络请求远程服务。为了实现本地到远程的通信，我们需要实现网络通信，处理其中可能的异常。为良好的代码设计和可维护性，我们将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能，而不必过多关心通信部分的细节。 防火墙（Firewall）代理 当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器。 保护（Protect or Access）代理 控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。 5.2 适配器模式5.2.1 概述如果去欧洲国家去旅游的话，他们的插座如下图最左边，是欧洲标准。而我们使用的插头如下图最右边的。因此我们的笔记本电脑，手机在当地不能直接充电。所以就需要一个插座转换器，转换器第1面插入当地的插座，第2面供我们充电，这样使得我们的插头在当地能使用。生活中这样的例子很多，手机充电器（将220v转换为5v的电压），读卡器等，其实就是使用到了适配器模式。 定义： ​ 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。 ​ 适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。 5.2.2 结构适配器模式（Adapter）包含以下主要角色： 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。 5.2.3 类适配器模式实现方式：定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。 【例】读卡器 现有一台电脑只能读取SD卡，而要读取TF卡中的内容的话就需要使用到适配器模式。创建一个读卡器，将TF卡中的内容读取出来。 类图如下： 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//SD卡的接口public interface SDCard &#123; //读取SD卡方法 String readSD(); //写入SD卡功能 void writeSD(String msg);&#125;//SD卡实现类public class SDCardImpl implements SDCard &#123; public String readSD() &#123; String msg = &quot;sd card read a msg :hello word SD&quot;; return msg; &#125; public void writeSD(String msg) &#123; System.out.println(&quot;sd card write msg : &quot; + msg); &#125;&#125;//电脑类public class Computer &#123; public String readSD(SDCard sdCard) &#123; if(sdCard == null) &#123; throw new NullPointerException(&quot;sd card null&quot;); &#125; return sdCard.readSD(); &#125;&#125;//TF卡接口public interface TFCard &#123; //读取TF卡方法 String readTF(); //写入TF卡功能 void writeTF(String msg);&#125;//TF卡实现类public class TFCardImpl implements TFCard &#123; public String readTF() &#123; String msg =&quot;tf card read msg : hello word tf card&quot;; return msg; &#125; public void writeTF(String msg) &#123; System.out.println(&quot;tf card write a msg : &quot; + msg); &#125;&#125;//定义适配器类（SD兼容TF）public class SDAdapterTF extends TFCardImpl implements SDCard &#123; public String readSD() &#123; System.out.println(&quot;adapter read tf card &quot;); return readTF(); &#125; public void writeSD(String msg) &#123; System.out.println(&quot;adapter write tf card&quot;); writeTF(msg); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; Computer computer = new Computer(); SDCard sdCard = new SDCardImpl(); System.out.println(computer.readSD(sdCard)); System.out.println(&quot;------------&quot;); SDAdapterTF adapter = new SDAdapterTF(); System.out.println(computer.readSD(adapter)); &#125;&#125; 类适配器模式违背了合成复用原则。类适配器是客户类有一个接口规范的情况下可用，反之不可用。 5.2.4 对象适配器模式实现方式：对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。 【例】读卡器 我们使用对象适配器模式将读卡器的案例进行改写。类图如下： 代码如下： 类适配器模式的代码，我们只需要修改适配器类（SDAdapterTF）和测试类。 12345678910111213141516171819202122232425262728293031323334//创建适配器对象（SD兼容TF）public class SDAdapterTF implements SDCard &#123; private TFCard tfCard; public SDAdapterTF(TFCard tfCard) &#123; this.tfCard = tfCard; &#125; public String readSD() &#123; System.out.println(&quot;adapter read tf card &quot;); return tfCard.readTF(); &#125; public void writeSD(String msg) &#123; System.out.println(&quot;adapter write tf card&quot;); tfCard.writeTF(msg); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; Computer computer = new Computer(); SDCard sdCard = new SDCardImpl(); System.out.println(computer.readSD(sdCard)); System.out.println(&quot;------------&quot;); TFCard tfCard = new TFCardImpl(); SDAdapterTF adapter = new SDAdapterTF(tfCard); System.out.println(computer.readSD(adapter)); &#125;&#125; 注意：还有一个适配器模式是接口适配器模式。当不希望实现一个接口中所有的方法时，可以创建一个抽象类Adapter ，实现所有方法。而此时我们只需要继承该抽象类即可。 5.2.5 应用场景 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。 5.2.6 JDK源码解析Reader（字符流）、InputStream（字节流）的适配使用的是InputStreamReader。 InputStreamReader继承自java.io包中的Reader，对他中的抽象的未实现的方法给出实现。如： 1234567public int read() throws IOException &#123; return sd.read();&#125;public int read(char cbuf[], int offset, int length) throws IOException &#123; return sd.read(cbuf, offset, length);&#125; 如上代码中的sd（StreamDecoder类对象），在Sun的JDK实现中，实际的方法实现是对sun.nio.cs.StreamDecoder类的同名方法的调用封装。类结构图如下： 从上图可以看出： InputStreamReader是对同样实现了Reader的StreamDecoder的封装。 StreamDecoder不是Java SE API中的内容，是Sun JDK给出的自身实现。但我们知道他们对构造方法中的字节流类（InputStream）进行封装，并通过该类进行了字节流和字符流之间的解码转换。 结论： ​ 从表层来看，InputStreamReader做了InputStream字节流类到Reader字符流之间的转换。而从如上Sun JDK中的实现类关系结构中可以看出，是StreamDecoder的设计实现在实际上采用了适配器模式。 5.3 装饰者模式5.3.1 概述我们先来看一个快餐店的例子。 快餐店有炒面、炒饭这些快餐，可以额外附加鸡蛋、火腿、培根这些配菜，当然加配菜需要额外加钱，每个配菜的价钱通常不太一样，那么计算总价就会显得比较麻烦。 使用继承的方式存在的问题： 扩展性不好 如果要再加一种配料（火腿肠），我们就会发现需要给FriedRice和FriedNoodles分别定义一个子类。如果要新增一个快餐品类（炒河粉）的话，就需要定义更多的子类。 产生过多的子类 定义： ​ 指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。 5.3.2 结构装饰（Decorator）模式中的角色： 抽象构件（Component）角色 ：定义一个抽象接口以规范准备接收附加责任的对象。 具体构件（Concrete Component）角色 ：实现抽象构件，通过装饰角色为其添加一些职责。 抽象装饰（Decorator）角色 ： 继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。 具体装饰（ConcreteDecorator）角色 ：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。 5.3.3 案例我们使用装饰者模式对快餐店案例进行改进，体会装饰者模式的精髓。 类图如下： 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135//快餐接口public abstract class FastFood &#123; private float price; private String desc; public FastFood() &#123; &#125; public FastFood(float price, String desc) &#123; this.price = price; this.desc = desc; &#125; public void setPrice(float price) &#123; this.price = price; &#125; public float getPrice() &#123; return price; &#125; public String getDesc() &#123; return desc; &#125; public void setDesc(String desc) &#123; this.desc = desc; &#125; public abstract float cost(); //获取价格&#125;//炒饭public class FriedRice extends FastFood &#123; public FriedRice() &#123; super(10, &quot;炒饭&quot;); &#125; public float cost() &#123; return getPrice(); &#125;&#125;//炒面public class FriedNoodles extends FastFood &#123; public FriedNoodles() &#123; super(12, &quot;炒面&quot;); &#125; public float cost() &#123; return getPrice(); &#125;&#125;//配料类public abstract class Garnish extends FastFood &#123; private FastFood fastFood; public FastFood getFastFood() &#123; return fastFood; &#125; public void setFastFood(FastFood fastFood) &#123; this.fastFood = fastFood; &#125; public Garnish(FastFood fastFood, float price, String desc) &#123; super(price,desc); this.fastFood = fastFood; &#125;&#125;//鸡蛋配料public class Egg extends Garnish &#123; public Egg(FastFood fastFood) &#123; super(fastFood,1,&quot;鸡蛋&quot;); &#125; public float cost() &#123; return getPrice() + getFastFood().getPrice(); &#125; @Override public String getDesc() &#123; return super.getDesc() + getFastFood().getDesc(); &#125;&#125;//培根配料public class Bacon extends Garnish &#123; public Bacon(FastFood fastFood) &#123; super(fastFood,2,&quot;培根&quot;); &#125; @Override public float cost() &#123; return getPrice() + getFastFood().getPrice(); &#125; @Override public String getDesc() &#123; return super.getDesc() + getFastFood().getDesc(); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; //点一份炒饭 FastFood food = new FriedRice(); //花费的价格 System.out.println(food.getDesc() + &quot; &quot; + food.cost() + &quot;元&quot;); System.out.println(&quot;========&quot;); //点一份加鸡蛋的炒饭 FastFood food1 = new FriedRice(); food1 = new Egg(food1); //花费的价格 System.out.println(food1.getDesc() + &quot; &quot; + food1.cost() + &quot;元&quot;); System.out.println(&quot;========&quot;); //点一份加培根的炒面 FastFood food2 = new FriedNoodles(); food2 = new Bacon(food2); //花费的价格 System.out.println(food2.getDesc() + &quot; &quot; + food2.cost() + &quot;元&quot;); &#125;&#125; 好处： 饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任。 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。 5.3.4 使用场景 当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。 不能采用继承的情况主要有两类： 第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长； 第二类是因为类定义不能继承（如final类） 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。 当对象的功能要求可以动态地添加，也可以再动态地撤销时。 5.3.5 JDK源码解析IO流中的包装类使用到了装饰者模式。BufferedInputStream，BufferedOutputStream，BufferedReader，BufferedWriter。 我们以BufferedWriter举例来说明，先看看如何使用BufferedWriter 12345678910111213public class Demo &#123; public static void main(String[] args) throws Exception&#123; //创建BufferedWriter对象 //创建FileWriter对象 FileWriter fw = new FileWriter(&quot;C:\\\\Users\\\\Think\\\\Desktop\\\\a.txt&quot;); BufferedWriter bw = new BufferedWriter(fw); //写数据 bw.write(&quot;hello Buffered&quot;); bw.close(); &#125;&#125; 使用起来感觉确实像是装饰者模式，接下来看它们的结构： 小结： ​ BufferedWriter使用装饰者模式对Writer子实现类进行了增强，添加了缓冲区，提高了写数据的效率。 5.3.6 代理和装饰者的区别静态代理和装饰者模式的区别： 相同点： 都要实现与目标类相同的业务接口 在两个类中都要声明目标对象 都可以在不修改目标类的前提下增强目标方法 不同点： 目的不同装饰者是为了增强目标对象静态代理是为了保护和隐藏目标对象 获取目标对象构建的地方不同装饰者是由外界传递进来，可以通过构造方法传递静态代理是在代理类内部创建，以此来隐藏目标对象 5.4 桥接模式5.4.1 概述现在有一个需求，需要创建不同的图形，并且每个图形都有可能会有不同的颜色。我们可以利用继承的方式来设计类的关系： 我们可以发现有很多的类，假如我们再增加一个形状或再增加一种颜色，就需要创建更多的类。 试想，在一个有多种可能会变化的维度的系统中，用继承方式会造成类爆炸，扩展起来不灵活。每次在一个维度上新增一个具体实现都要增加多个子类。为了更加灵活的设计系统，我们此时可以考虑使用桥接模式。 定义： ​ 将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。 5.4.2 结构桥接（Bridge）模式包含以下主要角色： 抽象化（Abstraction）角色 ：定义抽象类，并包含一个对实现化对象的引用。 扩展抽象化（Refined Abstraction）角色 ：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。 实现化（Implementor）角色 ：定义实现化角色的接口，供扩展抽象化角色调用。 具体实现化（Concrete Implementor）角色 ：给出实现化角色接口的具体实现。 5.4.3 案例【例】视频播放器 需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI、WMV等。该播放器包含了两个维度，适合使用桥接模式。 类图如下： 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//视频文件public interface VideoFile &#123; void decode(String fileName);&#125;//avi文件public class AVIFile implements VideoFile &#123; public void decode(String fileName) &#123; System.out.println(&quot;avi视频文件：&quot;+ fileName); &#125;&#125;//rmvb文件public class REVBBFile implements VideoFile &#123; public void decode(String fileName) &#123; System.out.println(&quot;rmvb文件：&quot; + fileName); &#125;&#125;//操作系统版本public abstract class OperatingSystemVersion &#123; protected VideoFile videoFile; public OperatingSystemVersion(VideoFile videoFile) &#123; this.videoFile = videoFile; &#125; public abstract void play(String fileName);&#125;//Windows版本public class Windows extends OperatingSystem &#123; public Windows(VideoFile videoFile) &#123; super(videoFile); &#125; public void play(String fileName) &#123; videoFile.decode(fileName); &#125;&#125;//mac版本public class Mac extends OperatingSystemVersion &#123; public Mac(VideoFile videoFile) &#123; super(videoFile); &#125; public void play(String fileName) &#123; videoFile.decode(fileName); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; OperatingSystem os = new Windows(new AVIFile()); os.play(&quot;战狼3&quot;); &#125;&#125; 好处： 桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。 如：如果现在还有一种视频文件类型wmv，我们只需要再定义一个类实现VideoFile接口即可，其他类不需要发生变化。 实现细节对客户透明 5.4.4 使用场景 当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。 当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。 当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 5.5 外观模式5.5.1 概述有些人可能炒过股票，但其实大部分人都不太懂，这种没有足够了解证券知识的情况下做股票是很容易亏钱的，刚开始炒股肯定都会想，如果有个懂行的帮帮手就好，其实基金就是个好帮手，支付宝里就有许多的基金，它将投资者分散的资金集中起来，交由专业的经理人进行管理，投资于股票、债券、外汇等领域，而基金投资的收益归持有者所有，管理机构收取一定比例的托管管理费用。 定义： ​ 又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。 ​ 外观（Facade）模式是“迪米特法则”的典型应用 5.5.2 结构外观（Facade）模式包含以下主要角色： 外观（Facade）角色：为多个子系统对外提供一个共同的接口。 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。 5.5.3 案例【例】智能家电控制 小明的爷爷已经60岁了，一个人在家生活：每次都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；操作起来都比较麻烦。所以小明给爷爷买了智能音箱，可以通过语音直接控制这些智能家电的开启和关闭。类图如下： 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//灯类public class Light &#123; public void on() &#123; System.out.println(&quot;打开了灯....&quot;); &#125; public void off() &#123; System.out.println(&quot;关闭了灯....&quot;); &#125;&#125;//电视类public class TV &#123; public void on() &#123; System.out.println(&quot;打开了电视....&quot;); &#125; public void off() &#123; System.out.println(&quot;关闭了电视....&quot;); &#125;&#125;//控制类public class AirCondition &#123; public void on() &#123; System.out.println(&quot;打开了空调....&quot;); &#125; public void off() &#123; System.out.println(&quot;关闭了空调....&quot;); &#125;&#125;//智能音箱public class SmartAppliancesFacade &#123; private Light light; private TV tv; private AirCondition airCondition; public SmartAppliancesFacade() &#123; light = new Light(); tv = new TV(); airCondition = new AirCondition(); &#125; public void say(String message) &#123; if(message.contains(&quot;打开&quot;)) &#123; on(); &#125; else if(message.contains(&quot;关闭&quot;)) &#123; off(); &#125; else &#123; System.out.println(&quot;我还听不懂你说的！！！&quot;); &#125; &#125; //起床后一键开电器 private void on() &#123; System.out.println(&quot;起床了&quot;); light.on(); tv.on(); airCondition.on(); &#125; //睡觉一键关电器 private void off() &#123; System.out.println(&quot;睡觉了&quot;); light.off(); tv.off(); airCondition.off(); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; //创建外观对象 SmartAppliancesFacade facade = new SmartAppliancesFacade(); //客户端直接与外观对象进行交互 facade.say(&quot;打开家电&quot;); facade.say(&quot;关闭家电&quot;); &#125;&#125; 好处： 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。 缺点： 不符合开闭原则，修改很麻烦 5.5.4 使用场景 对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。 当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。 当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。 5.5.5 源码解析使用tomcat作为web容器时，接收浏览器发送过来的请求，tomcat会将请求信息封装成ServletRequest对象，如下图①处对象。但是大家想想ServletRequest是一个接口，它还有一个子接口HttpServletRequest，而我们知道该request对象肯定是一个HttpServletRequest对象的子实现类对象，到底是哪个类的对象呢？可以通过输出request对象，我们就会发现是一个名为RequestFacade的类的对象。 RequestFacade类就使用了外观模式。先看结构图： 为什么在此处使用外观模式呢？ ​ 定义 RequestFacade 类，分别实现 ServletRequest ，同时定义私有成员变量 Request ，并且方法的实现调用 Request 的实现。然后，将 RequestFacade上转为 ServletRequest 传给 servlet 的 service 方法，这样即使在 servlet 中被下转为 RequestFacade ，也不能访问私有成员变量对象中的方法。既用了 Request ，又能防止其中方法被不合理的访问。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式（二）","slug":"设计模式/设计模式（二）","date":"2023-06-16T05:41:43.000Z","updated":"2023-06-16T05:51:51.409Z","comments":true,"path":"2023/06/16/设计模式/设计模式（二）/","link":"","permalink":"http://example.com/2023/06/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"4，创建型模式4.2 工厂模式4.2.1 概述需求：设计一个咖啡店点餐系统。 设计一个咖啡类（Coffee），并定义其两个子类（美式咖啡【AmericanCoffee】和拿铁咖啡【LatteCoffee】）；再设计一个咖啡店类（CoffeeStore），咖啡店具有点咖啡的功能。 具体类的设计如下： 在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：解耦。 在本教程中会介绍三种工厂的使用 简单工厂模式（不属于GOF的23种经典设计模式） 工厂方法模式 抽象工厂模式 4.2.2 简单工厂模式简单工厂不是一种设计模式，反而比较像是一种编程习惯。 4.2.2.1 结构简单工厂包含如下角色： 抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。 具体产品 ：实现或者继承抽象产品的子类 具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。 4.2.2.2 实现现在使用简单工厂对上面案例进行改进，类图如下： 工厂类代码如下： 123456789101112public class SimpleCoffeeFactory &#123; public Coffee createCoffee(String type) &#123; Coffee coffee = null; if(&quot;americano&quot;.equals(type)) &#123; coffee = new AmericanoCoffee(); &#125; else if(&quot;latte&quot;.equals(type)) &#123; coffee = new LatteCoffee(); &#125; return coffee; &#125;&#125; 工厂（factory）处理创建对象的细节，一旦有了SimpleCoffeeFactory，CoffeeStore类中的orderCoffee()就变成此对象的客户，后期如果需要Coffee对象直接从工厂中获取即可。这样也就解除了和Coffee实现类的耦合，同时又产生了新的耦合，CoffeeStore对象和SimpleCoffeeFactory工厂对象的耦合，工厂对象和商品对象的耦合。 后期如果再加新品种的咖啡，我们势必要需求修改SimpleCoffeeFactory的代码，违反了开闭原则。工厂类的客户端可能有很多，比如创建美团外卖等，这样只需要修改工厂类的代码，省去其他的修改操作。 4.2.2.4 优缺点优点： 封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。 缺点： 增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。 4.2.2.3 扩展静态工厂 在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也不是23种设计模式中的。代码如下： 123456789101112public class SimpleCoffeeFactory &#123; public static Coffee createCoffee(String type) &#123; Coffee coffee = null; if(&quot;americano&quot;.equals(type)) &#123; coffee = new AmericanoCoffee(); &#125; else if(&quot;latte&quot;.equals(type)) &#123; coffee = new LatteCoffee(); &#125; return coffe; &#125;&#125; 4.2.3 工厂方法模式针对上例中的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。 4.2.3.1 概念定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。 4.2.3.2 结构工厂方法模式的主要角色： 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。 4.2.3.3 实现使用工厂方法模式对上例进行改进，类图如下： 代码如下： 抽象工厂： 1234public interface CoffeeFactory &#123; Coffee createCoffee();&#125; 具体工厂： 12345678910111213public class LatteCoffeeFactory implements CoffeeFactory &#123; public Coffee createCoffee() &#123; return new LatteCoffee(); &#125;&#125;public class AmericanCoffeeFactory implements CoffeeFactory &#123; public Coffee createCoffee() &#123; return new AmericanCoffee(); &#125;&#125; 咖啡店类： 123456789101112131415public class CoffeeStore &#123; private CoffeeFactory factory; public CoffeeStore(CoffeeFactory factory) &#123; this.factory = factory; &#125; public Coffee orderCoffee(String type) &#123; Coffee coffee = factory.createCoffee(); coffee.addMilk(); coffee.addsugar(); return coffee; &#125;&#125; 从以上的编写的代码可以看到，要增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码了，这样就解决了简单工厂模式的缺点。 工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。 4.2.3.4 优缺点优点： 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程； 在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则； 缺点： 每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。 4.2.4 抽象工厂模式前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、传智播客只培养计算机软件专业的学生等。 这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。 本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，下图所示横轴是产品等级，也就是同一类产品；纵轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂。 4.2.4.1 概念是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。 抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。 4.2.4.2 结构抽象工厂模式的主要角色如下： 抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。 4.2.4.2 实现现咖啡店业务发生改变，不仅要生产咖啡还要生产甜点，如提拉米苏、抹茶慕斯等，要是按照工厂方法模式，需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂、抹茶慕斯工厂、甜点工厂类，很容易发生类爆炸情况。其中拿铁咖啡、美式咖啡是一个产品等级，都是咖啡；提拉米苏、抹茶慕斯也是一个产品等级；拿铁咖啡和提拉米苏是同一产品族（也就是都属于意大利风味），美式咖啡和抹茶慕斯是同一产品族（也就是都属于美式风味）。所以这个案例可以使用抽象工厂模式实现。类图如下： 代码如下： 抽象工厂： 123456public interface DessertFactory &#123; Coffee createCoffee(); Dessert createDessert();&#125; 具体工厂： 12345678910111213141516171819202122//美式甜点工厂public class AmericanDessertFactory implements DessertFactory &#123; public Coffee createCoffee() &#123; return new AmericanCoffee(); &#125; public Dessert createDessert() &#123; return new MatchaMousse(); &#125;&#125;//意大利风味甜点工厂public class ItalyDessertFactory implements DessertFactory &#123; public Coffee createCoffee() &#123; return new LatteCoffee(); &#125; public Dessert createDessert() &#123; return new Tiramisu(); &#125;&#125; 如果要加同一个产品族的话，只需要再加一个对应的工厂类即可，不需要修改其他的类。 4.2.4.3 优缺点优点： 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。 缺点： 当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。 4.2.4.4 使用场景 当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。 系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。 系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。 如：输入法换皮肤，一整套一起换。生成不同操作系统的程序。 4.2.5 模式扩展简单工厂+配置文件解除耦合 可以通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合。在工厂类中加载配置文件中的全类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。 第一步：定义配置文件 为了演示方便，我们使用properties文件作为配置文件，名称为bean.properties 12american=com.itheima.pattern.factory.config_factory.AmericanCoffeelatte=com.itheima.pattern.factory.config_factory.LatteCoffee 第二步：改进工厂类 1234567891011121314151617181920212223242526272829public class CoffeeFactory &#123; private static Map&lt;String,Coffee&gt; map = new HashMap(); static &#123; Properties p = new Properties(); InputStream is = CoffeeFactory.class.getClassLoader().getResourceAsStream(&quot;bean.properties&quot;); try &#123; p.load(is); //遍历Properties集合对象 Set&lt;Object&gt; keys = p.keySet(); for (Object key : keys) &#123; //根据键获取值（全类名） String className = p.getProperty((String) key); //获取字节码对象 Class clazz = Class.forName(className); Coffee obj = (Coffee) clazz.newInstance(); map.put((String)key,obj); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Coffee createCoffee(String name) &#123; return map.get(name); &#125;&#125; 静态成员变量用来存储创建的对象（键存储的是名称，值存储的是对应的对象），而读取配置文件以及创建对象写在静态代码块中，目的就是只需要执行一次。 4.2.6 JDK源码解析-Collection.iterator方法12345678910111213141516public class Demo &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;令狐冲&quot;); list.add(&quot;风清扬&quot;); list.add(&quot;任我行&quot;); //获取迭代器对象 Iterator&lt;String&gt; it = list.iterator(); //使用迭代器遍历 while(it.hasNext()) &#123; String ele = it.next(); System.out.println(ele); &#125; &#125;&#125; 对上面的代码大家应该很熟，使用迭代器遍历集合，获取集合中的元素。而单列集合获取迭代器的方法就使用到了工厂方法模式。我们看通过类图看看结构： Collection接口是抽象工厂类，ArrayList是具体的工厂类；Iterator接口是抽象商品类，ArrayList类中的Iter内部类是具体的商品类。在具体的工厂类中iterator()方法创建具体的商品类的对象。 另： ​ 1,DateForamt类中的getInstance()方法使用的是工厂模式； ​ 2,Calendar类中的getInstance()方法使用的是工厂模式； 4.3 原型模式4.3.1 概述用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。 4.3.2 结构原型模式包含如下角色： 抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。 访问类：使用具体原型类中的 clone() 方法来复制新的对象。 接口类图如下： 4.3.3 实现原型模式的克隆分为浅克隆和深克隆。 浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。 深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。 Java中的Object类中提供了 clone() 方法来实现浅克隆。 Cloneable 接口是上面的类图中的抽象原型类，而实现了Cloneable接口的子实现类就是具体的原型类。代码如下： Realizetype（具体的原型类）： 123456789101112public class Realizetype implements Cloneable &#123; public Realizetype() &#123; System.out.println(&quot;具体的原型对象创建完成！&quot;); &#125; @Override protected Realizetype clone() throws CloneNotSupportedException &#123; System.out.println(&quot;具体原型复制成功！&quot;); return (Realizetype) super.clone(); &#125;&#125; PrototypeTest（测试访问类）： 12345678public class PrototypeTest &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Realizetype r1 = new Realizetype(); Realizetype r2 = r1.clone(); System.out.println(&quot;对象r1和r2是同一个对象？&quot; + (r1 == r2)); &#125;&#125; 4.3.4 案例用原型模式生成“三好学生”奖状 同一学校的“三好学生”奖状除了获奖人姓名不同，其他都相同，可以使用原型模式复制多个“三好学生”奖状出来，然后在修改奖状上的名字即可。 类图如下： 代码如下： 12345678910111213141516171819202122232425262728293031323334353637//奖状类public class Citation implements Cloneable &#123; private String name; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return (this.name); &#125; public void show() &#123; System.out.println(name + &quot;同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！&quot;); &#125; @Override public Citation clone() throws CloneNotSupportedException &#123; return (Citation) super.clone(); &#125;&#125;//测试访问类public class CitationTest &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Citation c1 = new Citation(); c1.setName(&quot;张三&quot;); //复制奖状 Citation c2 = c1.clone(); //将奖状的名字修改李四 c2.setName(&quot;李四&quot;); c1.show(); c2.show(); &#125;&#125; 4.3.5 使用场景 对象的创建非常复杂，可以使用原型模式快捷的创建对象。 性能和安全要求比较高。 4.3.6 扩展（深克隆）将上面的“三好学生”奖状的案例中Citation类的name属性修改为Student类型的属性。代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//奖状类public class Citation implements Cloneable &#123; private Student stu; public Student getStu() &#123; return stu; &#125; public void setStu(Student stu) &#123; this.stu = stu; &#125; void show() &#123; System.out.println(stu.getName() + &quot;同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！&quot;); &#125; @Override public Citation clone() throws CloneNotSupportedException &#123; return (Citation) super.clone(); &#125;&#125;//学生类public class Student &#123; private String name; private String address; public Student(String name, String address) &#123; this.name = name; this.address = address; &#125; public Student() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125;//测试类public class CitationTest &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Citation c1 = new Citation(); Student stu = new Student(&quot;张三&quot;, &quot;西安&quot;); c1.setStu(stu); //复制奖状 Citation c2 = c1.clone(); //获取c2奖状所属学生对象 Student stu1 = c2.getStu(); stu1.setName(&quot;李四&quot;); //判断stu对象和stu1对象是否是同一个对象 System.out.println(&quot;stu和stu1是同一个对象？&quot; + (stu == stu1)); c1.show(); c2.show(); &#125;&#125; 运行结果为： 说明： ​ stu对象和stu1对象是同一个对象，就会产生将stu1对象中name属性值改为“李四”，两个Citation（奖状）对象中显示的都是李四。这就是浅克隆的效果，对具体原型类（Citation）中的引用类型的属性进行引用的复制。这种情况需要使用深克隆，而进行深克隆需要使用对象流。代码如下： 123456789101112131415161718192021222324252627public class CitationTest1 &#123; public static void main(String[] args) throws Exception &#123; Citation c1 = new Citation(); Student stu = new Student(&quot;张三&quot;, &quot;西安&quot;); c1.setStu(stu); //创建对象输出流对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Think\\\\Desktop\\\\b.txt&quot;)); //将c1对象写出到文件中 oos.writeObject(c1); oos.close(); //创建对象出入流对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Think\\\\Desktop\\\\b.txt&quot;)); //读取对象 Citation c2 = (Citation) ois.readObject(); //获取c2奖状所属学生对象 Student stu1 = c2.getStu(); stu1.setName(&quot;李四&quot;); //判断stu对象和stu1对象是否是同一个对象 System.out.println(&quot;stu和stu1是同一个对象？&quot; + (stu == stu1)); c1.show(); c2.show(); &#125;&#125; 运行结果为： 注意：Citation类和Student类必须实现Serializable接口，否则会抛NotSerializableException异常。 4.5 建造者模式4.4.1 概述将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。 分离了部件的构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况。 由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。 建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。 4.4.2 结构建造者（Builder）模式包含如下角色： 抽象建造者类（Builder）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。 具体建造者类（ConcreteBuilder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。 产品类（Product）：要创建的复杂对象。 指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。 类图如下： 4.4.3 实例创建共享单车 生产自行车是一个复杂的过程，它包含了车架，车座等组件的生产。而车架又有碳纤维，铝合金等材质的，车座有橡胶，真皮等材质。对于自行车的生产就可以使用建造者模式。 这里Bike是产品，包含车架，车座等组件；Builder是抽象建造者，MobikeBuilder和OfoBuilder是具体的建造者；Director是指挥者。类图如下： 具体的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798//自行车类public class Bike &#123; private String frame; private String seat; public String getFrame() &#123; return frame; &#125; public void setFrame(String frame) &#123; this.frame = frame; &#125; public String getSeat() &#123; return seat; &#125; public void setSeat(String seat) &#123; this.seat = seat; &#125;&#125;// 抽象 builder 类public abstract class Builder &#123; protected Bike mBike = new Bike(); public abstract void buildFrame(); public abstract void buildSeat(); public abstract Bike createBike();&#125;//摩拜单车Builder类public class MobikeBuilder extends Builder &#123; @Override public void buildFrame() &#123; mBike.setFrame(&quot;铝合金车架&quot;); &#125; @Override public void buildSeat() &#123; mBike.setSeat(&quot;真皮车座&quot;); &#125; @Override public Bike createBike() &#123; return mBike; &#125;&#125;//ofo单车Builder类public class OfoBuilder extends Builder &#123; @Override public void buildFrame() &#123; mBike.setFrame(&quot;碳纤维车架&quot;); &#125; @Override public void buildSeat() &#123; mBike.setSeat(&quot;橡胶车座&quot;); &#125; @Override public Bike createBike() &#123; return mBike; &#125;&#125;//指挥者类public class Director &#123; private Builder mBuilder; public Director(Builder builder) &#123; mBuilder = builder; &#125; public Bike construct() &#123; mBuilder.buildFrame(); mBuilder.buildSeat(); return mBuilder.createBike(); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; showBike(new OfoBuilder()); showBike(new MobikeBuilder()); &#125; private static void showBike(Builder builder) &#123; Director director = new Director(builder); Bike bike = director.construct(); System.out.println(bike.getFrame()); System.out.println(bike.getSeat()); &#125;&#125; 注意： 上面示例是 Builder模式的常规用法，指挥者类 Director 在建造者模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，可以把指挥者类和抽象建造者进行结合 123456789101112131415// 抽象 builder 类public abstract class Builder &#123; protected Bike mBike = new Bike(); public abstract void buildFrame(); public abstract void buildSeat(); public abstract Bike createBike(); public Bike construct() &#123; this.buildFrame(); this.BuildSeat(); return this.createBike(); &#125;&#125; 说明： 这样做确实简化了系统结构，但同时也加重了抽象建造者类的职责，也不是太符合单一职责原则，如果construct() 过于复杂，建议还是封装到 Director 中。 4.4.4 优缺点优点： 建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。 建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。 缺点： 造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。 4.4.5 使用场景建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。 创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。 创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。 4.4.6 模式扩展建造者模式除了上面的用途外，在开发中还有一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用建造者模式进行重构。 重构前代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Phone &#123; private String cpu; private String screen; private String memory; private String mainboard; public Phone(String cpu, String screen, String memory, String mainboard) &#123; this.cpu = cpu; this.screen = screen; this.memory = memory; this.mainboard = mainboard; &#125; public String getCpu() &#123; return cpu; &#125; public void setCpu(String cpu) &#123; this.cpu = cpu; &#125; public String getScreen() &#123; return screen; &#125; public void setScreen(String screen) &#123; this.screen = screen; &#125; public String getMemory() &#123; return memory; &#125; public void setMemory(String memory) &#123; this.memory = memory; &#125; public String getMainboard() &#123; return mainboard; &#125; public void setMainboard(String mainboard) &#123; this.mainboard = mainboard; &#125; @Override public String toString() &#123; return &quot;Phone&#123;&quot; + &quot;cpu=&#x27;&quot; + cpu + &#x27;\\&#x27;&#x27; + &quot;, screen=&#x27;&quot; + screen + &#x27;\\&#x27;&#x27; + &quot;, memory=&#x27;&quot; + memory + &#x27;\\&#x27;&#x27; + &quot;, mainboard=&#x27;&quot; + mainboard + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; //构建Phone对象 Phone phone = new Phone(&quot;intel&quot;,&quot;三星屏幕&quot;,&quot;金士顿&quot;,&quot;华硕&quot;); System.out.println(phone); &#125;&#125; 上面在客户端代码中构建Phone对象，传递了四个参数，如果参数更多呢？代码的可读性及使用的成本就是比较高。 重构后代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Phone &#123; private String cpu; private String screen; private String memory; private String mainboard; private Phone(Builder builder) &#123; cpu = builder.cpu; screen = builder.screen; memory = builder.memory; mainboard = builder.mainboard; &#125; public static final class Builder &#123; private String cpu; private String screen; private String memory; private String mainboard; public Builder() &#123;&#125; public Builder cpu(String val) &#123; cpu = val; return this; &#125; public Builder screen(String val) &#123; screen = val; return this; &#125; public Builder memory(String val) &#123; memory = val; return this; &#125; public Builder mainboard(String val) &#123; mainboard = val; return this; &#125; public Phone build() &#123; return new Phone(this);&#125; &#125; @Override public String toString() &#123; return &quot;Phone&#123;&quot; + &quot;cpu=&#x27;&quot; + cpu + &#x27;\\&#x27;&#x27; + &quot;, screen=&#x27;&quot; + screen + &#x27;\\&#x27;&#x27; + &quot;, memory=&#x27;&quot; + memory + &#x27;\\&#x27;&#x27; + &quot;, mainboard=&#x27;&quot; + mainboard + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; Phone phone = new Phone.Builder() .cpu(&quot;intel&quot;) .mainboard(&quot;华硕&quot;) .memory(&quot;金士顿&quot;) .screen(&quot;三星&quot;) .build(); System.out.println(phone); &#125;&#125; 重构后的代码在使用起来更方便，某种程度上也可以提高开发效率。从软件设计上，对程序员的要求比较高。 4.6 创建者模式对比4.6.1 工厂方法模式VS建造者模式工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。 我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，于是一个超人就诞生了。 4.6.2 抽象工厂模式VS建造者模式抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。 建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。 如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式（一）","slug":"设计模式/设计模式（一）","date":"2023-06-16T03:31:38.000Z","updated":"2023-06-16T03:35:08.745Z","comments":true,"path":"2023/06/16/设计模式/设计模式（一）/","link":"","permalink":"http://example.com/2023/06/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"1，设计模式概述1.1 软件设计模式的产生背景“设计模式”最初并不是出现在软件设计中，而是被用于建筑领域的设计中。 1977年美国著名建筑大师、加利福尼亚大学伯克利分校环境结构中心主任克里斯托夫·亚历山大（Christopher Alexander）在他的著作《建筑模式语言：城镇、建筑、构造》中描述了一些常见的建筑设计问题，并提出了 253 种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式。 1990年软件工程界开始研讨设计模式的话题，后来召开了多次关于设计模式的研讨会。直到1995 年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》一书，在此书中收录了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4 位作者在软件开发领域里也以他们的“四人组”（Gang of Four，GoF）著称。 1.2 软件设计模式的概念软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。 1.3 学习设计模式的必要性设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。 正确使用设计模式具有以下优点。 可以提高程序员的思维能力、编程能力和设计能力。 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。 1.4 设计模式分类 创建型模式 用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF（四人组）书中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。 结构型模式 用于描述如何将类或对象按某种布局组成更大的结构，GoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。 行为型模式 用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。 2，UML图统一建模语言（Unified Modeling Language，UML）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。 UML 从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图。 2.1 类图概述类图(Class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。 2.2 类图的作用 在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解； 类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型。 2.3 类图表示法2.3.1 类的表示方式在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name,age和address这3个属性，以及work()方法。 属性&#x2F;方法名称前加的加号和减号表示了这个属性&#x2F;方法的可见性，UML类图中表示可见性的符号有三种： +：表示public -：表示private #：表示protected 属性的完整表示方式是： 可见性 名称 ：类型 [ &#x3D; 缺省值] 方法的完整表示方式是： 可见性 名称(参数列表) [ ： 返回类型] 注意： ​ 1，中括号中的内容表示是可选的 ​ 2，也有将类型放在变量名前面，返回值类型放在方法名前面 举个栗子： 上图Demo类定义了三个方法： method()方法：修饰符为public，没有参数，没有返回值。 method1()方法：修饰符为private，没有参数，返回值类型为String。 method2()方法：修饰符为protected，接收两个参数，第一个参数类型为int，第二个参数类型为String，返回值类型是int。 2.3.2 类与类之间关系的表示方式2.3.2.1 关联关系关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。 关联又可以分为单向关联，双向关联，自关联。 1，单向关联 在UML类图中单向关联用一个带箭头的实线表示。上图表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。 2，双向关联 从上图中我们很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。 在UML类图中，双向关联用一个不带箭头的直线表示。上图中在Customer类中维护一个List&lt;Product&gt;，表示一个顾客可以购买多个商品；在Product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买。 3，自关联 自关联在UML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是“自己包含自己”。 2.3.2.2 聚合关系聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系。 聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。 在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。下图所示是大学和教师的关系图： 2.3.2.3 组合关系组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。 在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。 在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。下图所示是头和嘴的关系图： 2.3.2.4 依赖关系依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。 在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。下图所示是司机和汽车的关系图，司机驾驶汽车： 2.3.2.5 继承关系继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。 在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如下图所示： 2.3.2.6 实现关系实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。 在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如图 9 所示。 3，软件设计原则在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。 3.1 开闭原则对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。 想要达到这样的效果，我们需要使用接口和抽象类。 因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。 下面以 搜狗输入法 的皮肤为例介绍开闭原则的应用。 【例】搜狗输入法 的皮肤设计。 分析：搜狗输入法 的皮肤是输入法背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的输入法的皮肤，也可以从网上下载新的皮肤。这些皮肤有共同的特点，可以为其定义一个抽象类（AbstractSkin），而每个具体的皮肤（DefaultSpecificSkin和HeimaSpecificSkin）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的。 3.2 里氏代换原则里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则：任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。 如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。 下面看一个里氏替换原则中经典的一个例子 【例】正方形不是长方形。 在数学领域里，正方形毫无疑问是长方形，它是一个长宽相等的长方形。所以，我们开发的一个与几何图形相关的软件系统，就可以顺理成章的让正方形继承自长方形。 代码如下： 长方形类（Rectangle）： 1234567891011121314151617181920public class Rectangle &#123; private double length; private double width; public double getLength() &#123; return length; &#125; public void setLength(double length) &#123; this.length = length; &#125; public double getWidth() &#123; return width; &#125; public void setWidth(double width) &#123; this.width = width; &#125;&#125; 正方形（Square）： 由于正方形的长和宽相同，所以在方法setLength和setWidth中，对长度和宽度都需要赋相同值。 123456789101112public class Square extends Rectangle &#123; public void setWidth(double width) &#123; super.setLength(width); super.setWidth(width); &#125; public void setLength(double length) &#123; super.setLength(length); super.setWidth(length); &#125;&#125; 类RectangleDemo是我们的软件系统中的一个组件，它有一个resize方法依赖基类Rectangle，resize方法是RectandleDemo类中的一个方法，用来实现宽度逐渐增长的效果。 1234567891011121314151617181920212223242526272829public class RectangleDemo &#123; public static void resize(Rectangle rectangle) &#123; while (rectangle.getWidth() &lt;= rectangle.getLength()) &#123; rectangle.setWidth(rectangle.getWidth() + 1); &#125; &#125; //打印长方形的长和宽 public static void printLengthAndWidth(Rectangle rectangle) &#123; System.out.println(rectangle.getLength()); System.out.println(rectangle.getWidth()); &#125; public static void main(String[] args) &#123; Rectangle rectangle = new Rectangle(); rectangle.setLength(20); rectangle.setWidth(10); resize(rectangle); printLengthAndWidth(rectangle); System.out.println(&quot;============&quot;); Rectangle rectangle1 = new Square(); rectangle1.setLength(10); resize(rectangle1); printLengthAndWidth(rectangle1); &#125;&#125; 我们运行一下这段代码就会发现，假如我们把一个普通长方形作为参数传入resize方法，就会看到长方形宽度逐渐增长的效果，当宽度大于长度,代码就会停止，这种行为的结果符合我们的预期；假如我们再把一个正方形作为参数传入resize方法后，就会看到正方形的宽度和长度都在不断增长，代码会一直运行下去，直至系统产生溢出错误。所以，普通的长方形是适合这段代码的，正方形不适合。我们得出结论：在resize方法中，Rectangle类型的参数是不能被Square类型的参数所代替，如果进行了替换就得不到预期结果。因此，Square类和Rectangle类之间的继承关系违反了里氏代换原则，它们之间的继承关系不成立，正方形不是长方形。 如何改进呢？此时我们需要重新设计他们之间的关系。抽象出来一个四边形接口(Quadrilateral)，让Rectangle类和Square类实现Quadrilateral接口 3.3 依赖倒转原则高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。 下面看一个例子来理解依赖倒转原则 【例】组装电脑 现要组装一台电脑，需要配件cpu，硬盘，内存条。只有这些配置都有了，计算机才能正常的运行。选择cpu有很多选择，如Intel，AMD等，硬盘可以选择希捷，西数等，内存条可以选择金士顿，海盗船等。 类图如下： 代码如下： 希捷硬盘类（XiJieHardDisk）: 1234567891011public class XiJieHardDisk implements HardDisk &#123; public void save(String data) &#123; System.out.println(&quot;使用希捷硬盘存储数据&quot; + data); &#125; public String get() &#123; System.out.println(&quot;使用希捷希捷硬盘取数据&quot;); return &quot;数据&quot;; &#125;&#125; Intel处理器（IntelCpu）： 123456public class IntelCpu implements Cpu &#123; public void run() &#123; System.out.println(&quot;使用Intel处理器&quot;); &#125;&#125; 金士顿内存条（KingstonMemory）： 123456public class KingstonMemory implements Memory &#123; public void save() &#123; System.out.println(&quot;使用金士顿作为内存条&quot;); &#125;&#125; 电脑（Computer）： 1234567891011121314151617181920212223242526272829303132333435363738public class Computer &#123; private XiJieHardDisk hardDisk; private IntelCpu cpu; private KingstonMemory memory; public IntelCpu getCpu() &#123; return cpu; &#125; public void setCpu(IntelCpu cpu) &#123; this.cpu = cpu; &#125; public KingstonMemory getMemory() &#123; return memory; &#125; public void setMemory(KingstonMemory memory) &#123; this.memory = memory; &#125; public XiJieHardDisk getHardDisk() &#123; return hardDisk; &#125; public void setHardDisk(XiJieHardDisk hardDisk) &#123; this.hardDisk = hardDisk; &#125; public void run() &#123; System.out.println(&quot;计算机工作&quot;); cpu.run(); memory.save(); String data = hardDisk.get(); System.out.println(&quot;从硬盘中获取的数据为：&quot; + data); &#125;&#125; 测试类（TestComputer）： 测试类用来组装电脑。 12345678910public class TestComputer &#123; public static void main(String[] args) &#123; Computer computer = new Computer(); computer.setHardDisk(new XiJieHardDisk()); computer.setCpu(new IntelCpu()); computer.setMemory(new KingstonMemory()); computer.run(); &#125;&#125; 上面代码可以看到已经组装了一台电脑，但是似乎组装的电脑的cpu只能是Intel的，内存条只能是金士顿的，硬盘只能是希捷的，这对用户肯定是不友好的，用户有了机箱肯定是想按照自己的喜好，选择自己喜欢的配件。 根据依赖倒转原则进行改进： 代码我们只需要修改Computer类，让Computer类依赖抽象（各个配件的接口），而不是依赖于各个组件具体的实现类。 类图如下： 电脑（Computer）： 12345678910111213141516171819202122232425262728293031323334public class Computer &#123; private HardDisk hardDisk; private Cpu cpu; private Memory memory; public HardDisk getHardDisk() &#123; return hardDisk; &#125; public void setHardDisk(HardDisk hardDisk) &#123; this.hardDisk = hardDisk; &#125; public Cpu getCpu() &#123; return cpu; &#125; public void setCpu(Cpu cpu) &#123; this.cpu = cpu; &#125; public Memory getMemory() &#123; return memory; &#125; public void setMemory(Memory memory) &#123; this.memory = memory; &#125; public void run() &#123; System.out.println(&quot;计算机工作&quot;); &#125;&#125; 面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。 3.4 接口隔离原则客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。 下面看一个例子来理解接口隔离原则 【例】安全门案例 我们需要创建一个黑马品牌的安全门，该安全门具有防火、防水、防盗的功能。可以将防火，防水，防盗功能提取成一个接口，形成一套规范。类图如下： 上面的设计我们发现了它存在的问题，黑马品牌的安全门具有防盗，防水，防火的功能。现在如果我们还需要再创建一个传智品牌的安全门，而该安全门只具有防盗、防水功能呢？很显然如果实现SafetyDoor接口就违背了接口隔离原则，那么我们如何进行修改呢？看如下类图： 代码如下： AntiTheft（接口）： 123public interface AntiTheft &#123; void antiTheft();&#125; Fireproof（接口）： 123public interface Fireproof &#123; void fireproof();&#125; Waterproof（接口）： 123public interface Waterproof &#123; void waterproof();&#125; HeiMaSafetyDoor（类）： 1234567891011121314public class HeiMaSafetyDoor implements AntiTheft,Fireproof,Waterproof &#123; public void antiTheft() &#123; System.out.println(&quot;防盗&quot;); &#125; public void fireproof() &#123; System.out.println(&quot;防火&quot;); &#125; public void waterproof() &#123; System.out.println(&quot;防水&quot;); &#125;&#125; ItcastSafetyDoor（类）： 123456789public class ItcastSafetyDoor implements AntiTheft,Fireproof &#123; public void antiTheft() &#123; System.out.println(&quot;防盗&quot;); &#125; public void fireproof() &#123; System.out.println(&quot;防火&quot;); &#125;&#125; 3.5 迪米特法则迪米特法则又叫最少知识原则。 只和你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。 其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。 迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。 下面看一个例子来理解迪米特法则 【例】明星与经纪人的关系实例 明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。 类图如下： 代码如下： 明星类（Star） 1234567891011public class Star &#123; private String name; public Star(String name) &#123; this.name=name; &#125; public String getName() &#123; return name; &#125;&#125; 粉丝类（Fans） 1234567891011public class Fans &#123; private String name; public Fans(String name) &#123; this.name=name; &#125; public String getName() &#123; return name; &#125;&#125; 媒体公司类（Company） 1234567891011public class Company &#123; private String name; public Company(String name) &#123; this.name=name; &#125; public String getName() &#123; return name; &#125;&#125; 经纪人类（Agent） 12345678910111213141516171819202122232425public class Agent &#123; private Star star; private Fans fans; private Company company; public void setStar(Star star) &#123; this.star = star; &#125; public void setFans(Fans fans) &#123; this.fans = fans; &#125; public void setCompany(Company company) &#123; this.company = company; &#125; public void meeting() &#123; System.out.println(fans.getName() + &quot;与明星&quot; + star.getName() + &quot;见面了。&quot;); &#125; public void business() &#123; System.out.println(company.getName() + &quot;与明星&quot; + star.getName() + &quot;洽淡业务。&quot;); &#125;&#125; 3.6 合成复用原则合成复用原则是指：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。 通常类的复用分为继承复用和合成复用两种。 继承复用虽然有简单和易实现的优点，但它也存在以下缺点： 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。 采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点： 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。 对象间的耦合度低。可以在类的成员位置声明抽象。 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。 下面看一个例子来理解合成复用原则 【例】汽车分类管理程序 汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。类图如下： 从上面类图我们可以看到使用继承复用产生了很多子类，如果现在又有新的动力源或者新的颜色的话，就需要再定义新的类。我们试着将继承复用改为聚合复用看一下。 4，创建者模式创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。 这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。 创建型模式分为： 单例模式 工厂方法模式 抽象工程模式 原型模式 建造者模式 4.1 单例设计模式单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 4.1.1 单例模式的结构单例模式的主要有以下角色： 单例类。只能创建一个实例的类 访问类。使用单例类 4.1.2 单例模式的实现 单例设计模式分类两种： ​ 饿汉式：类加载就会导致该单实例对象被创建 ​ 懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建 饿汉式-方式1（静态变量方式） 12345678910111213141516/** * 饿汉式 * 静态变量创建类的对象 */public class Singleton &#123; //私有构造方法 private Singleton() &#123;&#125; //在成员位置创建该类的对象 private static Singleton instance = new Singleton(); //对外提供静态方法获取该对象 public static Singleton getInstance() &#123; return instance; &#125;&#125; 说明： ​ 该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。 饿汉式-方式2（静态代码块方式） 123456789101112131415161718192021/** * 恶汉式 * 在静态代码块中创建该类对象 */public class Singleton &#123; //私有构造方法 private Singleton() &#123;&#125; //在成员位置创建该类的对象 private static Singleton instance; static &#123; instance = new Singleton(); &#125; //对外提供静态方法获取该对象 public static Singleton getInstance() &#123; return instance; &#125;&#125; 说明： ​ 该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着类的加载而创建。所以和饿汉式的方式1基本上一样，当然该方式也存在内存浪费问题。 懒汉式-方式1（线程不安全） 1234567891011121314151617181920/** * 懒汉式 * 线程不安全 */public class Singleton &#123; //私有构造方法 private Singleton() &#123;&#125; //在成员位置创建该类的对象 private static Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() &#123; if(instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 说明： ​ 从上面代码我们可以看出该方式在成员位置声明Singleton类型的静态变量，并没有进行对象的赋值操作，那么什么时候赋值的呢？当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果。但是，如果是多线程环境，会出现线程安全问题。 懒汉式-方式2（线程安全） 1234567891011121314151617181920/** * 懒汉式 * 线程安全 */public class Singleton &#123; //私有构造方法 private Singleton() &#123;&#125; //在成员位置创建该类的对象 private static Singleton instance; //对外提供静态方法获取该对象 public static synchronized Singleton getInstance() &#123; if(instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 说明： ​ 该方式也实现了懒加载效果，同时又解决了线程安全问题。但是在getInstance()方法上添加了synchronized关键字，导致该方法的执行效果特别低。从上面代码我们可以看出，其实就是在初始化instance的时候才会出现线程安全问题，一旦初始化完成就不存在了。 懒汉式-方式3（双重检查锁） 再来讨论一下懒汉模式中加锁的问题，对于 getInstance() 方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要调整加锁的时机。由此也产生了一种新的实现模式：双重检查锁模式 123456789101112131415161718192021222324/** * 双重检查方式 */public class Singleton &#123; //私有构造方法 private Singleton() &#123;&#125; private static Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() &#123; //第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例 if(instance == null) &#123; synchronized (Singleton.class) &#123; //抢到锁之后再次判断是否为null if(instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。 要解决双重检查锁模式带来空指针异常的问题，只需要使用 volatile 关键字, volatile 关键字可以保证可见性和有序性。 123456789101112131415161718192021222324/** * 双重检查方式 */public class Singleton &#123; //私有构造方法 private Singleton() &#123;&#125; private static volatile Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() &#123; //第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际 if(instance == null) &#123; synchronized (Singleton.class) &#123; //抢到锁之后再次判断是否为空 if(instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 小结： 添加 volatile 关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。 懒汉式-方式4（静态内部类方式） 静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性&#x2F;方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 static 修饰，保证只被实例化一次，并且严格保证实例化顺序。 1234567891011121314151617/** * 静态内部类方式 */public class Singleton &#123; //私有构造方法 private Singleton() &#123;&#125; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; //对外提供静态方法获取该对象 public static Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 说明： ​ 第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder 并初始化INSTANCE，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。 小结： ​ 静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。 枚举方式 枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。 123456/** * 枚举方式 */public enum Singleton &#123; INSTANCE;&#125; 说明： ​ 枚举方式属于恶汉式方式。 4.1.3 存在的问题4.1.3.1 问题演示破坏单例模式： 使上面定义的单例类（Singleton）可以创建多个对象，枚举方式除外。有两种方式，分别是序列化和反射。 序列化反序列化 Singleton类： 1234567891011121314public class Singleton implements Serializable &#123; //私有构造方法 private Singleton() &#123;&#125; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; //对外提供静态方法获取该对象 public static Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; Test类： 123456789101112131415161718192021222324252627282930public class Test &#123; public static void main(String[] args) throws Exception &#123; //往文件中写对象 //writeObject2File(); //从文件中读取对象 Singleton s1 = readObjectFromFile(); Singleton s2 = readObjectFromFile(); //判断两个反序列化后的对象是否是同一个对象 System.out.println(s1 == s2); &#125; private static Singleton readObjectFromFile() throws Exception &#123; //创建对象输入流对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Think\\\\Desktop\\\\a.txt&quot;)); //第一个读取Singleton对象 Singleton instance = (Singleton) ois.readObject(); return instance; &#125; public static void writeObject2File() throws Exception &#123; //获取Singleton类的对象 Singleton instance = Singleton.getInstance(); //创建对象输出流 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Think\\\\Desktop\\\\a.txt&quot;)); //将instance对象写出到文件中 oos.writeObject(instance); &#125;&#125; 上面代码运行结果是false，表明序列化和反序列化已经破坏了单例设计模式。 反射 Singleton类： 1234567891011121314151617181920212223public class Singleton &#123; //私有构造方法 private Singleton() &#123;&#125; private static volatile Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() &#123; if(instance != null) &#123; return instance; &#125; synchronized (Singleton.class) &#123; if(instance != null) &#123; return instance; &#125; instance = new Singleton(); return instance; &#125; &#125;&#125; Test类： 123456789101112131415161718public class Test &#123; public static void main(String[] args) throws Exception &#123; //获取Singleton类的字节码对象 Class clazz = Singleton.class; //获取Singleton类的私有无参构造方法对象 Constructor constructor = clazz.getDeclaredConstructor(); //取消访问检查 constructor.setAccessible(true); //创建Singleton类的对象s1 Singleton s1 = (Singleton) constructor.newInstance(); //创建Singleton类的对象s2 Singleton s2 = (Singleton) constructor.newInstance(); //判断通过反射创建的两个Singleton对象是否是同一个对象 System.out.println(s1 == s2); &#125;&#125; 上面代码运行结果是false，表明序列化和反序列化已经破坏了单例设计模式 注意：枚举方式不会出现这两个问题。 4.1.3.2 问题的解决 序列化、反序列方式破坏单例模式的解决方法 在Singleton类中添加readResolve()方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。 Singleton类： 123456789101112131415161718192021public class Singleton implements Serializable &#123; //私有构造方法 private Singleton() &#123;&#125; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; //对外提供静态方法获取该对象 public static Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; /** * 下面是为了解决序列化反序列化破解单例模式 */ private Object readResolve() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 源码解析： ObjectInputStream类 1234567891011121314151617181920212223242526272829303132333435363738public final Object readObject() throws IOException, ClassNotFoundException&#123; ... // if nested read, passHandle contains handle of enclosing object int outerHandle = passHandle; try &#123; Object obj = readObject0(false);//重点查看readObject0方法 .....&#125; private Object readObject0(boolean unshared) throws IOException &#123; ... try &#123; switch (tc) &#123; ... case TC_OBJECT: return checkResolve(readOrdinaryObject(unshared));//重点查看readOrdinaryObject方法 ... &#125; &#125; finally &#123; depth--; bin.setBlockDataMode(oldMode); &#125; &#125; private Object readOrdinaryObject(boolean unshared) throws IOException &#123; ... //isInstantiable 返回true，执行 desc.newInstance()，通过反射创建新的单例类， obj = desc.isInstantiable() ? desc.newInstance() : null; ... // 在Singleton类中添加 readResolve 方法后 desc.hasReadResolveMethod() 方法执行结果为true if (obj != null &amp;&amp; handles.lookupException(passHandle) == null &amp;&amp; desc.hasReadResolveMethod()) &#123; // 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量 // 这样多次调用ObjectInputStream类中的readObject方法，继而就会调用我们定义的readResolve方法，所以返回的是同一个对象。 Object rep = desc.invokeReadResolve(obj); ... &#125; return obj;&#125; 反射方式破解单例的解决方法 123456789101112131415161718192021222324252627282930public class Singleton &#123; //私有构造方法 private Singleton() &#123; /* 反射破解单例模式需要添加的代码 */ if(instance != null) &#123; throw new RuntimeException(); &#125; &#125; private static volatile Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() &#123; if(instance != null) &#123; return instance; &#125; synchronized (Singleton.class) &#123; if(instance != null) &#123; return instance; &#125; instance = new Singleton(); return instance; &#125; &#125;&#125; 说明: ​ 这种方式比较好理解。当通过反射方式调用构造方法进行创建创建时，直接抛异常。不运行此中操作。 4.1.4 JDK源码解析-Runtime类Runtime类就是使用的单例设计模式。 通过源代码查看使用的是哪儿种单例模式 12345678910111213141516171819public class Runtime &#123; private static Runtime currentRuntime = new Runtime(); /** * Returns the runtime object associated with the current Java application. * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance * methods and must be invoked with respect to the current runtime object. * * @return the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current * Java application. */ public static Runtime getRuntime() &#123; return currentRuntime; &#125; /** Don&#x27;t let anyone else instantiate this class */ private Runtime() &#123;&#125; ...&#125; 从上面源代码中可以看出Runtime类使用的是恶汉式（静态属性）方式来实现单例模式的。 使用Runtime类中的方法 12345678910111213141516171819public class RuntimeDemo &#123; public static void main(String[] args) throws IOException &#123; //获取Runtime类对象 Runtime runtime = Runtime.getRuntime(); //返回 Java 虚拟机中的内存总量。 System.out.println(runtime.totalMemory()); //返回 Java 虚拟机试图使用的最大内存量。 System.out.println(runtime.maxMemory()); //创建一个新的进程执行指定的字符串命令，返回进程对象 Process process = runtime.exec(&quot;ipconfig&quot;); //获取命令执行后的结果，通过输入流获取 InputStream inputStream = process.getInputStream(); byte[] arr = new byte[1024 * 1024* 100]; int b = inputStream.read(arr); System.out.println(new String(arr,0,b,&quot;gbk&quot;)); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"test2","slug":"设计模式/test2","date":"2023-06-15T09:42:48.000Z","updated":"2023-06-16T01:57:15.031Z","comments":true,"path":"2023/06/15/设计模式/test2/","link":"","permalink":"http://example.com/2023/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/test2/","excerpt":"","text":"111","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}],"categories":[{"name":"elk","slug":"elk","permalink":"http://example.com/elk/"},{"name":"ts","slug":"ts","permalink":"http://example.com/ts/"},{"name":"juc","slug":"juc","permalink":"http://example.com/juc/"},{"name":"mq","slug":"mq","permalink":"http://example.com/mq/"},{"name":"spring","slug":"spring","permalink":"http://example.com/spring/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"elk","slug":"elk","permalink":"http://example.com/tags/elk/"},{"name":"ts","slug":"ts","permalink":"http://example.com/tags/ts/"},{"name":"juc","slug":"juc","permalink":"http://example.com/tags/juc/"},{"name":"mq","slug":"mq","permalink":"http://example.com/tags/mq/"},{"name":"spring","slug":"spring","permalink":"http://example.com/tags/spring/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}